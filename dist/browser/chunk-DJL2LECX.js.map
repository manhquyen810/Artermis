{"version":3,"sources":["node_modules/ngx-infinite-scroll/fesm2022/ngx-infinite-scroll.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n  if (selector) {\n    const containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n  return container;\n}\nfunction findElement(selector, customRoot, fromRoot) {\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\nconst VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\nclass AxisResolver {\n  constructor(vertical = true) {\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n  topKey() {\n    return this.propsMap.top;\n  }\n}\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n  return false;\n}\nfunction createResolver({\n  windowElement,\n  axis\n}) {\n  return createResolverWithContainer({\n    axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\nfunction createResolverWithContainer(resolver, windowElement) {\n  const container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return {\n    ...resolver,\n    container\n  };\n}\nfunction isElementWindow(windowElement) {\n  const isWindow = ['Window', 'global'].some(obj => Object.prototype.toString.call(windowElement).includes(obj));\n  return isWindow;\n}\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\nfunction calculatePoints(element, resolver) {\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\nfunction calculatePointsForWindow(height, element, resolver) {\n  const {\n    axis,\n    container,\n    isWindow\n  } = resolver;\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  // scrolled until now / current y point\n  const scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n  // total height / most bottom y point\n  const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow\n  };\n}\nfunction calculatePointsForElement(height, element, resolver) {\n  const {\n    axis,\n    container\n  } = resolver;\n  // perhaps use container.offsetTop instead of 'scrollTop'\n  const scrolled = container[axis.scrollTopKey()];\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow: false\n  };\n}\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\nfunction extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}) {\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  const topKey = axis.topKey();\n  // elem = elem.nativeElement;\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  const pageYOffset = axis.pageYOffsetKey();\n  const scrollTop = axis.scrollTopKey();\n  const offsetTop = axis.offsetTopKey();\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\nfunction shouldFireScrollEvent(container, distance = {\n  down: 0,\n  up: 0\n}, scrollingDown) {\n  let remaining;\n  let containerBreakpoint;\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    const distanceDown = distance?.down ? distance.down : 0;\n    containerBreakpoint = distanceDown / 10;\n  } else {\n    const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    const distanceUp = distance?.up ? distance.up : 0;\n    containerBreakpoint = distanceUp / 10;\n  }\n  const shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\nfunction updateScrollPosition(position, scrollState) {\n  return scrollState.lastScrollPosition = position;\n}\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\nfunction isSameTotalToScroll(scrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n  return isScrollingDown ? scrollState.triggered.down === totalToScroll : scrollState.triggered.up === totalToScroll;\n}\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState);\n  // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\nclass ScrollState {\n  constructor(attrs) {\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    Object.assign(this, attrs);\n  }\n  updateScrollPosition(position) {\n    return this.lastScrollPosition = position;\n  }\n  updateTotalToScroll(totalToScroll) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n  updateScroll(scrolledUntilNow, totalToScroll) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n  updateTriggeredFlag(scroll, isScrollingDown) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n  isTriggeredScroll(totalToScroll, isScrollingDown) {\n    return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n  }\n}\nfunction createScroller(config) {\n  const {\n    scrollContainer,\n    scrollWindow,\n    element,\n    fromRoot\n  } = config;\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver).totalToScroll\n  });\n  const options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map(positionStats => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({\n    stats\n  }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({\n    fire,\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => {\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\nfunction attachScrollEvent(options) {\n  let obs = fromEvent(options.container, 'scroll');\n  // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle, undefined, {\n      leading: true,\n      trailing: true\n    }));\n  }\n  return obs;\n}\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  const {\n    scrollDown,\n    fire\n  } = getScrollStats(lastScrollPosition, stats, distance);\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\nconst InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\nfunction toInfiniteScrollAction(response) {\n  const {\n    scrollDown,\n    stats: {\n      scrolled: currentScrollPosition\n    }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\nlet InfiniteScrollDirective = /*#__PURE__*/(() => {\n  class InfiniteScrollDirective {\n    constructor(element, zone) {\n      this.element = element;\n      this.zone = zone;\n      this.scrolled = new EventEmitter();\n      this.scrolledUp = new EventEmitter();\n      this.infiniteScrollDistance = 2;\n      this.infiniteScrollUpDistance = 1.5;\n      this.infiniteScrollThrottle = 150;\n      this.infiniteScrollDisabled = false;\n      this.infiniteScrollContainer = null;\n      this.scrollWindow = true;\n      this.immediateCheck = false;\n      this.horizontal = false;\n      this.alwaysCallback = false;\n      this.fromRoot = false;\n    }\n    ngAfterViewInit() {\n      if (!this.infiniteScrollDisabled) {\n        this.setup();\n      }\n    }\n    ngOnChanges({\n      infiniteScrollContainer,\n      infiniteScrollDisabled,\n      infiniteScrollDistance\n    }) {\n      const containerChanged = inputPropChanged(infiniteScrollContainer);\n      const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n      const distanceChanged = inputPropChanged(infiniteScrollDistance);\n      const shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n      if (containerChanged || disabledChanged || distanceChanged) {\n        this.destroyScroller();\n        if (shouldSetup) {\n          this.setup();\n        }\n      }\n    }\n    ngOnDestroy() {\n      this.destroyScroller();\n    }\n    setup() {\n      if (!hasWindowDefined()) {\n        return;\n      }\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe(payload => this.handleOnScroll(payload));\n      });\n    }\n    handleOnScroll({\n      type,\n      payload\n    }) {\n      const emitter = type === InfiniteScrollActions.DOWN ? this.scrolled : this.scrolledUp;\n      if (hasObservers(emitter)) {\n        this.zone.run(() => emitter.emit(payload));\n      }\n    }\n    destroyScroller() {\n      if (this.disposeScroller) {\n        this.disposeScroller.unsubscribe();\n      }\n    }\n    static {\n      this.ɵfac = function InfiniteScrollDirective_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || InfiniteScrollDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n      };\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: InfiniteScrollDirective,\n        selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n        inputs: {\n          infiniteScrollDistance: \"infiniteScrollDistance\",\n          infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n          infiniteScrollThrottle: \"infiniteScrollThrottle\",\n          infiniteScrollDisabled: \"infiniteScrollDisabled\",\n          infiniteScrollContainer: \"infiniteScrollContainer\",\n          scrollWindow: \"scrollWindow\",\n          immediateCheck: \"immediateCheck\",\n          horizontal: \"horizontal\",\n          alwaysCallback: \"alwaysCallback\",\n          fromRoot: \"fromRoot\"\n        },\n        outputs: {\n          scrolled: \"scrolled\",\n          scrolledUp: \"scrolledUp\"\n        },\n        features: [i0.ɵɵNgOnChangesFeature]\n      });\n    }\n  }\n  return InfiniteScrollDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction hasObservers(emitter) {\n  // Note: The `observed` property is available only in RxJS@7.2.0, which means it's\n  // not available for users running the lower version.\n  return emitter.observed ?? emitter.observers.length > 0;\n}\n\n/**\n * @deprecated Import InfiniteScrollDirective instead\n */\nlet InfiniteScrollModule = /*#__PURE__*/(() => {\n  class InfiniteScrollModule {\n    static {\n      this.ɵfac = function InfiniteScrollModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || InfiniteScrollModule)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: InfiniteScrollModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return InfiniteScrollModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule };\n"],"mappings":"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","names":["resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","container","findElement","customRoot","inputPropChanged","prop","hasWindowDefined","VerticalProps","HorizontalProps","AxisResolver","vertical","shouldTriggerEvents","alwaysCallback","shouldFireScrollEvent","isTriggeredCurrentTotal","createResolver","windowElement","axis","createResolverWithContainer","isElementWindow","resolver","__spreadProps","__spreadValues","obj","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","isWindow","offsetHeightKey","clientHeightKey","extractHeightPropKeys","scrolled","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","elem","docElem","topKey","pageYOffset","scrollTop","offsetTop","distance","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","totalHiddenContentHeight","isScrollingDownwards","lastScrollPosition","getScrollStats","scrollDown","ScrollState","attrs","position","totalToScroll","scrolledUntilNow","scroll","isScrollingDown","createScroller","config","scrollContainer","scrollWindow","element","fromRoot","resolver","createResolver","AxisResolver","resolveContainerElement","scrollState","calculatePoints","options","distance","attachScrollEvent","mergeMap","of","map","positionStats","toInfiniteScrollParams","tap","stats","filter","fire","scrollDown","shouldTriggerEvents","toInfiniteScrollAction","obs","fromEvent","throttleTime","lastScrollPosition","getScrollStats","InfiniteScrollActions","response","currentScrollPosition","InfiniteScrollDirective","zone","EventEmitter","infiniteScrollContainer","infiniteScrollDisabled","infiniteScrollDistance","containerChanged","inputPropChanged","disabledChanged","distanceChanged","shouldSetup","hasWindowDefined","payload","type","emitter","hasObservers","__ngFactoryType__","ɵɵdirectiveInject","ElementRef","NgZone","ɵɵdefineDirective","ɵɵNgOnChangesFeature"],"x_google_ignoreList":[0]}