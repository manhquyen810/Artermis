{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/quiz/manage/quiz-exercise-interfaces.ts", "src/main/webapp/app/exercises/quiz/manage/quiz-exercise-validation.directive.ts"],
  "sourcesContent": ["export class Option {\r\n    key?: boolean | string;\r\n    label?: string;\r\n\r\n    constructor(key?: boolean | string, label?: string) {\r\n        this.key = key;\r\n        this.label = label;\r\n    }\r\n}\r\n\r\nexport class Duration {\r\n    minutes: number;\r\n    seconds: number;\r\n\r\n    constructor(minutes: number, seconds: number) {\r\n        this.minutes = minutes;\r\n        this.seconds = seconds;\r\n    }\r\n}\r\n", "import { ChangeDetectorRef, Directive, inject } from '@angular/core';\r\nimport { QuizExercise, QuizMode } from 'app/entities/quiz/quiz-exercise.model';\r\nimport { QuizQuestion, QuizQuestionType } from 'app/entities/quiz/quiz-question.model';\r\nimport { MultipleChoiceQuestion } from 'app/entities/quiz/multiple-choice-question.model';\r\nimport { ValidationReason } from 'app/entities/exercise.model';\r\nimport { ButtonType } from 'app/shared/components/button.component';\r\nimport { MAX_QUIZ_QUESTION_LENGTH_THRESHOLD } from 'app/shared/constants/input.constants';\r\nimport {\r\n    InvalidFlaggedQuestions,\r\n    checkForInvalidFlaggedQuestions,\r\n    computeQuizQuestionInvalidReason,\r\n    isQuizQuestionValid,\r\n} from 'app/exercises/quiz/shared/quiz-manage-util.service';\r\nimport { DragAndDropQuestionUtil } from 'app/exercises/quiz/shared/drag-and-drop-question-util.service';\r\nimport { ShortAnswerQuestionUtil } from 'app/exercises/quiz/shared/short-answer-question-util.service';\r\n\r\n@Directive()\r\nexport abstract class QuizExerciseValidationDirective {\r\n    protected dragAndDropQuestionUtil = inject(DragAndDropQuestionUtil);\r\n    protected shortAnswerQuestionUtil = inject(ShortAnswerQuestionUtil);\r\n\r\n    // Make constants available to html for comparison\r\n    readonly DRAG_AND_DROP = QuizQuestionType.DRAG_AND_DROP;\r\n    readonly MULTIPLE_CHOICE = QuizQuestionType.MULTIPLE_CHOICE;\r\n    readonly SHORT_ANSWER = QuizQuestionType.SHORT_ANSWER;\r\n    readonly QuizMode = QuizMode;\r\n    readonly ButtonType = ButtonType;\r\n\r\n    warningQuizCache = false;\r\n    quizIsValid: boolean;\r\n    quizExercise: QuizExercise;\r\n\r\n    savedEntity: QuizExercise;\r\n    isExamMode: boolean;\r\n    isImport: boolean;\r\n\r\n    invalidReasons: ValidationReason[];\r\n    invalidWarnings: ValidationReason[];\r\n\r\n    protected invalidFlaggedQuestions: InvalidFlaggedQuestions = {};\r\n    pendingChangesCache: boolean;\r\n\r\n    /**\r\n     * 1. Check whether the inputs in the quiz are valid\r\n     * 2. Check if warning are needed for the inputs\r\n     * 3. Display the warnings/invalid reasons in the html file if needed\r\n     */\r\n    cacheValidation(changeDetector: ChangeDetectorRef): void {\r\n        this.warningQuizCache = this.computeInvalidWarnings().length > 0;\r\n        this.quizIsValid = this.isValidQuiz();\r\n        this.pendingChangesCache = this.pendingChanges();\r\n        this.checkForInvalidFlaggedQuestions();\r\n        this.invalidReasons = this.computeInvalidReasons();\r\n        this.invalidWarnings = this.computeInvalidWarnings();\r\n        changeDetector.detectChanges();\r\n    }\r\n\r\n    isValidQuiz(): boolean {\r\n        if (!this.quizExercise) {\r\n            return false;\r\n        }\r\n\r\n        const isGenerallyValid =\r\n            this.quizExercise.title != undefined &&\r\n            this.quizExercise.title !== '' &&\r\n            this.quizExercise.title.length < MAX_QUIZ_QUESTION_LENGTH_THRESHOLD &&\r\n            this.quizExercise.duration !== 0 &&\r\n            this.quizExercise.quizQuestions != undefined &&\r\n            !!this.quizExercise.quizQuestions.length;\r\n\r\n        const areAllQuestionsValid = this.quizExercise.quizQuestions?.every(function (question) {\r\n            return isQuizQuestionValid(question, this.dragAndDropQuestionUtil, this.shortAnswerQuestionUtil);\r\n        }, this);\r\n        const maxPointsReachableInQuiz = this.quizExercise.quizQuestions?.map((quizQuestion) => quizQuestion.points ?? 0).reduce((a, b) => a + b, 0);\r\n\r\n        return (\r\n            isGenerallyValid &&\r\n            areAllQuestionsValid === true &&\r\n            maxPointsReachableInQuiz !== undefined &&\r\n            maxPointsReachableInQuiz > 0 &&\r\n            !this.testRunExistsAndShouldNotBeIgnored()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if the test runs for the quiz exist and should be ignored\r\n     * @returns {boolean} true if a test run exists for the quiz and should not be ignored\r\n     */\r\n    testRunExistsAndShouldNotBeIgnored(): boolean {\r\n        return !this.isImport && this.isExamMode && !!this.quizExercise.testRunParticipationsExist;\r\n    }\r\n\r\n    /**\r\n     * Get the reasons, why the quiz needs warnings\r\n     * @returns {Array} array of objects with fields 'translateKey' and 'translateValues'\r\n     */\r\n    computeInvalidWarnings(): ValidationReason[] {\r\n        const invalidWarnings = !this.quizExercise\r\n            ? []\r\n            : this.quizExercise.quizQuestions\r\n                  ?.map((question, index) => {\r\n                      if (question.type === QuizQuestionType.MULTIPLE_CHOICE && (<MultipleChoiceQuestion>question).answerOptions!.some((option) => !option.explanation)) {\r\n                          return {\r\n                              translateKey: 'artemisApp.quizExercise.invalidReasons.explanationIsMissing',\r\n                              translateValues: { index: index + 1 },\r\n                          };\r\n                      }\r\n                  })\r\n                  .filter(Boolean);\r\n\r\n        return invalidWarnings as ValidationReason[];\r\n    }\r\n\r\n    /**\r\n     * Get the reasons, why the quiz is invalid\r\n     * @returns {Array} array of objects with fields 'translateKey' and 'translateValues'\r\n     */\r\n    computeInvalidReasons(): ValidationReason[] {\r\n        const invalidReasons = new Array<ValidationReason>();\r\n        if (!this.quizExercise) {\r\n            return [];\r\n        }\r\n\r\n        if (!this.quizExercise.title || this.quizExercise.title === '') {\r\n            invalidReasons.push({\r\n                translateKey: 'artemisApp.quizExercise.invalidReasons.quizTitle',\r\n                translateValues: {},\r\n            });\r\n        }\r\n        if (this.quizExercise.title!.length >= MAX_QUIZ_QUESTION_LENGTH_THRESHOLD) {\r\n            invalidReasons.push({\r\n                translateKey: 'artemisApp.quizExercise.invalidReasons.quizTitleLength',\r\n                translateValues: { threshold: MAX_QUIZ_QUESTION_LENGTH_THRESHOLD },\r\n            });\r\n        }\r\n        if (!this.quizExercise.duration) {\r\n            invalidReasons.push({\r\n                translateKey: 'artemisApp.quizExercise.invalidReasons.quizDuration',\r\n                translateValues: {},\r\n            });\r\n        }\r\n        if (!this.quizExercise.quizQuestions || this.quizExercise.quizQuestions.length === 0) {\r\n            invalidReasons.push({\r\n                translateKey: 'artemisApp.quizExercise.invalidReasons.noQuestion',\r\n                translateValues: {},\r\n            });\r\n        }\r\n        if (this.testRunExistsAndShouldNotBeIgnored()) {\r\n            invalidReasons.push({\r\n                translateKey: 'artemisApp.quizExercise.edit.testRunSubmissionsExist',\r\n                translateValues: {},\r\n            });\r\n        }\r\n\r\n        // TODO: quiz cleanup: properly validate start (and due) date and deduplicate the checks (see isValidQuiz)\r\n        /** We only verify the releaseDate if the checkbox is activated **/\r\n        // if (this.quizExercise.isPlannedToStart) {\r\n        //     if (!this.quizExercise.releaseDate || !dayjs(this.quizExercise.releaseDate).isValid()) {\r\n        //         invalidReasons.push({\r\n        //             translateKey: 'artemisApp.quizExercise.invalidReasons.invalidStartTime',\r\n        //             translateValues: {},\r\n        //         });\r\n        //     }\r\n        // }\r\n        this.quizExercise.quizQuestions!.forEach(function (question: QuizQuestion, index: number) {\r\n            computeQuizQuestionInvalidReason(invalidReasons, question, index, this.dragAndDropQuestionUtil, this.shortAnswerQuestionUtil);\r\n        }, this);\r\n        const invalidFlaggedReasons = !this.quizExercise\r\n            ? []\r\n            : this.quizExercise.quizQuestions\r\n                  ?.map((question, index) => {\r\n                      if (this.invalidFlaggedQuestions[question.id!]) {\r\n                          return {\r\n                              translateKey: 'artemisApp.quizExercise.invalidReasons.questionHasInvalidFlaggedElements',\r\n                              translateValues: { index: index + 1 },\r\n                          };\r\n                      }\r\n                  })\r\n                  .filter(Boolean);\r\n\r\n        return invalidReasons.concat(invalidFlaggedReasons as ValidationReason[]);\r\n    }\r\n\r\n    /**\r\n     * @function pendingChanges\r\n     * @desc Determine if there are any changes waiting to be saved\r\n     * @returns {boolean} true if there are any pending changes, false otherwise\r\n     */\r\n    pendingChanges(): boolean {\r\n        if (!this.quizExercise || !this.savedEntity) {\r\n            return false;\r\n        }\r\n        return JSON.stringify(this.quizExercise) !== JSON.stringify(this.savedEntity);\r\n    }\r\n\r\n    checkForInvalidFlaggedQuestions() {\r\n        if (!this.quizExercise) {\r\n            return;\r\n        }\r\n        this.invalidFlaggedQuestions = checkForInvalidFlaggedQuestions(this.quizExercise.quizQuestions ?? []);\r\n    }\r\n\r\n    /**\r\n     * check if Dictionary is empty\r\n     * @param obj the dictionary to be checked\r\n     */\r\n    protected isEmpty(obj: any) {\r\n        return Object.keys(obj).length === 0;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["Duration", "minutes", "seconds", "constructor", "QuizExerciseValidationDirective", "dragAndDropQuestionUtil", "inject", "DragAndDropQuestionUtil", "shortAnswerQuestionUtil", "ShortAnswerQuestionUtil", "DRAG_AND_DROP", "QuizQuestionType", "MULTIPLE_CHOICE", "SHORT_ANSWER", "QuizMode", "ButtonType", "warningQuizCache", "quizIsValid", "quizExercise", "savedEntity", "isExamMode", "isImport", "invalidReasons", "invalidWarnings", "invalidFlaggedQuestions", "pendingChangesCache", "cacheValidation", "changeDetector", "computeInvalidWarnings", "length", "isValidQuiz", "pendingChanges", "checkForInvalidFlaggedQuestions", "computeInvalidReasons", "detectChanges", "isGenerallyValid", "title", "undefined", "MAX_QUIZ_QUESTION_LENGTH_THRESHOLD", "duration", "quizQuestions", "areAllQuestionsValid", "every", "question", "isQuizQuestionValid", "maxPointsReachableInQuiz", "map", "quizQuestion", "points", "reduce", "a", "b", "testRunExistsAndShouldNotBeIgnored", "testRunParticipationsExist", "index", "type", "answerOptions", "some", "option", "explanation", "translateKey", "translateValues", "filter", "Boolean", "Array", "push", "threshold", "forEach", "computeQuizQuestionInvalidReason", "invalidFlaggedReasons", "id", "concat", "JSON", "stringify", "isEmpty", "obj", "Object", "keys"]
}
