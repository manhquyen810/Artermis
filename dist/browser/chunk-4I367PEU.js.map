{
  "version": 3,
  "sources": ["src/main/webapp/app/core/theme/theme.service.ts"],
  "sourcesContent": ["import { Injectable, computed, effect, inject, signal, untracked } from '@angular/core';\r\nimport { IconDefinition, faMoon, faSun } from '@fortawesome/free-solid-svg-icons';\r\nimport { LocalStorageService } from 'ngx-webstorage';\r\n\r\nexport const THEME_LOCAL_STORAGE_KEY = 'artemisapp.theme.preference';\r\nexport const THEME_OVERRIDE_ID = 'artemis-theme-override';\r\n\r\n/**\r\n * Contains definitions for a theme.\r\n * If you add new themes, make sure to adapt the theme switch component which currently only supports two themes.\r\n */\r\nexport class Theme {\r\n    public static readonly LIGHT = new Theme('LIGHT', true, undefined, faSun);\r\n    public static readonly DARK = new Theme('DARK', false, 'theme-dark.css', faMoon);\r\n\r\n    private constructor(identifier: string, isDefault: boolean, fileName: string | undefined, icon: IconDefinition) {\r\n        this.identifier = identifier;\r\n        this.isDefault = isDefault;\r\n        this.fileName = fileName;\r\n        this.icon = icon;\r\n    }\r\n\r\n    public readonly identifier: string;\r\n    public readonly isDefault: boolean;\r\n    public readonly fileName: string | undefined;\r\n    public readonly icon: IconDefinition;\r\n\r\n    /**\r\n     * Returns an array with all available themes.\r\n     */\r\n    public static get all(): Theme[] {\r\n        return [this.LIGHT, this.DARK];\r\n    }\r\n}\r\n\r\n/**\r\n * Service that manages application UI theming.\r\n * Provides the current theme information to other components and services.\r\n * Applies new themes as requested from other components / services, usually the theme switcher component.\r\n */\r\n@Injectable({\r\n    providedIn: 'root',\r\n})\r\nexport class ThemeService {\r\n    /**\r\n     * The user preference changes as WritableSignal.\r\n     * If changed, the theme is applied immediately.\r\n     */\r\n    private _userPreference = signal<Theme | undefined>(undefined);\r\n\r\n    /**\r\n     * The user preference changes as ReadonlySignal.\r\n     * Can be either a theme for an explicit theme or undefined if system settings are preferred.\r\n     */\r\n    public readonly userPreference = this._userPreference.asReadonly();\r\n\r\n    /**\r\n     * The system preference as WritableSignal.\r\n     */\r\n    private systemPreference = signal<Theme>(Theme.LIGHT);\r\n\r\n    /**\r\n     * The currently applied theme as Signal.\r\n     */\r\n    public currentTheme = computed(() => this.userPreference() ?? this.systemPreference());\r\n\r\n    private localStorageService = inject(LocalStorageService);\r\n\r\n    private darkSchemeMediaQuery: MediaQueryList;\r\n\r\n    constructor() {\r\n        effect(() => {\r\n            // Apply the theme as soon as the currentTheme changes\r\n            const currentTheme = this.currentTheme();\r\n            untracked(() => this.applyTheme(currentTheme));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Should be called once on application startup.\r\n     * Sets up the system preference listener and applies the theme initially\r\n     * Sets up a local storage listener to account for changes in other tabs\r\n     */\r\n    initialize() {\r\n        this.darkSchemeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\r\n        if (this.darkSchemeMediaQuery.media !== 'not all') {\r\n            this.darkSchemeMediaQuery.addEventListener('change', () => {\r\n                if (this.darkSchemeMediaQuery.matches) {\r\n                    this.systemPreference.set(Theme.DARK);\r\n                } else {\r\n                    this.systemPreference.set(Theme.LIGHT);\r\n                }\r\n            });\r\n        }\r\n\r\n        addEventListener('storage', (event) => {\r\n            if (event.key === 'jhi-' + THEME_LOCAL_STORAGE_KEY) {\r\n                this._userPreference.set(this.getStoredThemePreference());\r\n            }\r\n        });\r\n\r\n        this.systemPreference.set(this.darkSchemeMediaQuery.matches ? Theme.DARK : Theme.LIGHT);\r\n        this._userPreference.set(this.getStoredThemePreference());\r\n    }\r\n\r\n    /**\r\n     * Returns the theme preference stored in local storage or undefined if no preference is stored\r\n     */\r\n    private getStoredThemePreference(): Theme | undefined {\r\n        const storedIdentifier = this.localStorageService.retrieve(THEME_LOCAL_STORAGE_KEY);\r\n        const storedTheme = Theme.all.find((theme) => theme.identifier === storedIdentifier);\r\n\r\n        // An unknown theme was stored. Let's clear it\r\n        if (storedIdentifier && !storedTheme) {\r\n            this.localStorageService.clear(THEME_LOCAL_STORAGE_KEY);\r\n        }\r\n\r\n        return storedTheme;\r\n    }\r\n\r\n    /**\r\n     * Prints the current page.\r\n     * Disables any theme override before doing that to ensure that we print in default theme.\r\n     * Resets the theme afterward if needed\r\n     */\r\n    public async print(): Promise<void> {\r\n        return new Promise<void>((resolve) => {\r\n            const overrideTag: any = document.getElementById(THEME_OVERRIDE_ID);\r\n            if (overrideTag) {\r\n                overrideTag.rel = 'none-tmp';\r\n            }\r\n            setTimeout(() => {\r\n                const notificationSidebarDisplayAttribute = this.hideNotificationSidebar();\r\n\r\n                window.print();\r\n\r\n                this.showNotificationSidebar(notificationSidebarDisplayAttribute);\r\n            }, 250);\r\n            setTimeout(() => {\r\n                if (overrideTag) {\r\n                    overrideTag.rel = 'stylesheet';\r\n                }\r\n                resolve();\r\n            }, 500);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Applies the specified theme preference.\r\n     * Should only be called upon user request.\r\n     * Stores the preference in local storage.\r\n     *\r\n     * @param preference the theme to be applied; pass undefined to use system preference mode\r\n     */\r\n    public applyThemePreference(preference: Theme | undefined) {\r\n        if (preference) {\r\n            this.localStorageService.store(THEME_LOCAL_STORAGE_KEY, preference.identifier);\r\n        } else {\r\n            this.localStorageService.clear(THEME_LOCAL_STORAGE_KEY);\r\n        }\r\n        this._userPreference.set(preference);\r\n    }\r\n\r\n    /**\r\n     * Applies the theme to the application.\r\n     *\r\n     * Only call if the theme changed.\r\n     *\r\n     * @param theme the theme to apply\r\n     */\r\n    private applyTheme(theme: Theme) {\r\n        // Get current <link> theme override\r\n        const overrideTag = document.getElementById(THEME_OVERRIDE_ID);\r\n\r\n        if (theme.isDefault) {\r\n            // The default theme is always injected by Angular; therefore, we just need to remove\r\n            // our theme override, if present\r\n            overrideTag?.remove();\r\n        } else {\r\n            // If the theme is not the default theme, we need to add a theme override stylesheet to the page header\r\n\r\n            // Select the head element\r\n            const head = document.getElementsByTagName('head')[0];\r\n\r\n            // Create new override tag from the current theme\r\n            const newTag = document.createElement('link');\r\n            newTag.id = THEME_OVERRIDE_ID;\r\n            newTag.rel = 'stylesheet';\r\n            // Use cache busting so the browser will reload the stylesheet at least once per hour\r\n            newTag.href = theme.fileName! + '?_=' + new Date().setMinutes(0, 0, 0);\r\n\r\n            // As soon as the new style sheet loaded, remove the old override (if present)\r\n            newTag.onload = () => {\r\n                overrideTag?.remove();\r\n            };\r\n\r\n            // Insert the new stylesheet link tag after the last existing link tag\r\n            const existingLinkTags = head.getElementsByTagName('link');\r\n            const lastLinkTag = existingLinkTags[existingLinkTags.length - 1];\r\n            head.insertBefore(newTag, lastLinkTag?.nextSibling);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hides the notification sidebar as there will be an overlay ove the whole page\r\n     * that covers details of the exam summary (=> exam summary cannot be read).\r\n     *\r\n     * @return displayAttribute of the notification sidebar before hiding it\r\n     */\r\n    private hideNotificationSidebar(): string {\r\n        return this.modifyNotificationSidebarDisplayStyling();\r\n    }\r\n\r\n    /**\r\n     * After printing the notification sidebar shall be displayed again.\r\n     *\r\n     * @param displayAttributeBeforeHide to reset the notification sidebar to its previous state\r\n     * @return displayAttribute of the notification sidebar before hiding it\r\n     */\r\n    private showNotificationSidebar(displayAttributeBeforeHide: string): string {\r\n        return this.modifyNotificationSidebarDisplayStyling(displayAttributeBeforeHide);\r\n    }\r\n\r\n    /**\r\n     * @param newDisplayAttribute that is set for the {@link NotificationSidebarComponent}\r\n     * @return displayAttribute of the notification sidebar before hiding it\r\n     */\r\n    private modifyNotificationSidebarDisplayStyling(newDisplayAttribute?: string): string {\r\n        const notificationSidebarElement: any = document.getElementById('notification-sidebar');\r\n        let displayBefore = '';\r\n\r\n        if (notificationSidebarElement) {\r\n            displayBefore = notificationSidebarElement.style.display;\r\n            notificationSidebarElement.style.display = newDisplayAttribute !== undefined ? newDisplayAttribute : 'none';\r\n        }\r\n        return displayBefore;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["THEME_LOCAL_STORAGE_KEY", "THEME_OVERRIDE_ID", "Theme", "LIGHT", "undefined", "faSun", "DARK", "faMoon", "constructor", "identifier", "isDefault", "fileName", "icon", "all", "ThemeService", "_userPreference", "signal", "userPreference", "asReadonly", "systemPreference", "currentTheme", "computed", "localStorageService", "inject", "LocalStorageService", "darkSchemeMediaQuery", "effect", "untracked", "applyTheme", "initialize", "window", "matchMedia", "media", "addEventListener", "matches", "set", "event", "key", "getStoredThemePreference", "storedIdentifier", "retrieve", "storedTheme", "find", "theme", "clear", "print", "__async", "Promise", "resolve", "overrideTag", "document", "getElementById", "rel", "setTimeout", "notificationSidebarDisplayAttribute", "hideNotificationSidebar", "showNotificationSidebar", "applyThemePreference", "preference", "store", "remove", "head", "getElementsByTagName", "newTag", "createElement", "id", "href", "Date", "setMinutes", "onload", "existingLinkTags", "lastLinkTag", "length", "insertBefore", "nextSibling", "modifyNotificationSidebarDisplayStyling", "displayAttributeBeforeHide", "newDisplayAttribute", "notificationSidebarElement", "displayBefore", "style", "display", "factory", "\u0275fac", "providedIn"]
}
