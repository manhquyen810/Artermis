{
  "version": 3,
  "sources": ["src/main/webapp/app/shared/image/session-storage-strategy.ts", "src/main/webapp/app/shared/image/cacheable-image.service.ts", "src/main/webapp/app/shared/image/secured-image.component.ts"],
  "sourcesContent": ["import { GlobalCacheConfig, ICachePair, IStorageStrategy } from 'ts-cacheable';\r\n\r\n/**\r\n * This is the same as the LocalStorageStrategy, only using the sessionStorage\r\n * instead of the localStorage: https://github.com/angelnikolov/ts-cacheable/blob/master/common/LocalStorageStrategy.ts\r\n */\r\nexport class SessionStorageStrategy extends IStorageStrategy {\r\n    private mainCacheKey: string = GlobalCacheConfig.globalCacheKey;\r\n    constructor() {\r\n        super();\r\n        if (sessionStorage == undefined) {\r\n            throw new Error('Platform not supported.');\r\n        }\r\n    }\r\n\r\n    add(cachePair: ICachePair<any>, cacheKey: string) {\r\n        const allCachedData = this.getRawData();\r\n        if (!allCachedData[cacheKey]) {\r\n            allCachedData[cacheKey] = [];\r\n        }\r\n        allCachedData[cacheKey].push(cachePair);\r\n        this.storeRawData(allCachedData);\r\n    }\r\n\r\n    addMany(entities: ICachePair<any>[], cacheKey: string) {\r\n        const allCachedData = this.getRawData();\r\n        if (!allCachedData[cacheKey]) {\r\n            allCachedData[cacheKey] = [];\r\n        }\r\n        allCachedData[cacheKey] = entities;\r\n        this.storeRawData(allCachedData);\r\n    }\r\n\r\n    getAll(cacheKey: string) {\r\n        return this.getRawData()[cacheKey] || [];\r\n    }\r\n\r\n    removeAtIndex(index: number, cacheKey: string) {\r\n        // we cannot pass null or undefined, but it's ok, because remove does not use the entity anyway\r\n        this.remove(index, {} as ICachePair<any>, cacheKey);\r\n    }\r\n\r\n    remove(index: number, entity: ICachePair<any>, cacheKey: string) {\r\n        const allCachedData = this.getRawData();\r\n        if (allCachedData[cacheKey] && allCachedData[cacheKey].length) {\r\n            allCachedData[cacheKey].splice(index, 1);\r\n        }\r\n        this.storeRawData(allCachedData);\r\n    }\r\n\r\n    updateAtIndex(index: number, entity: ICachePair<any>, cacheKey: string) {\r\n        this.update(index, entity, cacheKey);\r\n    }\r\n\r\n    update(index: number, entity: ICachePair<any>, cacheKey: string) {\r\n        const allCachedData = this.getRawData();\r\n        if (allCachedData[cacheKey] && allCachedData[cacheKey][index]) {\r\n            allCachedData[cacheKey][index] = entity;\r\n        }\r\n        this.storeRawData(allCachedData);\r\n    }\r\n\r\n    removeAll(cacheKey: string) {\r\n        const allCachedData = this.getRawData();\r\n        if (allCachedData[cacheKey] && allCachedData[cacheKey].length) {\r\n            allCachedData[cacheKey].length = 0;\r\n        }\r\n        this.storeRawData(allCachedData);\r\n    }\r\n\r\n    private getRawData(): { [key: string]: Array<ICachePair<any>> } {\r\n        const data = sessionStorage.getItem(this.mainCacheKey);\r\n        try {\r\n            return data ? JSON.parse(data) : {};\r\n        } catch (error) {\r\n            throw new Error(error);\r\n        }\r\n    }\r\n\r\n    private storeRawData(data: { [key: string]: Array<ICachePair<any>> }): void {\r\n        sessionStorage.setItem(this.mainCacheKey, JSON.stringify(data));\r\n    }\r\n}\r\n", "import { Injectable, OnDestroy, inject } from '@angular/core';\r\nimport { Cacheable, LocalStorageStrategy } from 'ts-cacheable';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable, Subject, Subscription, UnaryFunction, pipe } from 'rxjs';\r\nimport { distinctUntilChanged, switchMap, tap } from 'rxjs/operators';\r\nimport { AccountService } from 'app/core/auth/account.service';\r\nimport { SessionStorageStrategy } from 'app/shared/image/session-storage-strategy';\r\nimport { blobToBase64String } from 'app/utils/blob-util';\r\n\r\nconst logoutSubject = new Subject<void>();\r\n\r\n/**\r\n * Decides if an image (represented as Base64 string) should be stored in the cache.\r\n * Do not save too big images since space is limited.\r\n */\r\nconst shouldCacheDecider = (result: any) => {\r\n    if (typeof result === 'string') {\r\n        return result.length < 10_000;\r\n    }\r\n    // This should not happen since this service only works with strings.\r\n    return false;\r\n};\r\n\r\nexport interface ICacheableImageService {\r\n    loadCachedLocalStorage(url: string): Observable<any>;\r\n    loadCachedSessionStorage(url: string): Observable<any>;\r\n    loadWithoutCache(url: string): Observable<any>;\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class CacheableImageService implements ICacheableImageService, OnDestroy {\r\n    private accountService = inject(AccountService);\r\n    private httpClient = inject(HttpClient);\r\n\r\n    private userChangeSubscription: Subscription;\r\n\r\n    constructor() {\r\n        this.init();\r\n    }\r\n\r\n    /**\r\n     * Subscribe to the auth service to receive updates about user changes.\r\n     */\r\n    init(): void {\r\n        this.userChangeSubscription = this.accountService\r\n            .getAuthenticationState()\r\n            .pipe(\r\n                // Fires on every event where the user has changed (login/logout).\r\n                distinctUntilChanged(),\r\n                tap(() => logoutSubject.next()),\r\n            )\r\n            .subscribe();\r\n    }\r\n\r\n    ngOnDestroy(): void {\r\n        if (this.userChangeSubscription) {\r\n            this.userChangeSubscription.unsubscribe();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the image, cache it in the LocalStorage. Cache will only be cleared on logout.\r\n     * Important: Do _not_ use this for large images with more than 150KB because the LocalStorage is only 5-10 MB!\r\n     *\r\n     * @param url\r\n     */\r\n    @Cacheable({\r\n        storageStrategy: LocalStorageStrategy,\r\n        cacheBusterObserver: logoutSubject.asObservable(),\r\n        maxCacheCount: 30,\r\n        shouldCacheDecider,\r\n    })\r\n    public loadCachedLocalStorage(url: string): Observable<any> {\r\n        return this.httpClient.get(url, { responseType: 'blob' }).pipe(this.mapBlobToUrlString());\r\n    }\r\n\r\n    /**\r\n     * Load the image, cache them in the SessionStorage. Cache will be cleared on logout or when the browser is closed.\r\n     * Don't overuse this cache, the user could run out of RAM if we store too much in it.\r\n     *\r\n     * @param url\r\n     */\r\n    @Cacheable({\r\n        storageStrategy: SessionStorageStrategy,\r\n        cacheBusterObserver: logoutSubject.asObservable(),\r\n        maxCacheCount: 100,\r\n        shouldCacheDecider,\r\n    })\r\n    public loadCachedSessionStorage(url: string): Observable<any> {\r\n        return this.httpClient.get(url, { responseType: 'blob' }).pipe(this.mapBlobToUrlString());\r\n    }\r\n\r\n    /**\r\n     * Load image without using the cache (always triggers the endpoint).\r\n     *\r\n     * @param url\r\n     */\r\n    public loadWithoutCache(url: string): Observable<any> {\r\n        return this.httpClient.get(url, { responseType: 'blob' }).pipe(this.mapBlobToUrlString());\r\n    }\r\n\r\n    /**\r\n     * Map a Blob to a storable base64 url string.\r\n     */\r\n    private mapBlobToUrlString = (): UnaryFunction<Observable<Blob>, Observable<string>> => {\r\n        return pipe(switchMap(blobToBase64String));\r\n    };\r\n}\r\n", "import { Component, ElementRef, EventEmitter, Input, OnChanges, OnInit, Output, inject } from '@angular/core';\r\nimport { BehaviorSubject, Observable, isObservable, of } from 'rxjs';\r\nimport { catchError, filter, map, switchMap, tap } from 'rxjs/operators';\r\nimport { DomSanitizer } from '@angular/platform-browser';\r\nimport { CacheableImageService } from 'app/shared/image/cacheable-image.service';\r\nimport { base64StringToBlob } from 'app/utils/blob-util';\r\nimport { AsyncPipe } from '@angular/common';\r\n\r\n// Status that is emitted to the client to describe the loading status of the picture\r\nexport const enum ImageLoadingStatus {\r\n    SUCCESS = 'success',\r\n    ERROR = 'error',\r\n    LOADING = 'loading',\r\n}\r\n\r\nexport enum CachingStrategy {\r\n    LOCAL_STORAGE = 'LOCAL_STORAGE',\r\n    SESSION_STORAGE = 'SESSION_STORAGE',\r\n    NONE = 'NONE',\r\n}\r\n\r\n/**\r\n * Solution taken from: https://stackblitz.com/edit/secure-image-loads?file=app%2Fsecured-image.component.ts\r\n * Some browsers (i.e. Chrome) perform some toString function on the src attribute, which causes null to become 'null'\r\n * instead of '', thus triggering to the browser to look for //domain.com/null which results in an error\r\n * That's why I had to replace the attribute [src] with [attr.src]\r\n * This works because instead of setting src to either 'null' or '', the src attribute isn't set at all as long as the\r\n * variable/path used is not set/resolved, therefore not triggering the error.\r\n */\r\n@Component({\r\n    selector: 'jhi-secured-image',\r\n    template: `\r\n        @if (!this.mobileDragAndDrop) {\r\n            <img [attr.src]=\"dataUrl | async\" alt=\"alt\" />\r\n        }\r\n        @if (this.mobileDragAndDrop) {\r\n            <img [attr.src]=\"dataUrl | async\" class=\"dnd-drag-start\" draggable=\"true\" alt=\"alt\" cdkDrag />\r\n        }\r\n    `,\r\n    imports: [AsyncPipe],\r\n})\r\nexport class SecuredImageComponent implements OnChanges, OnInit {\r\n    private domSanitizer = inject(DomSanitizer);\r\n    private cacheableImageService = inject(CacheableImageService);\r\n    element = inject(ElementRef);\r\n\r\n    // This part just creates an rxjs stream from the src\r\n    // this makes sure that we can handle it when the src changes\r\n    // or even when the component gets destroyed\r\n    @Input() mobileDragAndDrop = false;\r\n    @Input() src: string;\r\n    @Input() cachingStrategy = CachingStrategy.SESSION_STORAGE;\r\n    @Input() alt = '';\r\n    private srcSubject?: BehaviorSubject<string>;\r\n    dataUrl: Observable<string>;\r\n    private retryCounter = 0;\r\n\r\n    @Output() endLoadingProcess = new EventEmitter<ImageLoadingStatus>();\r\n\r\n    ngOnInit(): void {\r\n        this.srcSubject = new BehaviorSubject(this.src);\r\n        // this stream will contain the actual url that our img tag will load\r\n        // everytime the src changes, the previous call would be canceled and the\r\n        // new resource would be loaded\r\n        this.dataUrl = this.srcSubject.pipe(\r\n            filter((url) => !!url),\r\n            switchMap((url) => this.loadImage(url)),\r\n        );\r\n    }\r\n\r\n    ngOnChanges() {\r\n        if (this.srcSubject) {\r\n            this.srcSubject.next(this.src);\r\n        }\r\n    }\r\n\r\n    // we need HttpClient to load the image and DomSanitizer to trust the url\r\n\r\n    // triggers the reload of the picture when the user clicks on a button\r\n    retryLoadImage() {\r\n        this.retryCounter = 0;\r\n        this.endLoadingProcess.emit(ImageLoadingStatus.LOADING);\r\n        this.ngOnChanges();\r\n    }\r\n\r\n    /**\r\n     * Load the image and decide by the active cache strategy if a cache should be used.\r\n     * The requested image will be declared as safe by this method so that angular will not complain.\r\n     * This method has a retry mechanism and will try a couple of times to retry downloading the file if it fails.\r\n     *\r\n     * @param url of the image on the server.\r\n     */\r\n    private loadImage(url: string): Observable<any> {\r\n        return of(undefined).pipe(\r\n            // Load the image from the server with the active caching strategy.\r\n            switchMap(() => {\r\n                let res;\r\n                if (this.cachingStrategy === CachingStrategy.SESSION_STORAGE) {\r\n                    res = this.cacheableImageService.loadCachedSessionStorage(url);\r\n                } else if (this.cachingStrategy === CachingStrategy.LOCAL_STORAGE) {\r\n                    res = this.cacheableImageService.loadCachedLocalStorage(url);\r\n                } else {\r\n                    res = this.cacheableImageService.loadWithoutCache(url);\r\n                }\r\n                // If the result is cached, it will not be an observable but a normal object - in this case it needs to be wrapped into an observable.\r\n                return isObservable(res) ? res : of(res);\r\n            }),\r\n            // The image will be loaded as a base64 string, so it needs to be converted to a blob before it can be used.\r\n            map((base64String: string) => {\r\n                return base64StringToBlob(base64String, 'application/json');\r\n            }),\r\n            // We need to declare the blob as safe, otherwise angular will complain about the inserted element.\r\n            map((blob: Blob) => {\r\n                return this.domSanitizer.bypassSecurityTrustUrl(URL.createObjectURL(blob));\r\n            }),\r\n            // Emit that the file was loaded successfully.\r\n            tap(() => {\r\n                this.endLoadingProcess.emit(ImageLoadingStatus.SUCCESS);\r\n            }),\r\n            catchError((error) => {\r\n                if (this.retryCounter === 0) {\r\n                    this.retryCounter++;\r\n                    return this.loadImage(url);\r\n                } else {\r\n                    this.endLoadingProcess.emit(ImageLoadingStatus.ERROR);\r\n                }\r\n                throw error;\r\n            }),\r\n        );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["SessionStorageStrategy", "IStorageStrategy", "mainCacheKey", "GlobalCacheConfig", "globalCacheKey", "constructor", "sessionStorage", "undefined", "Error", "add", "cachePair", "cacheKey", "allCachedData", "getRawData", "push", "storeRawData", "addMany", "entities", "getAll", "removeAtIndex", "index", "remove", "entity", "length", "splice", "updateAtIndex", "update", "removeAll", "data", "getItem", "JSON", "parse", "error", "setItem", "stringify", "logoutSubject", "Subject", "shouldCacheDecider", "result", "length", "CacheableImageService", "accountService", "inject", "AccountService", "httpClient", "HttpClient", "userChangeSubscription", "constructor", "init", "getAuthenticationState", "pipe", "distinctUntilChanged", "tap", "next", "subscribe", "ngOnDestroy", "unsubscribe", "loadCachedLocalStorage", "url", "get", "responseType", "mapBlobToUrlString", "loadCachedSessionStorage", "loadWithoutCache", "switchMap", "blobToBase64String", "factory", "\u0275fac", "providedIn", "__decorate", "Cacheable", "storageStrategy", "LocalStorageStrategy", "cacheBusterObserver", "asObservable", "maxCacheCount", "__metadata", "Observable", "SessionStorageStrategy", "\u0275\u0275text", "\u0275\u0275element", "\u0275\u0275advance", "CachingStrategy", "SecuredImageComponent", "domSanitizer", "inject", "DomSanitizer", "cacheableImageService", "CacheableImageService", "element", "ElementRef", "mobileDragAndDrop", "src", "cachingStrategy", "SESSION_STORAGE", "alt", "srcSubject", "dataUrl", "retryCounter", "endLoadingProcess", "EventEmitter", "ngOnInit", "BehaviorSubject", "pipe", "filter", "url", "switchMap", "loadImage", "ngOnChanges", "next", "retryLoadImage", "emit", "of", "undefined", "res", "loadCachedSessionStorage", "LOCAL_STORAGE", "loadCachedLocalStorage", "loadWithoutCache", "isObservable", "map", "base64String", "base64StringToBlob", "blob", "bypassSecurityTrustUrl", "URL", "createObjectURL", "tap", "catchError", "error", "selectors", "inputs", "outputs", "features", "\u0275\u0275NgOnChangesFeature", "decls", "vars", "consts", "template", "rf", "ctx", "\u0275\u0275template", "SecuredImageComponent_Conditional_1_Template", "SecuredImageComponent_Conditional_2_Template", "\u0275\u0275conditional", "AsyncPipe", "encapsulation"]
}
