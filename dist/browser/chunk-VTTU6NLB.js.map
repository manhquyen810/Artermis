{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/programming/shared/service/programming-language-feature/programming-language-feature.service.ts", "src/main/webapp/app/entities/programming/build.action.ts", "src/main/webapp/app/entities/programming/wind.file.ts", "src/main/webapp/app/exercises/programming/shared/service/aeolus.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport { ProgrammingLanguage, ProjectType } from 'app/entities/programming/programming-exercise.model';\r\nimport { ProfileService } from 'app/shared/layouts/profiles/profile.service';\r\n\r\n/**\r\n * ProgrammingLanguageFeature, defined on the server, allows to customize the user interface during programming exercise generation\r\n * @readonly\r\n */\r\nexport type ProgrammingLanguageFeature = {\r\n    programmingLanguage: ProgrammingLanguage;\r\n    sequentialTestRuns: boolean;\r\n    staticCodeAnalysis: boolean;\r\n    plagiarismCheckSupported: boolean;\r\n    packageNameRequired: boolean;\r\n    checkoutSolutionRepositoryAllowed: boolean;\r\n    projectTypes?: ProjectType[];\r\n    auxiliaryRepositoriesSupported: boolean;\r\n};\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ProgrammingLanguageFeatureService {\r\n    private profileService = inject(ProfileService);\r\n\r\n    private programmingLanguageFeatures: Map<ProgrammingLanguage, ProgrammingLanguageFeature> = new Map<ProgrammingLanguage, ProgrammingLanguageFeature>();\r\n\r\n    constructor() {\r\n        this.profileService.getProfileInfo().subscribe((profileInfo) => {\r\n            profileInfo.programmingLanguageFeatures.forEach((programmingLanguageFeature) => {\r\n                this.programmingLanguageFeatures.set(programmingLanguageFeature.programmingLanguage, programmingLanguageFeature);\r\n            });\r\n        });\r\n    }\r\n\r\n    public getProgrammingLanguageFeature(programmingLanguage: ProgrammingLanguage): ProgrammingLanguageFeature | undefined {\r\n        return this.programmingLanguageFeatures.get(programmingLanguage);\r\n    }\r\n\r\n    public supportsProgrammingLanguage(programmingLanguage: ProgrammingLanguage): boolean {\r\n        // A programming language is supported if the server provided us with information about that language\r\n        return this.programmingLanguageFeatures.has(programmingLanguage);\r\n    }\r\n}\r\n", "import { AeolusResult } from 'app/entities/programming/aeolus.result';\r\n\r\nexport class BuildAction {\r\n    name: string;\r\n    runAlways: boolean;\r\n    workdir: string;\r\n    results?: AeolusResult[];\r\n    platform?: string;\r\n    parameters: Map<string, string | boolean | number> = new Map<string, string | boolean | number>();\r\n}\r\n\r\nexport class ScriptAction extends BuildAction {\r\n    script: string;\r\n}\r\n\r\nexport class PlatformAction extends BuildAction {\r\n    type: string;\r\n    kind: string;\r\n}\r\n", "import { BuildAction } from 'app/entities/programming/build.action';\r\nimport { WindMetadata } from 'app/entities/programming/wind.metadata';\r\n\r\nexport class WindFile {\r\n    api: string;\r\n    metadata: WindMetadata;\r\n    actions: BuildAction[];\r\n}\r\n", "import { HttpClient } from '@angular/common/http';\r\nimport { Injectable, inject } from '@angular/core';\r\nimport { BuildAction, PlatformAction, ScriptAction } from 'app/entities/programming/build.action';\r\nimport { WindFile } from 'app/entities/programming/wind.file';\r\nimport { Observable } from 'rxjs';\r\n\r\nimport { ProgrammingLanguage, ProjectType } from 'app/entities/programming/programming-exercise.model';\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class AeolusService {\r\n    private http = inject(HttpClient);\r\n\r\n    private resourceUrl = 'api/programming/aeolus';\r\n\r\n    /**\r\n     * Fetches the aeolus template file for the given programming language\r\n     * @param {ProgrammingLanguage} language\r\n     * @param {ProjectType} projectType (if available)\r\n     * @param staticAnalysis (if available) whether static code analysis should be enabled\r\n     * @param sequentialRuns (if available) whether sequential test runs should be enabled\r\n     * @returns WindFile or undefined if no template is available\r\n     */\r\n    getAeolusTemplateFile(language: ProgrammingLanguage, projectType?: ProjectType, staticAnalysis?: boolean, sequentialRuns?: boolean): Observable<string> {\r\n        const uriWithParams = this.buildURIWithParams(language, projectType, staticAnalysis, sequentialRuns);\r\n        return this.http.get<string>(`${this.resourceUrl}/templates/` + uriWithParams.uri, {\r\n            responseType: 'text' as 'json',\r\n            params: uriWithParams.params,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetches the aeolus template file for the given programming language\r\n     * @param {ProgrammingLanguage} language\r\n     * @param {ProjectType} projectType (if available)\r\n     * @param staticAnalysis (if available) whether static code analysis should be enabled\r\n     * @param sequentialRuns (if available) whether sequential test runs should be enabled\r\n     * @returns json test file\r\n     */\r\n    getAeolusTemplateScript(language: ProgrammingLanguage, projectType?: ProjectType, staticAnalysis?: boolean, sequentialRuns?: boolean): Observable<string> {\r\n        const uriWithParams = this.buildURIWithParams(language, projectType, staticAnalysis, sequentialRuns);\r\n        return this.http.get<string>(`${this.resourceUrl}/template-scripts/` + uriWithParams.uri, {\r\n            responseType: 'text' as 'json',\r\n            params: uriWithParams.params,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parses the given windfile, the input is a json string, the output is a WindFile object\r\n     * @param file the json string\r\n     */\r\n    parseWindFile(file: string): WindFile | undefined {\r\n        try {\r\n            const templateFile: WindFile = JSON.parse(file);\r\n            const windfile: WindFile = Object.assign(new WindFile(), templateFile);\r\n            const actions: BuildAction[] = [];\r\n            templateFile.actions.forEach((anyAction: any) => {\r\n                let action: BuildAction | undefined;\r\n                if (anyAction.script) {\r\n                    action = Object.assign(new ScriptAction(), anyAction);\r\n                } else {\r\n                    action = Object.assign(new PlatformAction(), anyAction);\r\n                }\r\n                if (action) {\r\n                    action.parameters = new Map<string, string | boolean | number>();\r\n                    if (anyAction.parameters) {\r\n                        for (const key of Object.keys(anyAction.parameters)) {\r\n                            action.parameters.set(key, anyAction.parameters[key]);\r\n                        }\r\n                    }\r\n                    actions.push(action);\r\n                }\r\n            });\r\n            // somehow, the returned content may have a scriptActions field, which is not a field of the WindFile class\r\n            if ('scriptActions' in windfile) {\r\n                delete windfile['scriptActions'];\r\n            }\r\n            windfile.actions = actions;\r\n            return windfile;\r\n        } catch (SyntaxError) {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    buildURIWithParams(language: ProgrammingLanguage, projectType?: ProjectType, staticAnalysis?: boolean, sequentialRuns?: boolean): { uri: string; params: any } {\r\n        const path: string = [language, projectType].filter(Boolean).join('/');\r\n        const params = {\r\n            staticAnalysis: !!staticAnalysis,\r\n            sequentialRuns: !!sequentialRuns,\r\n        };\r\n        return {\r\n            uri: path,\r\n            params: params,\r\n        };\r\n    }\r\n\r\n    serializeWindFile(windfile: WindFile): string {\r\n        return JSON.stringify(windfile, this.replacer);\r\n    }\r\n\r\n    /**\r\n     * Serializes a value, transforming instances of Map into plain objects.\r\n     * This function is designed for use as a replacer function in JSON.stringify.\r\n     *\r\n     * @param _ The key associated with the value being serialized. This is not used in the function, but is required by the JSON.stringify replacer interface.\r\n     * @param value The value to be serialized. If the value is a Map, it will be converted to an object with string keys and values corresponding to the map's entries.\r\n     * @returns If the value is a Map, returns a plain object with keys and values from the map. Otherwise, returns the value unchanged.\r\n     * @template T The type of the value to be serialized. Ensures that the return type matches the type of the input value, except when the value is a Map.\r\n     */\r\n    replacer<T>(_: unknown, value: T): T | Record<string, unknown> {\r\n        if (value instanceof Map) {\r\n            const object: Record<string, unknown> = {};\r\n            value.forEach((value, key) => {\r\n                object[String(key)] = value;\r\n            });\r\n            return object;\r\n        } else {\r\n            return value;\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ProgrammingLanguageFeatureService", "profileService", "inject", "ProfileService", "programmingLanguageFeatures", "Map", "constructor", "getProfileInfo", "subscribe", "profileInfo", "forEach", "programmingLanguageFeature", "set", "programmingLanguage", "getProgrammingLanguageFeature", "get", "supportsProgrammingLanguage", "has", "factory", "\u0275fac", "providedIn", "BuildAction", "name", "runAlways", "workdir", "results", "platform", "parameters", "Map", "ScriptAction", "script", "PlatformAction", "type", "kind", "WindFile", "api", "metadata", "actions", "AeolusService", "http", "inject", "HttpClient", "resourceUrl", "getAeolusTemplateFile", "language", "projectType", "staticAnalysis", "sequentialRuns", "uriWithParams", "buildURIWithParams", "get", "uri", "responseType", "params", "getAeolusTemplateScript", "parseWindFile", "file", "templateFile", "JSON", "parse", "windfile", "Object", "assign", "WindFile", "actions", "forEach", "anyAction", "action", "script", "ScriptAction", "PlatformAction", "parameters", "Map", "key", "keys", "set", "push", "filter", "Boolean", "join", "serializeWindFile", "stringify", "replacer", "_", "value", "object", "String", "factory", "\u0275fac", "providedIn"]
}
