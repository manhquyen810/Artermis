{
  "version": 3,
  "sources": ["src/main/webapp/app/utils/rxjs.utils.ts", "src/main/webapp/app/course/manage/course-storage.service.ts"],
  "sourcesContent": ["import { Observable, Subject } from 'rxjs';\r\n\r\nexport class SubjectObservablePair<T> {\r\n    subject: Subject<T>;\r\n    observable: Observable<T>;\r\n\r\n    constructor() {\r\n        this.subject = new Subject<T>();\r\n        this.observable = this.subject.asObservable();\r\n    }\r\n}\r\n", "import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { Course } from 'app/entities/course.model';\r\nimport { SubjectObservablePair } from 'app/utils/rxjs.utils';\r\n\r\n/**\r\n * This service is used to store {@link Course} objects for the currently logged-in user.\r\n * The methods {@link CourseManagementService#findAllForDashboard} and {@link CourseManagementService#findOneForDashboard} retrieve one or multiple {@link Course} objects and save them in this service.\r\n * This way, multiple components that need a course can access it without having to retrieve it again from the server.\r\n * Some components update the course object and can use the {@link updateCourse} method to make the changes available to the entire application.\r\n * Components that need to be notified about these changes can use the {@link subscribeToCourseUpdates} method.\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class CourseStorageService {\r\n    private storedCourses: Course[] = [];\r\n\r\n    private readonly courseUpdateSubscriptions: Map<number, SubjectObservablePair<Course>> = new Map();\r\n\r\n    setCourses(courses?: Course[]) {\r\n        this.storedCourses = courses ?? [];\r\n    }\r\n\r\n    getCourse(courseId: number) {\r\n        return this.storedCourses.find((course) => course.id === courseId);\r\n    }\r\n\r\n    updateCourse(course?: Course): void {\r\n        if (course) {\r\n            // filter out the old course object with the same id\r\n            this.storedCourses = this.storedCourses.filter((existingCourse) => existingCourse.id !== course.id);\r\n            this.storedCourses.push(course);\r\n            return this.courseUpdateSubscriptions.get(course.id!)?.subject.next(course);\r\n        }\r\n    }\r\n\r\n    subscribeToCourseUpdates(courseId: number): Observable<Course> {\r\n        if (!this.courseUpdateSubscriptions.has(courseId)) {\r\n            this.courseUpdateSubscriptions.set(courseId, new SubjectObservablePair());\r\n        }\r\n        return this.courseUpdateSubscriptions.get(courseId)!.observable;\r\n    }\r\n}\r\n"],
  "mappings": "gDAEM,IAAOA,EAAP,KAA4B,CAC9BC,QACAC,WAEAC,aAAA,CACI,KAAKF,QAAU,IAAIG,EACnB,KAAKF,WAAa,KAAKD,QAAQI,aAAY,CAC/C,GCIJ,IAAaC,GAAoB,IAAA,CAA3B,MAAOA,CAAoB,CACrBC,cAA0B,CAAA,EAEjBC,0BAAwE,IAAIC,IAE7FC,WAAWC,EAAkB,CACzB,KAAKJ,cAAgBI,GAAW,CAAA,CACpC,CAEAC,UAAUC,EAAgB,CACtB,OAAO,KAAKN,cAAcO,KAAMC,GAAWA,EAAOC,KAAOH,CAAQ,CACrE,CAEAI,aAAaF,EAAe,CACxB,GAAIA,EAEA,YAAKR,cAAgB,KAAKA,cAAcW,OAAQC,GAAmBA,EAAeH,KAAOD,EAAOC,EAAE,EAClG,KAAKT,cAAca,KAAKL,CAAM,EACvB,KAAKP,0BAA0Ba,IAAIN,EAAOC,EAAG,GAAGM,QAAQC,KAAKR,CAAM,CAElF,CAEAS,yBAAyBX,EAAgB,CACrC,OAAK,KAAKL,0BAA0BiB,IAAIZ,CAAQ,GAC5C,KAAKL,0BAA0BkB,IAAIb,EAAU,IAAIc,CAAuB,EAErE,KAAKnB,0BAA0Ba,IAAIR,CAAQ,EAAGe,UACzD,4CA3BStB,EAAoB,6BAApBA,EAAoBuB,QAApBvB,EAAoBwB,UAAAC,WADP,MAAM,CAAA,SACnBzB,CAAoB,GAAA",
  "names": ["SubjectObservablePair", "subject", "observable", "constructor", "Subject", "asObservable", "CourseStorageService", "storedCourses", "courseUpdateSubscriptions", "Map", "setCourses", "courses", "getCourse", "courseId", "find", "course", "id", "updateCourse", "filter", "existingCourse", "push", "get", "subject", "next", "subscribeToCourseUpdates", "has", "set", "SubjectObservablePair", "observable", "factory", "\u0275fac", "providedIn"]
}
