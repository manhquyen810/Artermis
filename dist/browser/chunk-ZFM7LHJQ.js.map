{"version":3,"sources":["node_modules/ts-cacheable/dist/esm2015/common/IStorageStrategy.js","node_modules/ts-cacheable/dist/esm2015/common/InMemoryStorageStrategy.js","node_modules/ts-cacheable/dist/esm2015/common/index.js","node_modules/ts-cacheable/dist/esm2015/common/LocalStorageStrategy.js","node_modules/ts-cacheable/dist/esm2015/cacheable.decorator.js"],"sourcesContent":["export class IStorageStrategy {}\n","import { IStorageStrategy } from './IStorageStrategy';\nexport class InMemoryStorageStrategy extends IStorageStrategy {\n  constructor() {\n    super(...arguments);\n    this.cachePairs = [];\n  }\n  add(cachePair, cacheKey, ctx) {\n    this.cachePairs.push(cachePair);\n  }\n  addMany(cachePairs) {\n    this.cachePairs = cachePairs;\n  }\n  updateAtIndex(index, entity) {\n    const updatee = this.cachePairs[index];\n    Object.assign(updatee, entity);\n  }\n  update(index, entity) {\n    const updatee = this.cachePairs[index];\n    Object.assign(updatee, entity);\n  }\n  getAll() {\n    return this.cachePairs;\n  }\n  removeAtIndex(index) {\n    this.cachePairs.splice(index, 1);\n  }\n  remove(index) {\n    this.cachePairs.splice(index, 1);\n  }\n  removeAll() {\n    this.cachePairs.length = 0;\n  }\n}\n","import { IStorageStrategy } from './IStorageStrategy';\nimport { InMemoryStorageStrategy } from './InMemoryStorageStrategy';\nimport { IAsyncStorageStrategy } from './IAsyncStorageStrategy';\nimport { DOMStorageStrategy } from './DOMStorageStrategy';\nimport { LocalStorageStrategy } from './LocalStorageStrategy';\nimport { isInstant, bustCache } from './CacheBusterFunctions';\nexport const DEFAULT_CACHE_RESOLVER = (oldParams, newParams) => JSON.stringify(oldParams) === JSON.stringify(newParams);\nexport const DEFAULT_HASHER = parameters => parameters.map(param => param !== undefined ? JSON.parse(JSON.stringify(param)) : param);\nexport const GlobalCacheConfig = {\n  storageStrategy: InMemoryStorageStrategy,\n  globalCacheKey: 'CACHE_STORAGE',\n  promiseImplementation: Promise\n};\nexport { IStorageStrategy };\nexport { IAsyncStorageStrategy };\nexport { DOMStorageStrategy };\nexport { LocalStorageStrategy };\nexport { isInstant, bustCache };\n","import { IStorageStrategy } from './IStorageStrategy';\nimport { GlobalCacheConfig } from '.';\nexport class LocalStorageStrategy extends IStorageStrategy {\n  constructor() {\n    super();\n    this.masterCacheKey = GlobalCacheConfig.globalCacheKey;\n    if (typeof localStorage == 'undefined') {\n      throw new Error('Platform not supported.');\n    }\n  }\n  add(cachePair, cacheKey) {\n    const allCachedData = this.getRawData();\n    if (!allCachedData[cacheKey]) {\n      allCachedData[cacheKey] = [];\n    }\n    allCachedData[cacheKey].push(cachePair);\n    this.storeRawData(allCachedData);\n  }\n  addMany(cachePairs, cacheKey) {\n    const allCachedData = this.getRawData();\n    if (!allCachedData[cacheKey]) {\n      allCachedData[cacheKey] = [];\n    }\n    allCachedData[cacheKey] = cachePairs;\n    this.storeRawData(allCachedData);\n  }\n  getAll(cacheKey) {\n    return this.getRawData()[cacheKey] || [];\n  }\n  removeAtIndex(index, cacheKey) {\n    const allCachedData = this.getRawData();\n    if (allCachedData[cacheKey] && allCachedData[cacheKey].length) {\n      allCachedData[cacheKey].splice(index, 1);\n    }\n    this.storeRawData(allCachedData);\n  }\n  remove(index, entity, cacheKey) {\n    const allCachedData = this.getRawData();\n    if (allCachedData[cacheKey] && allCachedData[cacheKey].length) {\n      allCachedData[cacheKey].splice(index, 1);\n    }\n    this.storeRawData(allCachedData);\n  }\n  updateAtIndex(index, entity, cacheKey) {\n    const allCachedData = this.getRawData();\n    if (allCachedData[cacheKey] && allCachedData[cacheKey][index]) {\n      allCachedData[cacheKey][index] = entity;\n    }\n    this.storeRawData(allCachedData);\n  }\n  update(index, entity, cacheKey) {\n    const allCachedData = this.getRawData();\n    if (allCachedData[cacheKey] && allCachedData[cacheKey][index]) {\n      allCachedData[cacheKey][index] = entity;\n    }\n    this.storeRawData(allCachedData);\n  }\n  removeAll(cacheKey) {\n    const allCachedData = this.getRawData();\n    if (allCachedData[cacheKey] && allCachedData[cacheKey].length) {\n      allCachedData[cacheKey].length = 0;\n    }\n    this.storeRawData(allCachedData);\n  }\n  getRawData() {\n    const data = localStorage.getItem(this.masterCacheKey);\n    try {\n      return JSON.parse(data) || {};\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n  storeRawData(data) {\n    localStorage.setItem(this.masterCacheKey, JSON.stringify(data));\n  }\n}\n","import { empty, merge, of, Subject } from 'rxjs';\nimport { delay, finalize, tap, publishReplay, refCount } from 'rxjs/operators';\nimport { DEFAULT_CACHE_RESOLVER, GlobalCacheConfig, DEFAULT_HASHER } from './common';\nexport const globalCacheBusterNotifier = new Subject();\nexport function Cacheable(cacheConfig = {}) {\n  return function (_target, _propertyKey, propertyDescriptor) {\n    const cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n    const oldMethod = propertyDescriptor.value;\n    if (propertyDescriptor && propertyDescriptor.value) {\n      let storageStrategy = !cacheConfig.storageStrategy ? new GlobalCacheConfig.storageStrategy() : new cacheConfig.storageStrategy();\n      const pendingCachePairs = [];\n      if (cacheConfig.cacheModifier) {\n        cacheConfig.cacheModifier.subscribe(callback => storageStrategy.addMany(callback(storageStrategy.getAll(cacheKey, this)), cacheKey, this));\n      }\n      /**\n       * subscribe to the globalCacheBuster\n       * if a custom cacheBusterObserver is passed, subscribe to it as well\n       * subscribe to the cacheBusterObserver and upon emission, clear all caches\n       */\n      merge(globalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver ? cacheConfig.cacheBusterObserver : empty()).subscribe(_ => {\n        storageStrategy.removeAll(cacheKey, this);\n        pendingCachePairs.length = 0;\n      });\n      const cacheResolver = cacheConfig.cacheResolver || GlobalCacheConfig.cacheResolver;\n      cacheConfig.cacheResolver = cacheResolver ? cacheResolver : DEFAULT_CACHE_RESOLVER;\n      const cacheHasher = cacheConfig.cacheHasher || GlobalCacheConfig.cacheHasher;\n      cacheConfig.cacheHasher = cacheHasher ? cacheHasher : DEFAULT_HASHER;\n      /* use function instead of an arrow function to keep context of invocation */\n      propertyDescriptor.value = function (...parameters) {\n        const cachePairs = storageStrategy.getAll(cacheKey, this);\n        let cacheParameters = cacheConfig.cacheHasher(parameters);\n        let _foundCachePair = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n        const _foundPendingCachePair = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n        /**\n         * check if maxAge is passed and cache has actually expired\n         */\n        if ((cacheConfig.maxAge || GlobalCacheConfig.maxAge) && _foundCachePair && _foundCachePair.created) {\n          if (new Date().getTime() - new Date(_foundCachePair.created).getTime() > (cacheConfig.maxAge || GlobalCacheConfig.maxAge)) {\n            /**\n             * cache duration has expired - remove it from the cachePairs array\n             */\n            storageStrategy.remove ? storageStrategy.remove(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey, this);\n            _foundCachePair = null;\n          } else if (cacheConfig.slidingExpiration || GlobalCacheConfig.slidingExpiration) {\n            /**\n             * renew cache duration\n             */\n            _foundCachePair.created = new Date();\n            storageStrategy.update ? storageStrategy.update(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this);\n          }\n        }\n        if (_foundCachePair) {\n          const cached$ = of(_foundCachePair.response);\n          return cacheConfig.async ? cached$.pipe(delay(0)) : cached$;\n        } else if (_foundPendingCachePair) {\n          return _foundPendingCachePair.response;\n        } else {\n          const response$ = oldMethod.call(this, ...parameters).pipe(finalize(() => {\n            /**\n             * if there has been an observable cache pair for these parameters, when it completes or errors, remove it\n             */\n            const _pendingCachePairToRemove = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n            pendingCachePairs.splice(pendingCachePairs.indexOf(_pendingCachePairToRemove), 1);\n          }), tap(response => {\n            /**\n             * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n             * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n             */\n            if (!cacheConfig.shouldCacheDecider || cacheConfig.shouldCacheDecider(response)) {\n              if (!(cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) === 1 || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) && (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) < cachePairs.length + 1) {\n                storageStrategy.remove ? storageStrategy.remove(0, cachePairs[0], cacheKey, this) : storageStrategy.removeAtIndex(0, cacheKey, this);\n              }\n              storageStrategy.add({\n                parameters: cacheParameters,\n                response,\n                created: cacheConfig.maxAge || GlobalCacheConfig.maxAge ? new Date() : null\n              }, cacheKey, this);\n            }\n          }), publishReplay(1), refCount());\n          /**\n           * cache the stream\n           */\n          pendingCachePairs.push({\n            parameters: cacheParameters,\n            response: response$,\n            created: new Date()\n          });\n          return response$;\n        }\n      };\n    }\n    return propertyDescriptor;\n  };\n}\n;\n"],"mappings":"mGAAO,IAAMA,EAAN,KAAuB,CAAC,ECCxB,IAAMC,EAAN,cAAsCC,CAAiB,CAC5D,aAAc,CACZ,MAAM,GAAG,SAAS,EAClB,KAAK,WAAa,CAAC,CACrB,CACA,IAAIC,EAAWC,EAAUC,EAAK,CAC5B,KAAK,WAAW,KAAKF,CAAS,CAChC,CACA,QAAQG,EAAY,CAClB,KAAK,WAAaA,CACpB,CACA,cAAcC,EAAOC,EAAQ,CAC3B,IAAMC,EAAU,KAAK,WAAWF,CAAK,EACrC,OAAO,OAAOE,EAASD,CAAM,CAC/B,CACA,OAAOD,EAAOC,EAAQ,CACpB,IAAMC,EAAU,KAAK,WAAWF,CAAK,EACrC,OAAO,OAAOE,EAASD,CAAM,CAC/B,CACA,QAAS,CACP,OAAO,KAAK,UACd,CACA,cAAcD,EAAO,CACnB,KAAK,WAAW,OAAOA,EAAO,CAAC,CACjC,CACA,OAAOA,EAAO,CACZ,KAAK,WAAW,OAAOA,EAAO,CAAC,CACjC,CACA,WAAY,CACV,KAAK,WAAW,OAAS,CAC3B,CACF,EC1BO,IAAMG,EAAyB,CAACC,EAAWC,IAAc,KAAK,UAAUD,CAAS,IAAM,KAAK,UAAUC,CAAS,EACzGC,EAAiBC,GAAcA,EAAW,IAAIC,GAASA,IAAU,OAAY,KAAK,MAAM,KAAK,UAAUA,CAAK,CAAC,EAAIA,CAAK,EACtHC,EAAoB,CAC/B,gBAAiBC,EACjB,eAAgB,gBAChB,sBAAuB,OACzB,ECVO,IAAMC,EAAN,cAAmCC,CAAiB,CACzD,aAAc,CAGZ,GAFA,MAAM,EACN,KAAK,eAAiBC,EAAkB,eACpC,OAAO,aAAgB,IACzB,MAAM,IAAI,MAAM,yBAAyB,CAE7C,CACA,IAAIC,EAAWC,EAAU,CACvB,IAAMC,EAAgB,KAAK,WAAW,EACjCA,EAAcD,CAAQ,IACzBC,EAAcD,CAAQ,EAAI,CAAC,GAE7BC,EAAcD,CAAQ,EAAE,KAAKD,CAAS,EACtC,KAAK,aAAaE,CAAa,CACjC,CACA,QAAQC,EAAYF,EAAU,CAC5B,IAAMC,EAAgB,KAAK,WAAW,EACjCA,EAAcD,CAAQ,IACzBC,EAAcD,CAAQ,EAAI,CAAC,GAE7BC,EAAcD,CAAQ,EAAIE,EAC1B,KAAK,aAAaD,CAAa,CACjC,CACA,OAAOD,EAAU,CACf,OAAO,KAAK,WAAW,EAAEA,CAAQ,GAAK,CAAC,CACzC,CACA,cAAcG,EAAOH,EAAU,CAC7B,IAAMC,EAAgB,KAAK,WAAW,EAClCA,EAAcD,CAAQ,GAAKC,EAAcD,CAAQ,EAAE,QACrDC,EAAcD,CAAQ,EAAE,OAAOG,EAAO,CAAC,EAEzC,KAAK,aAAaF,CAAa,CACjC,CACA,OAAOE,EAAOC,EAAQJ,EAAU,CAC9B,IAAMC,EAAgB,KAAK,WAAW,EAClCA,EAAcD,CAAQ,GAAKC,EAAcD,CAAQ,EAAE,QACrDC,EAAcD,CAAQ,EAAE,OAAOG,EAAO,CAAC,EAEzC,KAAK,aAAaF,CAAa,CACjC,CACA,cAAcE,EAAOC,EAAQJ,EAAU,CACrC,IAAMC,EAAgB,KAAK,WAAW,EAClCA,EAAcD,CAAQ,GAAKC,EAAcD,CAAQ,EAAEG,CAAK,IAC1DF,EAAcD,CAAQ,EAAEG,CAAK,EAAIC,GAEnC,KAAK,aAAaH,CAAa,CACjC,CACA,OAAOE,EAAOC,EAAQJ,EAAU,CAC9B,IAAMC,EAAgB,KAAK,WAAW,EAClCA,EAAcD,CAAQ,GAAKC,EAAcD,CAAQ,EAAEG,CAAK,IAC1DF,EAAcD,CAAQ,EAAEG,CAAK,EAAIC,GAEnC,KAAK,aAAaH,CAAa,CACjC,CACA,UAAUD,EAAU,CAClB,IAAMC,EAAgB,KAAK,WAAW,EAClCA,EAAcD,CAAQ,GAAKC,EAAcD,CAAQ,EAAE,SACrDC,EAAcD,CAAQ,EAAE,OAAS,GAEnC,KAAK,aAAaC,CAAa,CACjC,CACA,YAAa,CACX,IAAMI,EAAO,aAAa,QAAQ,KAAK,cAAc,EACrD,GAAI,CACF,OAAO,KAAK,MAAMA,CAAI,GAAK,CAAC,CAC9B,OAASC,EAAO,CACd,MAAM,IAAI,MAAMA,CAAK,CACvB,CACF,CACA,aAAaD,EAAM,CACjB,aAAa,QAAQ,KAAK,eAAgB,KAAK,UAAUA,CAAI,CAAC,CAChE,CACF,ECxEO,IAAME,EAA4B,IAAIC,EACtC,SAASC,EAAUC,EAAc,CAAC,EAAG,CAC1C,OAAO,SAAUC,EAASC,EAAcC,EAAoB,CAC1D,IAAMC,EAAWJ,EAAY,UAAYC,EAAQ,YAAY,KAAO,IAAMC,EACpEG,EAAYF,EAAmB,MACrC,GAAIA,GAAsBA,EAAmB,MAAO,CAClD,IAAIG,EAAmBN,EAAY,gBAA4D,IAAIA,EAAY,gBAA1D,IAAIO,EAAkB,gBACrEC,EAAoB,CAAC,EACvBR,EAAY,eACdA,EAAY,cAAc,UAAUS,GAAYH,EAAgB,QAAQG,EAASH,EAAgB,OAAOF,EAAU,IAAI,CAAC,EAAGA,EAAU,IAAI,CAAC,EAO3IM,EAAMb,EAA0B,aAAa,EAAGG,EAAY,oBAAsBA,EAAY,oBAAsBW,EAAM,CAAC,EAAE,UAAUC,GAAK,CAC1IN,EAAgB,UAAUF,EAAU,IAAI,EACxCI,EAAkB,OAAS,CAC7B,CAAC,EACD,IAAMK,EAAgBb,EAAY,eAAiBO,EAAkB,cACrEP,EAAY,cAAgBa,GAAgCC,EAC5D,IAAMC,EAAcf,EAAY,aAAeO,EAAkB,YACjEP,EAAY,YAAce,GAA4BC,EAEtDb,EAAmB,MAAQ,YAAac,EAAY,CAClD,IAAMC,EAAaZ,EAAgB,OAAOF,EAAU,IAAI,EACpDe,EAAkBnB,EAAY,YAAYiB,CAAU,EACpDG,EAAkBF,EAAW,KAAKG,GAAMrB,EAAY,cAAcqB,EAAG,WAAYF,CAAe,CAAC,EAC/FG,EAAyBd,EAAkB,KAAKa,GAAMrB,EAAY,cAAcqB,EAAG,WAAYF,CAAe,CAAC,EAmBrH,IAfKnB,EAAY,QAAUO,EAAkB,SAAWa,GAAmBA,EAAgB,UACrF,IAAI,KAAK,EAAE,QAAQ,EAAI,IAAI,KAAKA,EAAgB,OAAO,EAAE,QAAQ,GAAKpB,EAAY,QAAUO,EAAkB,SAIhHD,EAAgB,OAASA,EAAgB,OAAOY,EAAW,QAAQE,CAAe,EAAGA,EAAiBhB,EAAU,IAAI,EAAIE,EAAgB,cAAcY,EAAW,QAAQE,CAAe,EAAGhB,EAAU,IAAI,EACzMgB,EAAkB,OACTpB,EAAY,mBAAqBO,EAAkB,qBAI5Da,EAAgB,QAAU,IAAI,KAC9Bd,EAAgB,OAASA,EAAgB,OAAOY,EAAW,QAAQE,CAAe,EAAGA,EAAiBhB,EAAU,IAAI,EAAIE,EAAgB,cAAcY,EAAW,QAAQE,CAAe,EAAGA,EAAiBhB,EAAU,IAAI,IAG1NgB,EAAiB,CACnB,IAAMG,EAAUC,EAAGJ,EAAgB,QAAQ,EAC3C,OAAOpB,EAAY,MAAQuB,EAAQ,KAAKE,EAAM,CAAC,CAAC,EAAIF,CACtD,KAAO,IAAID,EACT,OAAOA,EAAuB,SACzB,CACL,IAAMI,EAAYrB,EAAU,KAAK,KAAM,GAAGY,CAAU,EAAE,KAAKU,EAAS,IAAM,CAIxE,IAAMC,EAA4BpB,EAAkB,KAAKa,GAAMrB,EAAY,cAAcqB,EAAG,WAAYF,CAAe,CAAC,EACxHX,EAAkB,OAAOA,EAAkB,QAAQoB,CAAyB,EAAG,CAAC,CAClF,CAAC,EAAGC,EAAIC,GAAY,EAKd,CAAC9B,EAAY,oBAAsBA,EAAY,mBAAmB8B,CAAQ,MACxE,EAAE9B,EAAY,eAAiBO,EAAkB,iBAAmBP,EAAY,eAAiBO,EAAkB,iBAAmB,IAAMP,EAAY,eAAiBO,EAAkB,iBAAmBP,EAAY,eAAiBO,EAAkB,eAAiBW,EAAW,OAAS,KACpSZ,EAAgB,OAASA,EAAgB,OAAO,EAAGY,EAAW,CAAC,EAAGd,EAAU,IAAI,EAAIE,EAAgB,cAAc,EAAGF,EAAU,IAAI,GAErIE,EAAgB,IAAI,CAClB,WAAYa,EACZ,SAAAW,EACA,QAAS9B,EAAY,QAAUO,EAAkB,OAAS,IAAI,KAAS,IACzE,EAAGH,EAAU,IAAI,EAErB,CAAC,EAAG2B,EAAc,CAAC,EAAGC,EAAS,CAAC,EAIhC,OAAAxB,EAAkB,KAAK,CACrB,WAAYW,EACZ,SAAUO,EACV,QAAS,IAAI,IACf,CAAC,EACMA,CACT,EACF,CACF,CACA,OAAOvB,CACT,CACF","names":["IStorageStrategy","InMemoryStorageStrategy","IStorageStrategy","cachePair","cacheKey","ctx","cachePairs","index","entity","updatee","DEFAULT_CACHE_RESOLVER","oldParams","newParams","DEFAULT_HASHER","parameters","param","GlobalCacheConfig","InMemoryStorageStrategy","LocalStorageStrategy","IStorageStrategy","GlobalCacheConfig","cachePair","cacheKey","allCachedData","cachePairs","index","entity","data","error","globalCacheBusterNotifier","Subject","Cacheable","cacheConfig","_target","_propertyKey","propertyDescriptor","cacheKey","oldMethod","storageStrategy","GlobalCacheConfig","pendingCachePairs","callback","merge","empty","_","cacheResolver","DEFAULT_CACHE_RESOLVER","cacheHasher","DEFAULT_HASHER","parameters","cachePairs","cacheParameters","_foundCachePair","cp","_foundPendingCachePair","cached$","of","delay","response$","finalize","_pendingCachePairToRemove","tap","response","publishReplay","refCount"],"x_google_ignoreList":[0,1,2,3,4]}