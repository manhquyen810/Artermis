{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/quiz/shared/drag-and-drop-question-util.service.ts", "src/main/webapp/app/exercises/quiz/manage/temp-id.ts", "src/main/webapp/app/entities/quiz/drop-location.model.ts", "src/main/webapp/app/entities/quiz/drag-item.model.ts", "src/main/webapp/app/exercises/quiz/shared/fit-text/fit-text.directive.ts", "src/main/webapp/app/exercises/quiz/shared/questions/drag-and-drop-question/drag-item.component.ts", "src/main/webapp/app/exercises/quiz/shared/questions/drag-and-drop-question/drag-item.component.html"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\r\nimport { DragAndDropMapping } from 'app/entities/quiz/drag-and-drop-mapping.model';\r\nimport { DragAndDropQuestion } from 'app/entities/quiz/drag-and-drop-question.model';\r\nimport { DragItem } from 'app/entities/quiz/drag-item.model';\r\nimport { BaseEntityWithTempId, DropLocation } from 'app/entities/quiz/drop-location.model';\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class DragAndDropQuestionUtil {\r\n    /**\r\n     * Get a sample solution for the given drag and drop question\r\n     *\r\n     * @param question {object} the drag and drop question we want to solve\r\n     * @param [mappings] {Array} (optional) the mappings we try to use in the sample solution (this may contain incorrect mappings - they will be filtered out)\r\n     * @return {Array} array of mappings that would solve this question (can be empty, if question is unsolvable)\r\n     */\r\n    solve(question: DragAndDropQuestion, mappings?: DragAndDropMapping[]) {\r\n        if (!question.correctMappings) {\r\n            return [];\r\n        }\r\n\r\n        const sampleMappings = new Array<DragAndDropMapping>();\r\n        let availableDragItems = question.dragItems;\r\n\r\n        // filter out dropLocations that do not need to be mapped\r\n        let remainingDropLocations = question.dropLocations?.filter((dropLocation) => {\r\n            return question.correctMappings?.some((mapping) => {\r\n                return this.isSameEntityWithTempId(mapping.dropLocation, dropLocation);\r\n            }, this);\r\n        }, this);\r\n\r\n        if (mappings) {\r\n            // add mappings that are already correct\r\n            mappings.forEach(function (mapping) {\r\n                const correctMapping = this.getMapping(question.correctMappings!, mapping.dragItem!, mapping.dropLocation!);\r\n                if (correctMapping) {\r\n                    sampleMappings.push(correctMapping);\r\n                    remainingDropLocations = remainingDropLocations?.filter(function (dropLocation) {\r\n                        return !this.isSameEntityWithTempId(dropLocation, mapping.dropLocation);\r\n                    }, this);\r\n                    availableDragItems = availableDragItems?.filter(function (dragItem) {\r\n                        return !this.isSameEntityWithTempId(dragItem, mapping.dragItem);\r\n                    }, this);\r\n                }\r\n            }, this);\r\n        }\r\n\r\n        // solve recursively\r\n        const solved = this.solveRec(question.correctMappings, remainingDropLocations, availableDragItems, sampleMappings);\r\n\r\n        if (solved) {\r\n            return sampleMappings;\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try to solve a drag and drop question recursively\r\n     *\r\n     * @param correctMappings {Array} the correct mappings defined by the creator of the question\r\n     * @param remainingDropLocations {Array} the drop locations that still need to be mapped (recursion stops if this is empty)\r\n     * @param availableDragItems {Array} the unused drag items that can still be used to map to drop locations (recursion stops if this is empty)\r\n     * @param sampleMappings {Array} the mappings so far\r\n     * @return {boolean} true, if the question was solved (solution is saved in sampleMappings), otherwise false\r\n     */\r\n    solveRec(\r\n        correctMappings: DragAndDropMapping[],\r\n        remainingDropLocations: DropLocation[] | undefined,\r\n        availableDragItems: DragItem[] | undefined,\r\n        sampleMappings: DragAndDropMapping[],\r\n    ) {\r\n        if (!remainingDropLocations || remainingDropLocations.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        const dropLocation = remainingDropLocations[0];\r\n        return availableDragItems?.some(function (dragItem, index) {\r\n            const correctMapping = this.getMapping(correctMappings, dragItem, dropLocation);\r\n            if (correctMapping) {\r\n                sampleMappings.push(correctMapping); // add new mapping\r\n                remainingDropLocations.splice(0, 1); // remove first dropLocation\r\n                availableDragItems.splice(index, 1); // remove the used dragItem\r\n                const solved = this.solveRec(correctMappings, remainingDropLocations, availableDragItems, sampleMappings);\r\n                remainingDropLocations.splice(0, 0, dropLocation); // re-insert first dropLocation\r\n                availableDragItems.splice(index, 0, dragItem); // re-insert the used dragItem\r\n                if (!solved) {\r\n                    sampleMappings.pop(); // remove new mapping (only if solution was not found)\r\n                }\r\n                return solved;\r\n            } else {\r\n                return false;\r\n            }\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Validate that all correct mappings (and any combination of them that doesn't use a dropLocation or dragItem twice)\r\n     * can be used in a 100% correct solution.\r\n     * This means that if any pair of dragItems share a possible dropLocation, then they must share all dropLocations,\r\n     * or in other words the sets of possible dropLocations for these two dragItems must be identical\r\n     *\r\n     * @param question {object} the question to check\r\n     * @return {boolean} true, if the condition is met, otherwise false\r\n     */\r\n    validateNoMisleadingCorrectMapping(question: DragAndDropQuestion) {\r\n        if (!question.correctMappings || !question.dragItems) {\r\n            // no correct mappings at all means there can be no misleading mappings\r\n            return true;\r\n        }\r\n        // iterate through all pairs of drag items\r\n        for (let i = 0; i < question.dragItems.length; i++) {\r\n            for (let j = 0; j < i; j++) {\r\n                // if these two drag items have one common drop location, they must share all drop locations\r\n                const dragItem1 = question.dragItems[i];\r\n                const dragItem2 = question.dragItems[j];\r\n                const shareOneDropLocation = question.dropLocations?.some(function (dropLocation) {\r\n                    const isMappedWithDragItem1 = this.isMappedTogether(question.correctMappings, dragItem1, dropLocation);\r\n                    const isMappedWithDragItem2 = this.isMappedTogether(question.correctMappings, dragItem2, dropLocation);\r\n                    return isMappedWithDragItem1 && isMappedWithDragItem2;\r\n                }, this);\r\n                if (shareOneDropLocation) {\r\n                    const allDropLocationsForDragItem1 = this.getAllDropLocationsForDragItem(question.correctMappings, dragItem1);\r\n                    const allDropLocationsForDragItem2 = this.getAllDropLocationsForDragItem(question.correctMappings, dragItem2);\r\n                    if (!this.isSameSetOfDropLocations(allDropLocationsForDragItem1, allDropLocationsForDragItem2)) {\r\n                        // condition is violated for this pair of dragItems\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // condition was met for all pairs of drag items\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check if the given dragItem and dropLocation are mapped together in the given mappings\r\n     *\r\n     * @param mappings {Array} the existing mappings to consider\r\n     * @param dragItem {object} the drag item to search for\r\n     * @param dropLocation {object} the drop location to search for\r\n     * @return {boolean} true if they are mapped together, otherwise false\r\n     */\r\n    isMappedTogether(mappings: DragAndDropMapping[], dragItem: DragItem, dropLocation: DropLocation) {\r\n        return !!this.getMapping(mappings, dragItem, dropLocation);\r\n    }\r\n\r\n    /**\r\n     * Get the mapping that maps the given dragItem and dropLocation together\r\n     *\r\n     * @param mappings {Array} the existing mappings to consider\r\n     * @param dragItem {object} the drag item to search for\r\n     * @param dropLocation {object} the drop location to search for\r\n     * @return {object | null} the found mapping, or null if it doesn't exist\r\n     */\r\n    getMapping(mappings: DragAndDropMapping[], dragItem: DragItem, dropLocation: DropLocation) {\r\n        return mappings.find((mapping: DragAndDropMapping) => {\r\n            return this.isSameEntityWithTempId(dropLocation, mapping.dropLocation) && this.isSameEntityWithTempId(dragItem, mapping.dragItem);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Get all drop locations that are mapped to the given drag items\r\n     *\r\n     * @param mappings {Array} the existing mappings to consider\r\n     * @param dragItem {object} the drag item that the returned drop locations have to be mapped to\r\n     * @return {Array} the resulting drop locations\r\n     */\r\n    getAllDropLocationsForDragItem(mappings: DragAndDropMapping[], dragItem: DragItem): DropLocation[] {\r\n        return mappings.filter((mapping) => this.isSameEntityWithTempId(mapping.dragItem, dragItem)).map((mapping) => mapping.dropLocation!);\r\n    }\r\n\r\n    /**\r\n     * Check if set1 and set2 contain the same drag items or drop locations\r\n     *\r\n     * @param set1 {Array} one set of drag items or drop locations\r\n     * @param set2 {Array} another set of drag items or drop locations\r\n     * @return {boolean} true if the sets contain the same items, otherwise false\r\n     */\r\n    isSameSetOfDropLocations(set1: DropLocation[], set2: DropLocation[]): boolean {\r\n        if (set1.length !== set2.length) {\r\n            // different number of elements => impossible to contain the same elements\r\n            return false;\r\n        }\r\n        return (\r\n            // for every element in set1 there has to be an identical element in set2 and vice versa\r\n            set1.every((element1: DropLocation) => {\r\n                return set2.some((element2: DropLocation) => {\r\n                    return this.isSameEntityWithTempId(element1, element2);\r\n                });\r\n            }) &&\r\n            set2.every((element2: DropLocation) => {\r\n                return set1.some((element1: DropLocation) => {\r\n                    return this.isSameEntityWithTempId(element1, element2);\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * compare if the two objects are the same entities with a temp id\r\n     *\r\n     * @param a {object} an entity with a temp id\r\n     * @param b {object} another entity with a temp id\r\n     * @return {boolean}\r\n     */\r\n    isSameEntityWithTempId(a: BaseEntityWithTempId | undefined, b: BaseEntityWithTempId | undefined): boolean {\r\n        return a === b || (a != undefined && b != undefined && ((a.id && b.id && a.id === b.id) || (a.tempID != undefined && b.tempID != undefined && a.tempID === b.tempID)));\r\n    }\r\n}\r\n", "/**\r\n * Generates a temporary ID that we can assign to a DragItem or DropLocation or other quiz element\r\n * so that we can refer to those objects before the server has created an ID.\r\n */\r\nexport function generate(): number {\r\n    return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\r\n}\r\n", "import { BaseEntity } from 'app/shared/model/base-entity';\r\nimport { DragAndDropQuestion } from 'app/entities/quiz/drag-and-drop-question.model';\r\nimport { generate } from 'app/exercises/quiz/manage/temp-id';\r\n\r\nexport interface CanBecomeInvalid {\r\n    invalid: boolean;\r\n}\r\n\r\nexport class BaseEntityWithTempId implements BaseEntity {\r\n    public id?: number;\r\n    public tempID?: number;\r\n    constructor() {\r\n        this.tempID = generate();\r\n    }\r\n}\r\n\r\nexport class DropLocation extends BaseEntityWithTempId implements CanBecomeInvalid {\r\n    public posX?: number;\r\n    public posY?: number;\r\n    public width?: number;\r\n    public height?: number;\r\n    public invalid = false; // default value\r\n    public question?: DragAndDropQuestion;\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\n", "import { DragAndDropQuestion } from 'app/entities/quiz/drag-and-drop-question.model';\r\nimport { BaseEntityWithTempId, CanBecomeInvalid } from 'app/entities/quiz/drop-location.model';\r\n\r\nexport class DragItem extends BaseEntityWithTempId implements CanBecomeInvalid {\r\n    public pictureFilePath?: string;\r\n    public text?: string;\r\n    public question?: DragAndDropQuestion;\r\n    public invalid = false; // default value\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\n", "import { AfterViewInit, Directive, ElementRef, HostListener, Input, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges, inject } from '@angular/core';\r\n\r\n// NOTE: this code was taken from https://github.com/sollenne/angular-fittext because the repository was not maintained any more since June 2018\r\n\r\n@Directive({ selector: '[fitText]' })\r\nexport class FitTextDirective implements AfterViewInit, OnInit, OnChanges, OnDestroy {\r\n    private renderer = inject(Renderer2);\r\n\r\n    @Input() fitText = true;\r\n    @Input() compression = 1;\r\n    @Input() activateOnResize = true;\r\n    @Input() minFontSize?: number | 'inherit' = 0;\r\n    @Input() maxFontSize?: number | 'inherit' = Number.POSITIVE_INFINITY;\r\n    @Input() delay = 100;\r\n    @Input() innerHTML: any;\r\n    @Input() fontUnit: 'px' | 'em' | string = 'px';\r\n\r\n    private readonly fitTextElement: HTMLElement;\r\n    private readonly computed: CSSStyleDeclaration;\r\n    private readonly newlines: number;\r\n    private readonly lineHeight: string;\r\n    private readonly display: string;\r\n    private fitTextParent: HTMLElement;\r\n    private fitTextMinFontSize: number;\r\n    private fitTextMaxFontSize: number;\r\n    private calcSize = 10;\r\n    private resizeTimeout: NodeJS.Timeout;\r\n\r\n    constructor() {\r\n        const el = inject(ElementRef);\r\n\r\n        this.fitTextElement = el.nativeElement;\r\n        this.fitTextParent = this.fitTextElement.parentElement!;\r\n        this.computed = window.getComputedStyle(this.fitTextElement);\r\n        this.newlines = this.fitTextElement.childElementCount > 0 ? this.fitTextElement.childElementCount : 1;\r\n        this.lineHeight = this.computed.lineHeight;\r\n        this.display = this.computed.display;\r\n    }\r\n\r\n    @HostListener('window:resize')\r\n    public onWindowResize = (): void => {\r\n        if (this.activateOnResize) {\r\n            this.setFontSize();\r\n        }\r\n    };\r\n\r\n    public ngOnInit() {\r\n        this.fitTextMinFontSize = this.minFontSize === 'inherit' ? Number(this.computed.fontSize) : this.minFontSize!;\r\n        this.fitTextMaxFontSize = this.maxFontSize === 'inherit' ? Number(this.computed.fontSize) : this.maxFontSize!;\r\n    }\r\n\r\n    public ngAfterViewInit() {\r\n        this.setFontSize(0);\r\n    }\r\n\r\n    public ngOnChanges(changes: SimpleChanges) {\r\n        if (changes['compression'] && !changes['compression'].firstChange) {\r\n            this.setFontSize(0);\r\n        }\r\n        if (changes['innerHTML']) {\r\n            this.fitTextElement.innerHTML = this.innerHTML;\r\n            if (!changes['innerHTML'].firstChange) {\r\n                this.setFontSize(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    public ngOnDestroy() {\r\n        clearTimeout(this.resizeTimeout);\r\n    }\r\n\r\n    private setFontSize = (delay: number = this.delay): void => {\r\n        this.resizeTimeout = setTimeout(() => {\r\n            if (this.fitTextElement.offsetHeight * this.fitTextElement.offsetWidth !== 0) {\r\n                // reset to default\r\n                this.setStyles(this.calcSize, 1, 'inline-block');\r\n                // set new\r\n                this.setStyles(this.calculateNewFontSize(), this.lineHeight, this.display);\r\n            }\r\n        }, delay);\r\n    };\r\n\r\n    private calculateNewFontSize = (): number => {\r\n        const ratio = (this.calcSize * this.newlines) / this.fitTextElement.offsetWidth / this.newlines;\r\n\r\n        return Math.max(\r\n            Math.min(\r\n                (this.fitTextParent.offsetWidth -\r\n                    (parseFloat(getComputedStyle(this.fitTextParent).paddingLeft) + parseFloat(getComputedStyle(this.fitTextParent).paddingRight)) -\r\n                    6) *\r\n                    ratio *\r\n                    this.compression,\r\n                this.fitTextMaxFontSize,\r\n            ),\r\n            this.fitTextMinFontSize,\r\n        );\r\n    };\r\n\r\n    private setStyles = (fontSize: number, lineHeight: number | string, display: string): void => {\r\n        this.renderer.setStyle(this.fitTextElement, 'fontSize', fontSize.toString() + this.fontUnit);\r\n        this.renderer.setStyle(this.fitTextElement, 'lineHeight', lineHeight.toString());\r\n        this.renderer.setStyle(this.fitTextElement, 'display', display);\r\n    };\r\n}\r\n", "import { Component, Input, OnInit, ViewEncapsulation } from '@angular/core';\r\nimport isMobile from 'ismobilejs-es5';\r\nimport { DragItem } from 'app/entities/quiz/drag-item.model';\r\nimport { NgClass, NgStyle } from '@angular/common';\r\nimport { CdkDrag, CdkDragPlaceholder, CdkDragPreview } from '@angular/cdk/drag-drop';\r\nimport { SecuredImageComponent } from 'app/shared/image/secured-image.component';\r\nimport { FitTextDirective } from '../../fit-text/fit-text.directive';\r\nimport { TranslateDirective } from 'app/shared/language/translate.directive';\r\n\r\n@Component({\r\n    selector: 'jhi-drag-item',\r\n    templateUrl: './drag-item.component.html',\r\n    styleUrls: ['./drag-item.component.scss'],\r\n    encapsulation: ViewEncapsulation.None,\r\n    imports: [NgClass, NgStyle, CdkDrag, SecuredImageComponent, CdkDragPlaceholder, FitTextDirective, CdkDragPreview, TranslateDirective],\r\n})\r\nexport class DragItemComponent implements OnInit {\r\n    @Input() minWidth: string;\r\n    @Input() dragItem: DragItem;\r\n    @Input() clickDisabled: boolean;\r\n    @Input() invalid: boolean;\r\n    @Input() filePreviewPaths: Map<string, string> = new Map<string, string>();\r\n    isMobile = false;\r\n\r\n    /**\r\n     * Initializes device information and whether the device is a mobile device\r\n     */\r\n    ngOnInit(): void {\r\n        this.isMobile = isMobile(window.navigator.userAgent).any;\r\n    }\r\n}\r\n", "<div class=\"drag-item\" ngClass=\"{'no-click': clickDisabled}\" [ngStyle]=\"{ 'min-width': minWidth }\">\r\n    @if (dragItem && dragItem.pictureFilePath) {\r\n        <div class=\"drag-item-picture\" [cdkDragDisabled]=\"clickDisabled\" [cdkDragData]=\"dragItem\" cdkDrag>\r\n            @if (dragItem.pictureFilePath) {\r\n                <jhi-secured-image [src]=\"filePreviewPaths.get(dragItem.pictureFilePath!) || dragItem.pictureFilePath!\" [mobileDragAndDrop]=\"isMobile\" />\r\n            }\r\n            <div *cdkDragPlaceholder></div>\r\n        </div>\r\n    }\r\n    @if (dragItem && !dragItem.pictureFilePath) {\r\n        <div class=\"drag-item-text\">\r\n            <div [fitText]=\"true\" [activateOnResize]=\"true\" [maxFontSize]=\"17\" [minFontSize]=\"15\" [delay]=\"150\">\r\n                <div class=\"drag-box\" [cdkDragDisabled]=\"clickDisabled\" [cdkDragData]=\"dragItem\" cdkDrag>\r\n                    <span>{{ dragItem.text }}</span>\r\n                    <div *cdkDragPlaceholder></div>\r\n                    <div *cdkDragPreview matchSize>\r\n                        <div style=\"border: 1px solid #000; background: white; color: black; padding: 4px; overflow: hidden; text-overflow: ellipsis\">{{ dragItem.text }}</div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    }\r\n    @if (invalid) {\r\n        <div class=\"invalid\">\r\n            <span jhiTranslate=\"artemisApp.showStatistic.invalid\"></span>\r\n        </div>\r\n    }\r\n</div>\r\n"],
  "mappings": "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",
  "names": ["DragAndDropQuestionUtil", "solve", "question", "mappings", "correctMappings", "sampleMappings", "Array", "availableDragItems", "dragItems", "remainingDropLocations", "dropLocations", "filter", "dropLocation", "some", "mapping", "isSameEntityWithTempId", "forEach", "correctMapping", "getMapping", "dragItem", "push", "solveRec", "length", "index", "splice", "solved", "pop", "validateNoMisleadingCorrectMapping", "i", "j", "dragItem1", "dragItem2", "isMappedWithDragItem1", "isMappedTogether", "isMappedWithDragItem2", "allDropLocationsForDragItem1", "getAllDropLocationsForDragItem", "allDropLocationsForDragItem2", "isSameSetOfDropLocations", "find", "map", "set1", "set2", "every", "element1", "element2", "a", "b", "undefined", "id", "tempID", "factory", "\u0275fac", "providedIn", "generate", "Math", "floor", "random", "Number", "MAX_SAFE_INTEGER", "BaseEntityWithTempId", "id", "tempID", "constructor", "generate", "DropLocation", "posX", "posY", "width", "height", "invalid", "question", "DragItem", "BaseEntityWithTempId", "pictureFilePath", "text", "question", "invalid", "constructor", "FitTextDirective", "renderer", "inject", "Renderer2", "fitText", "compression", "activateOnResize", "minFontSize", "maxFontSize", "Number", "POSITIVE_INFINITY", "delay", "innerHTML", "fontUnit", "fitTextElement", "computed", "newlines", "lineHeight", "display", "fitTextParent", "fitTextMinFontSize", "fitTextMaxFontSize", "calcSize", "resizeTimeout", "constructor", "el", "ElementRef", "nativeElement", "parentElement", "window", "getComputedStyle", "childElementCount", "onWindowResize", "setFontSize", "ngOnInit", "fontSize", "ngAfterViewInit", "ngOnChanges", "changes", "firstChange", "ngOnDestroy", "clearTimeout", "setTimeout", "offsetHeight", "offsetWidth", "setStyles", "calculateNewFontSize", "ratio", "Math", "max", "min", "parseFloat", "paddingLeft", "paddingRight", "setStyle", "toString", "selectors", "hostBindings", "rf", "ctx", "\u0275\u0275listener", "\u0275\u0275resolveWindow", "\u0275\u0275text", "\u0275\u0275element", "\u0275\u0275advance", "\u0275\u0275property", "ctx_r0", "filePreviewPaths", "get", "dragItem", "pictureFilePath", "isMobile", "\u0275\u0275elementStart", "\u0275\u0275template", "DragItemComponent_Conditional_2_Conditional_3_Template", "DragItemComponent_Conditional_2_div_4_Template", "\u0275\u0275elementEnd", "clickDisabled", "\u0275\u0275conditional", "\u0275\u0275textInterpolate", "text", "DragItemComponent_Conditional_3_div_10_Template", "DragItemComponent_Conditional_3_div_12_Template", "DragItemComponent", "minWidth", "invalid", "Map", "ngOnInit", "window", "navigator", "userAgent", "any", "selectors", "inputs", "decls", "vars", "consts", "template", "rf", "ctx", "DragItemComponent_Conditional_2_Template", "DragItemComponent_Conditional_3_Template", "DragItemComponent_Conditional_4_Template", "\u0275\u0275pureFunction1", "_c0", "NgClass", "NgStyle", "CdkDrag", "SecuredImageComponent", "CdkDragPlaceholder", "FitTextDirective", "CdkDragPreview", "TranslateDirective", "styles", "encapsulation"]
}
