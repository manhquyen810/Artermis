{
  "version": 3,
  "sources": ["src/main/webapp/app/entities/feedback.model.ts"],
  "sourcesContent": ["import { BaseEntity } from 'app/shared/model/base-entity';\r\nimport { Result } from 'app/entities/result.model';\r\nimport { TextBlock } from 'app/entities/text/text-block.model';\r\nimport { GradingInstruction } from 'app/exercises/shared/structured-grading-criterion/grading-instruction.model';\r\nimport { convertToHtmlLinebreaks, escapeString } from 'app/utils/text.utils';\r\nimport { ProgrammingExerciseTestCase } from 'app/entities/programming/programming-exercise-test-case.model';\r\n\r\nexport enum FeedbackHighlightColor {\r\n    RED = 'rgba(219, 53, 69, 0.6)',\r\n    CYAN = 'rgba(23, 162, 184, 0.3)',\r\n    BLUE = 'rgba(0, 123, 255, 0.6)',\r\n    YELLOW = 'rgba(255, 193, 7, 0.6)',\r\n    GREEN = 'rgba(40, 167, 69, 0.6)',\r\n}\r\n\r\nexport enum FeedbackType {\r\n    AUTOMATIC = 'AUTOMATIC',\r\n    MANUAL = 'MANUAL',\r\n    MANUAL_UNREFERENCED = 'MANUAL_UNREFERENCED',\r\n    AUTOMATIC_ADAPTED = 'AUTOMATIC_ADAPTED',\r\n}\r\n\r\nexport enum FeedbackSuggestionType {\r\n    NO_SUGGESTION = 'NO_SUGGESTION', // No suggestion at all\r\n    SUGGESTED = 'SUGGESTED', // Suggestion is made, but not accepted yet\r\n    ACCEPTED = 'ACCEPTED', // Suggestion is accepted\r\n    ADAPTED = 'ADAPTED', // Suggestion is accepted and then modified by the TA\r\n}\r\n\r\n// Prefixes for the feedback text to identify the feedback type more specifically without having to change the database schema:\r\nexport const STATIC_CODE_ANALYSIS_FEEDBACK_IDENTIFIER = 'SCAFeedbackIdentifier:';\r\nexport const SUBMISSION_POLICY_FEEDBACK_IDENTIFIER = 'SubPolFeedbackIdentifier:';\r\nexport const FEEDBACK_SUGGESTION_IDENTIFIER = 'FeedbackSuggestion:';\r\nexport const FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER = 'FeedbackSuggestion:accepted:';\r\nexport const FEEDBACK_SUGGESTION_ADAPTED_IDENTIFIER = 'FeedbackSuggestion:adapted:';\r\nexport const NON_GRADED_FEEDBACK_SUGGESTION_IDENTIFIER = 'NonGradedFeedbackSuggestion:';\r\n\r\nexport interface DropInfo {\r\n    instruction: GradingInstruction;\r\n}\r\n\r\n/**\r\n * Possible tutor feedback states upon validation from the server.\r\n */\r\nexport enum FeedbackCorrectionErrorType {\r\n    INCORRECT_SCORE = 'INCORRECT_SCORE',\r\n    UNNECESSARY_FEEDBACK = 'UNNECESSARY_FEEDBACK',\r\n    MISSING_GRADING_INSTRUCTION = 'MISSING_GRADING_INSTRUCTION',\r\n    INCORRECT_GRADING_INSTRUCTION = 'INCORRECT_GRADING_INSTRUCTION',\r\n    EMPTY_NEGATIVE_FEEDBACK = 'EMPTY_NEGATIVE_FEEDBACK',\r\n}\r\n\r\n/**\r\n * Wraps the information returned by the server upon validating tutor feedbacks.\r\n */\r\nexport class FeedbackCorrectionError {\r\n    // Corresponds to `Feedback.reference`. Reference to the assessed element.\r\n    public reference: string;\r\n\r\n    // The correction type of the corresponding feedback.\r\n    public type: FeedbackCorrectionErrorType;\r\n}\r\n\r\nexport type FeedbackCorrectionStatus = FeedbackCorrectionErrorType | 'CORRECT';\r\n\r\nexport class Feedback implements BaseEntity {\r\n    public id?: number;\r\n    public gradingInstruction?: GradingInstruction;\r\n    public text?: string;\r\n    public detailText?: string;\r\n    public hasLongFeedbackText?: boolean;\r\n    public reference?: string;\r\n    public credits?: number;\r\n    public type?: FeedbackType;\r\n    public result?: Result;\r\n    public positive?: boolean;\r\n    public testCase?: ProgrammingExerciseTestCase;\r\n\r\n    // Specifies whether the tutor feedback is correct relative to the instructor feedback (during tutor training) or if there is a validation error.\r\n    // Client only property.\r\n    public correctionStatus?: FeedbackCorrectionStatus;\r\n\r\n    // helper attributes for modeling exercise assessments stored in Feedback\r\n    public referenceType?: string; // this string needs to follow UMLModelElementType in Apollon in typings.d.ts\r\n    public referenceId?: string;\r\n\r\n    public copiedFeedbackId?: number; // helper attribute, only calculated locally on the client\r\n\r\n    public isSubsequent?: boolean; // helper attribute to find feedback which is not included in the total score on the client\r\n\r\n    private static readonly PROGRAMMING_REFERENCE_PREFIX = 'file:';\r\n    private static readonly PROGRAMMING_REFERENCE_LINE_SEPERATOR = '_line:';\r\n\r\n    constructor() {\r\n        this.credits = 0;\r\n    }\r\n\r\n    public static isTestCaseFeedback(feedback: Feedback): boolean {\r\n        if (feedback.type !== FeedbackType.AUTOMATIC) {\r\n            return false;\r\n        }\r\n        return !!feedback.testCase;\r\n    }\r\n\r\n    public static isStaticCodeAnalysisFeedback(that: Feedback): boolean {\r\n        if (!that.text) {\r\n            return false;\r\n        }\r\n        return that.type === FeedbackType.AUTOMATIC && that.text.startsWith(STATIC_CODE_ANALYSIS_FEEDBACK_IDENTIFIER);\r\n    }\r\n\r\n    public static isSubmissionPolicyFeedback(that: Feedback): boolean {\r\n        if (!that.text) {\r\n            return false;\r\n        }\r\n        return that.type === FeedbackType.AUTOMATIC && that.text.startsWith(SUBMISSION_POLICY_FEEDBACK_IDENTIFIER);\r\n    }\r\n\r\n    public static isFeedbackSuggestion(that: Feedback): boolean {\r\n        if (!that.text) {\r\n            return false;\r\n        }\r\n        return that.text.startsWith(FEEDBACK_SUGGESTION_IDENTIFIER);\r\n    }\r\n\r\n    public static isNonGradedFeedbackSuggestion(that: Feedback): boolean {\r\n        if (!that.text) {\r\n            return false;\r\n        }\r\n        return that.text.startsWith(NON_GRADED_FEEDBACK_SUGGESTION_IDENTIFIER);\r\n    }\r\n\r\n    /**\r\n     * Determine the type of the feedback suggestion. See FeedbackSuggestionType for more details on the meanings.\r\n     * @param that feedback to determine the type of\r\n     */\r\n    public static getFeedbackSuggestionType(that: Feedback): FeedbackSuggestionType {\r\n        if (!Feedback.isFeedbackSuggestion(that)) {\r\n            return FeedbackSuggestionType.NO_SUGGESTION;\r\n        }\r\n        // that.text is guaranteed to be defined here because the feedback is a suggestion, which must have a text\r\n        if (that.text!.startsWith(FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER)) {\r\n            return FeedbackSuggestionType.ACCEPTED;\r\n        }\r\n        if (that.text!.startsWith(FEEDBACK_SUGGESTION_ADAPTED_IDENTIFIER)) {\r\n            return FeedbackSuggestionType.ADAPTED;\r\n        }\r\n        return FeedbackSuggestionType.SUGGESTED;\r\n    }\r\n\r\n    public static hasDetailText(that: Feedback): boolean {\r\n        return that.detailText != undefined && that.detailText.length > 0;\r\n    }\r\n\r\n    public static hasContent(that: Feedback): boolean {\r\n        // if the feedback is associated with the grading instruction, the detail text is optional\r\n        return Feedback.hasDetailText(that) || !!that.gradingInstruction?.feedback;\r\n    }\r\n\r\n    /**\r\n     * Checks for equality of two feedbacks. Only checking the ids is not enough because they are undefined for inline\r\n     * feedbacks before they are saved.\r\n     * @param f1 The feedback that is compared to f2\r\n     * @param f2 The feedback that is compared to f1\r\n     */\r\n    public static areIdentical(f1: Feedback, f2: Feedback) {\r\n        return f1.id === f2.id && f1.text === f2.text && f1.detailText === f2.detailText;\r\n    }\r\n\r\n    /**\r\n     * Get the referenced file path for referenced programming feedbacks, or undefined.\r\n     * Typical reference format for programming feedback: `file:src/com/example/package/MyClass.java_line:13`.\r\n     * Example output in this case: `src/com/example/package/MyClass.java`\r\n     */\r\n    public static getReferenceFilePath(feedback: Feedback): string | undefined {\r\n        if (!feedback.reference?.startsWith(this.PROGRAMMING_REFERENCE_PREFIX)) {\r\n            // Find \"file:\" prefix\r\n            // No programming feedback\r\n            return undefined;\r\n        }\r\n        const indexOfLine = feedback.reference?.lastIndexOf(this.PROGRAMMING_REFERENCE_LINE_SEPERATOR);\r\n        return feedback.reference.substring(this.PROGRAMMING_REFERENCE_PREFIX.length, indexOfLine); // Split after \"_line:\"\r\n    }\r\n\r\n    /**\r\n     * Get the referenced line for referenced programming feedbacks, or undefined.\r\n     * Typical reference format for programming feedback: `file:src/com/example/package/MyClass.java_line:13`.\r\n     * Example output in this case: 13\r\n     */\r\n    public static getReferenceLine(feedback: Feedback): number | undefined {\r\n        if (!feedback.reference?.startsWith(this.PROGRAMMING_REFERENCE_PREFIX)) {\r\n            // Find \"file:\" prefix\r\n            // No programming feedback\r\n            return undefined;\r\n        }\r\n        const indexOfLine = feedback.reference.lastIndexOf(this.PROGRAMMING_REFERENCE_LINE_SEPERATOR); // Split before \"_line:\"\r\n        const line = parseInt(feedback.reference.substring(indexOfLine + this.PROGRAMMING_REFERENCE_LINE_SEPERATOR.length));\r\n        if (isNaN(line)) {\r\n            return undefined;\r\n        }\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Feedback is empty if it has 0 credits and the comment is empty.\r\n     * @param that\r\n     */\r\n    public static isEmpty(that: Feedback): boolean {\r\n        return !that.credits && !Feedback.hasContent(that);\r\n    }\r\n\r\n    /**\r\n     * Feedback is present if it has non 0 credits, a comment, or both.\r\n     * @param that\r\n     */\r\n    public static isPresent(that: Feedback): boolean {\r\n        return !Feedback.isEmpty(that);\r\n    }\r\n\r\n    public static hasCreditsAndComment(that: Feedback): boolean {\r\n        return that.credits != undefined && Feedback.hasContent(that);\r\n    }\r\n\r\n    public static haveCredits(that: Feedback[]): boolean {\r\n        return that.filter(Feedback.hasCredits).length > 0 && that.filter(Feedback.hasCredits).length === that.length;\r\n    }\r\n\r\n    public static hasCredits(that: Feedback): boolean {\r\n        return that.credits != undefined;\r\n    }\r\n\r\n    public static haveCreditsAndComments(that: Feedback[]): boolean {\r\n        return that.filter(Feedback.hasCreditsAndComment).length > 0 && that.filter(Feedback.hasCreditsAndComment).length === that.length;\r\n    }\r\n\r\n    public static forModeling(credits: number, text?: string, referenceId?: string, referenceType?: string, dropInfo?: DropInfo): Feedback {\r\n        const that = new Feedback();\r\n        that.referenceId = referenceId;\r\n        that.referenceType = referenceType;\r\n        that.credits = credits;\r\n        that.text = text;\r\n        if (dropInfo?.instruction?.id) {\r\n            that.gradingInstruction = dropInfo.instruction;\r\n        }\r\n        if (referenceType && referenceId) {\r\n            that.reference = referenceType + ':' + referenceId;\r\n        }\r\n        return that;\r\n    }\r\n\r\n    public static forText(textBlock: TextBlock, credits = 0, detailText?: string): Feedback {\r\n        const that = new Feedback();\r\n        that.reference = textBlock.id;\r\n        that.credits = credits;\r\n        that.detailText = detailText;\r\n\r\n        // Delete unused properties\r\n        that.referenceId = undefined;\r\n        that.referenceType = undefined;\r\n        that.text = undefined;\r\n        that.positive = undefined;\r\n\r\n        return that;\r\n    }\r\n\r\n    public static fromServerResponse(response: Feedback): Feedback {\r\n        return Object.assign(new Feedback(), response);\r\n    }\r\n\r\n    public static updateFeedbackTypeOnChange(feedback: Feedback) {\r\n        if (Feedback.isFeedbackSuggestion(feedback)) {\r\n            // Mark as adapted feedback suggestion\r\n            feedback.text = (feedback.text ?? FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER).replace(FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER, FEEDBACK_SUGGESTION_ADAPTED_IDENTIFIER);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper method to build the feedback text for the review. When the feedback has a link with grading instruction\r\n * it merges the feedback of the grading instruction with the feedback text provided by the assessor. Otherwise,\r\n * it returns the detailed text and/or text properties of the feedback depending on the submission element.\r\n *\r\n * @param feedback that contains feedback text and grading instruction\r\n * @param addFeedbackText if the text of the feedback should be part of the resulting text. Defaults to true.\r\n *                        The detailText of the feedback is always added if present.\r\n * @returns formatted string representing the feedback text ready to display\r\n */\r\nexport const buildFeedbackTextForReview = (feedback: Feedback, addFeedbackText = true): string => {\r\n    let feedbackText = '';\r\n    if (feedback.gradingInstruction?.feedback) {\r\n        feedbackText = feedback.gradingInstruction.feedback;\r\n        if (feedback.detailText) {\r\n            feedbackText = feedbackText + '\\n' + feedback.detailText;\r\n        }\r\n        if (addFeedbackText && feedback.text) {\r\n            feedbackText = feedbackText + '\\n' + feedback.text;\r\n        }\r\n    } else if (feedback.detailText) {\r\n        feedbackText = feedback.detailText;\r\n    } else if (addFeedbackText && feedback.text) {\r\n        feedbackText = feedback.text;\r\n    }\r\n\r\n    // escape special characters like \"<\", \">\", \"&\" to render them correctly\r\n    feedbackText = escapeString(feedbackText);\r\n    return convertToHtmlLinebreaks(feedbackText);\r\n};\r\n/**\r\n * Helper method to find subsequent feedback for the review. When the feedback has a link with grading instruction,\r\n * it keeps the number of how many times the grading instructions are applied. If the usage limit is exceeded for the\r\n * grading instruction, it marks the feedback as subsequent.\r\n *\r\n * @param feedbacks the list of feedbacks\r\n */\r\nexport const checkSubsequentFeedbackInAssessment = (feedbacks: Feedback[]) => {\r\n    const gradingInstructions: { [key: number]: number } = {}; // { instructionId: number of encounters }\r\n    for (const feedback of feedbacks) {\r\n        if (feedback.gradingInstruction && feedback.gradingInstruction.credits !== 0) {\r\n            if (gradingInstructions[feedback.gradingInstruction!.id!]) {\r\n                // this grading instruction is counted before\r\n                const maxCount = feedback.gradingInstruction.usageCount;\r\n                const encounters = gradingInstructions[feedback.gradingInstruction!.id!];\r\n                if (maxCount && maxCount > 0) {\r\n                    if (encounters >= maxCount) {\r\n                        // usage limit is exceeded, mark the feedback as subsequent\r\n                        feedback.isSubsequent = true;\r\n                    }\r\n                    gradingInstructions[feedback.gradingInstruction!.id!] = encounters + 1;\r\n                }\r\n            } else {\r\n                // the grading instruction is encountered for the first time\r\n                gradingInstructions[feedback.gradingInstruction!.id!] = 1;\r\n            }\r\n        }\r\n    }\r\n};\r\n"],
  "mappings": "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",
  "names": ["FeedbackHighlightColor", "FeedbackType", "FeedbackSuggestionType", "STATIC_CODE_ANALYSIS_FEEDBACK_IDENTIFIER", "SUBMISSION_POLICY_FEEDBACK_IDENTIFIER", "FEEDBACK_SUGGESTION_IDENTIFIER", "FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER", "FEEDBACK_SUGGESTION_ADAPTED_IDENTIFIER", "NON_GRADED_FEEDBACK_SUGGESTION_IDENTIFIER", "Feedback", "id", "gradingInstruction", "text", "detailText", "hasLongFeedbackText", "reference", "credits", "type", "result", "positive", "testCase", "correctionStatus", "referenceType", "referenceId", "copiedFeedbackId", "isSubsequent", "PROGRAMMING_REFERENCE_PREFIX", "PROGRAMMING_REFERENCE_LINE_SEPERATOR", "constructor", "isTestCaseFeedback", "feedback", "FeedbackType", "AUTOMATIC", "isStaticCodeAnalysisFeedback", "that", "startsWith", "STATIC_CODE_ANALYSIS_FEEDBACK_IDENTIFIER", "isSubmissionPolicyFeedback", "SUBMISSION_POLICY_FEEDBACK_IDENTIFIER", "isFeedbackSuggestion", "FEEDBACK_SUGGESTION_IDENTIFIER", "isNonGradedFeedbackSuggestion", "NON_GRADED_FEEDBACK_SUGGESTION_IDENTIFIER", "getFeedbackSuggestionType", "FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER", "FeedbackSuggestionType", "ACCEPTED", "FEEDBACK_SUGGESTION_ADAPTED_IDENTIFIER", "ADAPTED", "SUGGESTED", "NO_SUGGESTION", "hasDetailText", "undefined", "length", "hasContent", "areIdentical", "f1", "f2", "getReferenceFilePath", "indexOfLine", "lastIndexOf", "substring", "getReferenceLine", "line", "parseInt", "isNaN", "isEmpty", "isPresent", "hasCreditsAndComment", "haveCredits", "filter", "hasCredits", "haveCreditsAndComments", "forModeling", "dropInfo", "instruction", "forText", "textBlock", "fromServerResponse", "response", "Object", "assign", "updateFeedbackTypeOnChange", "replace", "buildFeedbackTextForReview", "addFeedbackText", "feedbackText", "escapeString", "convertToHtmlLinebreaks", "checkSubsequentFeedbackInAssessment", "feedbacks", "gradingInstructions", "maxCount", "usageCount", "encounters"]
}
