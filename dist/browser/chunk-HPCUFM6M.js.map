{
  "version": 3,
  "sources": ["src/main/webapp/app/assessment/athena.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport { HttpClient, HttpResponse } from '@angular/common/http';\r\nimport { Observable, map, of, switchMap } from 'rxjs';\r\nimport { ProfileService } from 'app/shared/layouts/profiles/profile.service';\r\nimport { ModelingFeedbackSuggestion, ProgrammingFeedbackSuggestion, TextFeedbackSuggestion } from 'app/entities/feedback-suggestion.model';\r\nimport { Exercise } from 'app/entities/exercise.model';\r\nimport { FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER, FEEDBACK_SUGGESTION_IDENTIFIER, Feedback, FeedbackType } from 'app/entities/feedback.model';\r\nimport { TextBlock } from 'app/entities/text/text-block.model';\r\nimport { TextBlockRef } from 'app/entities/text/text-block-ref.model';\r\nimport { TextSubmission } from 'app/entities/text/text-submission.model';\r\nimport { PROFILE_ATHENA } from 'app/app.constants';\r\nimport { ModelingSubmission } from 'app/entities/modeling-submission.model';\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class AthenaService {\r\n    protected http = inject(HttpClient);\r\n    private profileService = inject(ProfileService);\r\n\r\n    public resourceUrl = 'api/athena';\r\n\r\n    /**\r\n     * Determine if the Athena service is available based on whether the corresponding profile is active\r\n     */\r\n    public isEnabled(): Observable<boolean> {\r\n        return this.profileService.getProfileInfo().pipe(switchMap((profileInfo) => of(profileInfo.activeProfiles.includes(PROFILE_ATHENA))));\r\n    }\r\n\r\n    /**\r\n     * Fetches all available modules for a course and exercise.\r\n     *\r\n     * @param courseId The id of the course for which the feedback suggestion modules should be fetched\r\n     * @param exercise The exercise for which the feedback suggestion modules should be fetched\r\n     */\r\n    public getAvailableModules(courseId: number, exercise: Exercise): Observable<string[]> {\r\n        return this.isEnabled().pipe(\r\n            switchMap((isAthenaEnabled) => {\r\n                if (!isAthenaEnabled) {\r\n                    return of([] as string[]);\r\n                }\r\n                return this.http\r\n                    .get<string[]>(`${this.resourceUrl}/courses/${courseId}/${exercise.type}-exercises/available-modules`, { observe: 'response' })\r\n                    .pipe(switchMap((res: HttpResponse<string[]>) => of(res.body!)));\r\n            }),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get feedback suggestions for the given submission from Athena\r\n     *\r\n     * @param exercise\r\n     * @param submissionId the id of the submission\r\n     * @return observable that emits the feedback suggestions\r\n     */\r\n    private getFeedbackSuggestions<T>(exercise: Exercise, submissionId: number): Observable<T[]> {\r\n        if (!exercise.feedbackSuggestionModule) {\r\n            return of([]);\r\n        }\r\n        return this.isEnabled().pipe(\r\n            switchMap((isAthenaEnabled) => {\r\n                if (!isAthenaEnabled) {\r\n                    return of([] as T[]);\r\n                }\r\n                return this.http\r\n                    .get<T[]>(`${this.resourceUrl}/${exercise.type}-exercises/${exercise.id}/submissions/${submissionId}/feedback-suggestions`, { observe: 'response' })\r\n                    .pipe(switchMap((res: HttpResponse<T[]>) => of(res.body!)));\r\n            }),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Find a grading instruction by id in the given exercise\r\n     */\r\n    private findGradingInstruction(exercise: Exercise, id: number): any | undefined {\r\n        for (const criterion of exercise.gradingCriteria ?? []) {\r\n            for (const instruction of criterion.structuredGradingInstructions) {\r\n                if (instruction.id == id) {\r\n                    return instruction;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Get feedback suggestions for the given text submission from Athena\r\n     *\r\n     * @param exercise\r\n     * @param submission  the submission\r\n     * @return observable that emits the referenced feedback suggestions as TextBlockRef objects\r\n     * with TextBlocks and the unreferenced feedback suggestions as Feedback objects\r\n     * with the \"FeedbackSuggestion:\" prefix\r\n     */\r\n    public getTextFeedbackSuggestions(exercise: Exercise, submission: TextSubmission): Observable<(TextBlockRef | Feedback)[]> {\r\n        return this.getFeedbackSuggestions<TextFeedbackSuggestion>(exercise, submission.id!).pipe(\r\n            map((suggestions) => {\r\n                // Convert referenced feedback suggestions to TextBlockRefs for easier handling in the components\r\n                return suggestions.map((suggestion) => {\r\n                    const feedback = new Feedback();\r\n                    feedback.credits = suggestion.credits;\r\n                    // Text feedback suggestions are automatically accepted, so we can set the text directly:\r\n                    feedback.text = FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER + suggestion.title;\r\n                    feedback.detailText = suggestion.description;\r\n                    // Load grading instruction from exercise, if available\r\n                    if (suggestion.structuredGradingInstructionId != undefined) {\r\n                        feedback.gradingInstruction = this.findGradingInstruction(exercise, suggestion.structuredGradingInstructionId);\r\n                    }\r\n                    if (suggestion.indexStart == null) {\r\n                        // Unreferenced feedback, return Feedback object\r\n                        feedback.type = FeedbackType.MANUAL_UNREFERENCED;\r\n                        return feedback;\r\n                    }\r\n                    // Referenced feedback, convert to TextBlockRef\r\n                    feedback.type = FeedbackType.MANUAL;\r\n                    const textBlock = new TextBlock();\r\n                    textBlock.startIndex = suggestion.indexStart;\r\n                    textBlock.endIndex = suggestion.indexEnd;\r\n                    textBlock.setTextFromSubmission(submission);\r\n                    feedback.reference = textBlock.id;\r\n                    return new TextBlockRef(textBlock, feedback);\r\n                });\r\n            }),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get feedback suggestions for the given programming submission from Athena\r\n     *\r\n     * @param exercise\r\n     * @param submissionId the id of the submission\r\n     * @return observable that emits the feedback suggestions as Feedback objects with the \"FeedbackSuggestion:\" prefix\r\n     */\r\n    public getProgrammingFeedbackSuggestions(exercise: Exercise, submissionId: number): Observable<Feedback[]> {\r\n        return this.getFeedbackSuggestions<ProgrammingFeedbackSuggestion>(exercise, submissionId).pipe(\r\n            map((suggestions) => {\r\n                return suggestions.map((suggestion) => {\r\n                    const feedback = new Feedback();\r\n                    feedback.credits = suggestion.credits;\r\n                    feedback.text = FEEDBACK_SUGGESTION_IDENTIFIER + suggestion.title;\r\n                    feedback.detailText = suggestion.description;\r\n                    if (suggestion.filePath != undefined && (suggestion.lineEnd ?? suggestion.lineStart) != undefined) {\r\n                        // Referenced feedback\r\n                        feedback.type = FeedbackType.MANUAL;\r\n                        feedback.reference = `file:${suggestion.filePath}_line:${suggestion.lineEnd ?? suggestion.lineStart}`; // Only use a single line for now because Artemis does not support line ranges\r\n                    } else {\r\n                        // Unreferenced feedback\r\n                        feedback.type = FeedbackType.MANUAL_UNREFERENCED;\r\n                        feedback.reference = undefined;\r\n                    }\r\n                    // Load grading instruction from exercise, if available\r\n                    if (suggestion.structuredGradingInstructionId != undefined) {\r\n                        feedback.gradingInstruction = this.findGradingInstruction(exercise, suggestion.structuredGradingInstructionId);\r\n                    }\r\n                    return feedback;\r\n                });\r\n            }),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get feedback suggestions for the given modeling submission from Athena.\r\n     *\r\n     * @param exercise The exercise for which a submission is assessed\r\n     * @param submission The assessed submission\r\n     * @return observable that emits the feedback suggestions as Feedback objects with the \"FeedbackSuggestion:\" prefix\r\n     */\r\n    public getModelingFeedbackSuggestions(exercise: Exercise, submission: ModelingSubmission): Observable<Feedback[]> {\r\n        return this.getFeedbackSuggestions<ModelingFeedbackSuggestion>(exercise, submission.id!).pipe(\r\n            map((suggestions) => {\r\n                return suggestions.map((suggestion, index) => {\r\n                    const feedback = new Feedback();\r\n                    feedback.id = index;\r\n                    feedback.credits = suggestion.credits;\r\n                    feedback.positive = suggestion.credits >= 1;\r\n\r\n                    // Extract reference details if present\r\n                    const reference = suggestion.reference?.split(':');\r\n                    const [referenceType, referenceId] = reference || [];\r\n\r\n                    if (referenceId) {\r\n                        feedback.type = FeedbackType.AUTOMATIC;\r\n                        feedback.text = suggestion.description;\r\n                        feedback.reference = suggestion.reference;\r\n                        feedback.referenceId = referenceId;\r\n                        feedback.referenceType = referenceType;\r\n                    } else {\r\n                        feedback.type = FeedbackType.MANUAL_UNREFERENCED;\r\n                        feedback.text = `${FEEDBACK_SUGGESTION_IDENTIFIER}${suggestion.title}`;\r\n                        feedback.detailText = suggestion.description;\r\n                    }\r\n\r\n                    // Attach grading instruction if available\r\n                    if (suggestion.structuredGradingInstructionId) {\r\n                        feedback.gradingInstruction = this.findGradingInstruction(exercise, suggestion.structuredGradingInstructionId);\r\n                    }\r\n\r\n                    return feedback;\r\n                });\r\n            }),\r\n        );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["AthenaService", "http", "inject", "HttpClient", "profileService", "ProfileService", "resourceUrl", "isEnabled", "getProfileInfo", "pipe", "switchMap", "profileInfo", "of", "activeProfiles", "includes", "PROFILE_ATHENA", "getAvailableModules", "courseId", "exercise", "isAthenaEnabled", "get", "type", "observe", "res", "body", "getFeedbackSuggestions", "submissionId", "feedbackSuggestionModule", "id", "findGradingInstruction", "criterion", "gradingCriteria", "instruction", "structuredGradingInstructions", "getTextFeedbackSuggestions", "submission", "map", "suggestions", "suggestion", "feedback", "Feedback", "credits", "text", "FEEDBACK_SUGGESTION_ACCEPTED_IDENTIFIER", "title", "detailText", "description", "structuredGradingInstructionId", "undefined", "gradingInstruction", "indexStart", "FeedbackType", "MANUAL_UNREFERENCED", "MANUAL", "textBlock", "TextBlock", "startIndex", "endIndex", "indexEnd", "setTextFromSubmission", "reference", "TextBlockRef", "getProgrammingFeedbackSuggestions", "FEEDBACK_SUGGESTION_IDENTIFIER", "filePath", "lineEnd", "lineStart", "getModelingFeedbackSuggestions", "index", "positive", "split", "referenceType", "referenceId", "AUTOMATIC", "factory", "\u0275fac", "providedIn"]
}
