{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/quiz/manage/quiz-exercise.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport { HttpClient, HttpResponse } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\nimport { QuizBatch, QuizExercise, QuizStatus } from 'app/entities/quiz/quiz-exercise.model';\r\nimport { createRequestOption } from 'app/shared/util/request.util';\r\nimport { ExerciseService } from 'app/exercises/shared/exercise/exercise.service';\r\nimport { QuizQuestion, QuizQuestionType } from 'app/entities/quiz/quiz-question.model';\r\nimport { DragAndDropQuestion } from 'app/entities/quiz/drag-and-drop-question.model';\r\nimport { downloadFile, downloadZipFromFilePromises } from 'app/shared/util/download.util';\r\nimport { objectToJsonBlob } from 'app/utils/blob-util';\r\nimport { FileService } from 'app/shared/http/file.service';\r\nimport JSZip from 'jszip';\r\n\r\nexport type EntityResponseType = HttpResponse<QuizExercise>;\r\nexport type EntityArrayResponseType = HttpResponse<QuizExercise[]>;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class QuizExerciseService {\r\n    private http = inject(HttpClient);\r\n    private exerciseService = inject(ExerciseService);\r\n    private fileService = inject(FileService);\r\n    private resourceUrl = 'api/quiz/quiz-exercises';\r\n\r\n    /**\r\n     * Create the given quiz exercise\r\n     * @param quizExercise the quiz exercise that should be created\r\n     * @param files the files that should be uploaded\r\n     */\r\n    create(quizExercise: QuizExercise, files: Map<string, Blob>): Observable<EntityResponseType> {\r\n        const copy = ExerciseService.convertExerciseDatesFromClient(quizExercise);\r\n        copy.categories = ExerciseService.stringifyExerciseCategories(copy);\r\n\r\n        const formData = new FormData();\r\n        formData.append('exercise', objectToJsonBlob(copy));\r\n        files.forEach((file, fileName) => {\r\n            formData.append('files', file, fileName);\r\n        });\r\n\r\n        return this.http\r\n            .post<QuizExercise>(this.resourceUrl, formData, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Imports a quiz exercise by cloning the entity itself plus example solutions and example submissions\r\n     *\r\n     * @param adaptedSourceQuizExercise The exercise that should be imported, including adapted values for the\r\n     * new exercise. E.g. with another title than the original exercise. Old values that should get discarded\r\n     * (like the old ID) will be handled by the server.\r\n     * @param files The files that should be uploaded\r\n     */\r\n    import(adaptedSourceQuizExercise: QuizExercise, files: Map<string, Blob>) {\r\n        let copy = ExerciseService.convertExerciseDatesFromClient(adaptedSourceQuizExercise);\r\n        copy = ExerciseService.setBonusPointsConstrainedByIncludedInOverallScore(copy);\r\n        copy.categories = ExerciseService.stringifyExerciseCategories(copy);\r\n\r\n        const formData = new FormData();\r\n        formData.append('exercise', objectToJsonBlob(copy));\r\n        files.forEach((file, fileName) => {\r\n            formData.append('files', file, fileName);\r\n        });\r\n\r\n        return this.http\r\n            .post<QuizExercise>(`${this.resourceUrl}/import/${adaptedSourceQuizExercise.id}`, formData, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Update the given quiz exercise\r\n     * @param id the id of the quiz exercise that should be updated\r\n     * @param quizExercise the quiz exercise that should be updated\r\n     * @param files the files that should be uploaded\r\n     * @param req Additional parameters that should be passed to the server when updating the exercise\r\n     */\r\n    update(id: number, quizExercise: QuizExercise, files: Map<string, Blob>, req?: any): Observable<EntityResponseType> {\r\n        const options = createRequestOption(req);\r\n        const copy = ExerciseService.convertExerciseDatesFromClient(quizExercise);\r\n        copy.categories = ExerciseService.stringifyExerciseCategories(copy);\r\n\r\n        const formData = new FormData();\r\n        formData.append('exercise', objectToJsonBlob(copy));\r\n        files.forEach((file, fileName) => {\r\n            formData.append('files', file, fileName);\r\n        });\r\n\r\n        return this.http\r\n            .put<QuizExercise>(this.resourceUrl + '/' + id, formData, { params: options, observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Find the quiz exercise with the given id\r\n     * @param quizExerciseId the id of the quiz exercise that should be found\r\n     */\r\n    find(quizExerciseId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .get<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}`, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Recalculate the statistics for a given quiz exercise\r\n     * @param quizExerciseId the id of the quiz exercise for which the statistics should be recalculated\r\n     */\r\n    recalculate(quizExerciseId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .get<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}/recalculate-statistics`, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Note: the exercises in the response do not contain participations and do not contain the course to save network bandwidth\r\n     * They also do not contain questions\r\n     *\r\n     * @param courseId the course for which the quiz exercises should be returned\r\n     */\r\n    findForCourse(courseId: number): Observable<EntityArrayResponseType> {\r\n        return this.http\r\n            .get<QuizExercise[]>(`api/quiz/courses/${courseId}/quiz-exercises`, { observe: 'response' })\r\n            .pipe(map((res: EntityArrayResponseType) => this.exerciseService.processExerciseEntityArrayResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Note: the exercises in the response do not contain participations, the course and also not the exerciseGroup to save network bandwidth\r\n     * They also do not contain questions\r\n     *\r\n     * @param examId the exam for which the quiz exercises should be returned\r\n     */\r\n    findForExam(examId: number): Observable<EntityArrayResponseType> {\r\n        return this.http\r\n            .get<QuizExercise[]>(`api/exam/exams/${examId}/quiz-exercises`, { observe: 'response' })\r\n            .pipe(map((res: EntityArrayResponseType) => this.exerciseService.processExerciseEntityArrayResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Find the quiz exercise with the given id, with information filtered for students\r\n     * @param quizExerciseId the id of the quiz exercise that should be loaded\r\n     */\r\n    findForStudent(quizExerciseId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .get<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}/for-student`, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Open a quiz exercise for practice\r\n     * @param quizExerciseId the id of the quiz exercise that should be opened for practice\r\n     */\r\n    openForPractice(quizExerciseId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .put<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}/open-for-practice`, null, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Start a quiz exercise\r\n     * @param quizExerciseId the id of the quiz exercise that should be started\r\n     */\r\n    start(quizExerciseId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .put<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}/start-now`, null, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * End a quiz exercise\r\n     * @param quizExerciseId the id of the quiz exercise that should be stopped\r\n     */\r\n    end(quizExerciseId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .put<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}/end-now`, null, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Set a quiz exercise visible\r\n     * @param quizExerciseId the id of the quiz exercise that should be set visible\r\n     */\r\n    setVisible(quizExerciseId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .put<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}/set-visible`, null, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Start a quiz batch\r\n     * @param quizBatchId the id of the quiz batch that should be started\r\n     */\r\n    startBatch(quizBatchId: number): Observable<HttpResponse<QuizBatch>> {\r\n        return this.http.put<QuizBatch>(`${this.resourceUrl}/${quizBatchId}/start-batch`, null, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Start a quiz batch\r\n     * @param quizExerciseId the id of the quiz exercise that should be started\r\n     */\r\n    addBatch(quizExerciseId: number): Observable<HttpResponse<QuizBatch>> {\r\n        return this.http.put<QuizBatch>(`${this.resourceUrl}/${quizExerciseId}/add-batch`, null, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Load all quiz exercises\r\n     */\r\n    query(): Observable<EntityArrayResponseType> {\r\n        return this.http\r\n            .get<QuizExercise[]>(this.resourceUrl, { observe: 'response' })\r\n            .pipe(map((res: EntityArrayResponseType) => this.exerciseService.processExerciseEntityArrayResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Delete a quiz exercise\r\n     * @param quizExerciseId the id of the quiz exercise that should be deleted\r\n     */\r\n    delete(quizExerciseId: number): Observable<HttpResponse<any>> {\r\n        return this.http.delete(`${this.resourceUrl}/${quizExerciseId}`, { observe: 'response' });\r\n    }\r\n\r\n    join(quizExerciseId: number, password: string): Observable<HttpResponse<QuizBatch>> {\r\n        return this.http.post<QuizExercise>(`${this.resourceUrl}/${quizExerciseId}/join`, { password }, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Exports given quiz questions into json file\r\n     * @param quizQuestions Quiz questions we want to export\r\n     * @param exportAll If true exports all questions, else exports only those whose export flag is true\r\n     * @param fileName Name (without ending) of the resulting file, defaults to 'quiz'\r\n     */\r\n    exportQuiz(quizQuestions?: QuizQuestion[], exportAll?: boolean, fileName?: string) {\r\n        // Make list of questions which we need to export,\r\n        const questions: QuizQuestion[] = [];\r\n\r\n        quizQuestions!.forEach((question) => {\r\n            if (exportAll === true || question.exportQuiz) {\r\n                question.quizQuestionStatistic = undefined;\r\n                question.exercise = undefined;\r\n                questions.push(question);\r\n            }\r\n        });\r\n        if (questions.length === 0) {\r\n            return;\r\n        }\r\n        this.exportAssetsFromAllQuestions(questions, fileName ?? 'quiz');\r\n    }\r\n\r\n    /**\r\n     * Exports assets (images) embedded in the markdown and from drag and drop exercises\r\n     * @param questions list of questions which will be exported\r\n     * @param fileName name of the output zip file\r\n     */\r\n    exportAssetsFromAllQuestions(questions: QuizQuestion[], fileName: string) {\r\n        const zip: JSZip = new JSZip();\r\n        const filePromises: Promise<void | File>[] = [];\r\n        const quizJson = JSON.stringify(questions);\r\n        const blob = new Blob([quizJson], { type: 'application/json' });\r\n        questions.forEach((question, questionIndex) => {\r\n            if (question.type === QuizQuestionType.DRAG_AND_DROP) {\r\n                if ((question as DragAndDropQuestion).backgroundFilePath) {\r\n                    const filePath = (question as DragAndDropQuestion).backgroundFilePath!;\r\n                    const fileNameExtension = filePath.split('.').last();\r\n                    filePromises.push(this.fetchFilePromise(`q${questionIndex}_background.${fileNameExtension}`, zip, filePath));\r\n                }\r\n                if ((question as DragAndDropQuestion).dragItems) {\r\n                    (question as DragAndDropQuestion).dragItems?.forEach((dragItem, drag_index) => {\r\n                        if (dragItem.pictureFilePath) {\r\n                            const filePath = dragItem.pictureFilePath!;\r\n                            const fileNameExtension = filePath.split('.').last();\r\n                            filePromises.push(this.fetchFilePromise(`q${questionIndex}_dragItem-${drag_index}.${fileNameExtension}`, zip, filePath));\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            this.findImagesInMarkdown(JSON.stringify(question)).forEach((embeddedImage) => {\r\n                filePromises.push(this.fetchFilePromise(`q${questionIndex}_${embeddedImage[1]}`, zip, embeddedImage[2]));\r\n            });\r\n        });\r\n        if (filePromises.length === 0) {\r\n            downloadFile(blob, (fileName ?? 'quiz') + '.json');\r\n            return;\r\n        }\r\n        zip.file((fileName ?? 'quiz') + '.json', blob);\r\n        downloadZipFromFilePromises(zip, filePromises, fileName);\r\n    }\r\n\r\n    findImagesInMarkdown(description: string) {\r\n        // Will return all matches of ![file_name](path), will group file_name and path\r\n        const embeddedImageRegex = /!\\[(.+?)\\]\\((.+?)\\)/g;\r\n        return [...description.matchAll(embeddedImageRegex)];\r\n    }\r\n\r\n    /**\r\n     * This method fetches a file through the file Service, zips it and pushes it to the provided list of file Promises\r\n     * @param fileName the name of the file to be zipped\r\n     * @param zip a JSZip instance\r\n     * @param filePath the internal path of the file to be fetched\r\n     */\r\n    async fetchFilePromise(fileName: string, zip: JSZip, filePath: string) {\r\n        return this.fileService\r\n            .getFile(filePath)\r\n            .then((fileResult) => {\r\n                zip.file(fileName, fileResult);\r\n            })\r\n            .catch((error) => {\r\n                throw new Error(`File with name: ${fileName} at path: ${filePath} could not be fetched` + error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Evaluates the QuizStatus for a given quiz\r\n     *\r\n     * @param quizExercise the quiz exercise to get the status of\r\n     * @return the status of the quiz\r\n     */\r\n    getStatus(quizExercise: QuizExercise) {\r\n        if (!quizExercise.quizStarted) {\r\n            return QuizStatus.INVISIBLE;\r\n        }\r\n        if (quizExercise.quizEnded) {\r\n            return quizExercise.isOpenForPractice ? QuizStatus.OPEN_FOR_PRACTICE : QuizStatus.CLOSED;\r\n        }\r\n        if (quizExercise.quizBatches && quizExercise.quizBatches.some((batch) => batch.started)) {\r\n            return QuizStatus.ACTIVE;\r\n        }\r\n        return QuizStatus.VISIBLE;\r\n    }\r\n}\r\n"],
  "mappings": "sdAYA,IAAAA,EAAkB,OAMlB,IAAaC,GAAmB,IAAA,CAA1B,MAAOA,CAAmB,CACpBC,KAAOC,EAAOC,CAAU,EACxBC,gBAAkBF,EAAOG,CAAe,EACxCC,YAAcJ,EAAOK,CAAW,EAChCC,YAAc,0BAOtBC,OAAOC,EAA4BC,EAAwB,CACvD,IAAMC,EAAOP,EAAgBQ,+BAA+BH,CAAY,EACxEE,EAAKE,WAAaT,EAAgBU,4BAA4BH,CAAI,EAElE,IAAMI,EAAW,IAAIC,SACrBD,OAAAA,EAASE,OAAO,WAAYC,EAAiBP,CAAI,CAAC,EAClDD,EAAMS,QAAQ,CAACC,EAAMC,IAAY,CAC7BN,EAASE,OAAO,QAASG,EAAMC,CAAQ,CAC3C,CAAC,EAEM,KAAKrB,KACPsB,KAAmB,KAAKf,YAAaQ,EAAU,CAAEQ,QAAS,UAAU,CAAE,EACtEC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAUAE,OAAOC,EAAyCnB,EAAwB,CACpE,IAAIC,EAAOP,EAAgBQ,+BAA+BiB,CAAyB,EACnFlB,EAAOP,EAAgB0B,kDAAkDnB,CAAI,EAC7EA,EAAKE,WAAaT,EAAgBU,4BAA4BH,CAAI,EAElE,IAAMI,EAAW,IAAIC,SACrBD,OAAAA,EAASE,OAAO,WAAYC,EAAiBP,CAAI,CAAC,EAClDD,EAAMS,QAAQ,CAACC,EAAMC,IAAY,CAC7BN,EAASE,OAAO,QAASG,EAAMC,CAAQ,CAC3C,CAAC,EAEM,KAAKrB,KACPsB,KAAmB,GAAG,KAAKf,WAAW,WAAWsB,EAA0BE,EAAE,GAAIhB,EAAU,CAAEQ,QAAS,UAAU,CAAE,EAClHC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CASAM,OAAOD,EAAYtB,EAA4BC,EAA0BuB,EAAS,CAC9E,IAAMC,EAAUC,EAAoBF,CAAG,EACjCtB,EAAOP,EAAgBQ,+BAA+BH,CAAY,EACxEE,EAAKE,WAAaT,EAAgBU,4BAA4BH,CAAI,EAElE,IAAMI,EAAW,IAAIC,SACrBD,OAAAA,EAASE,OAAO,WAAYC,EAAiBP,CAAI,CAAC,EAClDD,EAAMS,QAAQ,CAACC,EAAMC,IAAY,CAC7BN,EAASE,OAAO,QAASG,EAAMC,CAAQ,CAC3C,CAAC,EAEM,KAAKrB,KACPoC,IAAkB,KAAK7B,YAAc,IAAMwB,EAAIhB,EAAU,CAAEsB,OAAQH,EAASX,QAAS,UAAU,CAAE,EACjGC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAMAY,KAAKC,EAAsB,CACvB,OAAO,KAAKvC,KACPwC,IAAkB,GAAG,KAAKjC,WAAW,IAAIgC,CAAc,GAAI,CAAEhB,QAAS,UAAU,CAAE,EAClFC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAMAe,YAAYF,EAAsB,CAC9B,OAAO,KAAKvC,KACPwC,IAAkB,GAAG,KAAKjC,WAAW,IAAIgC,CAAc,0BAA2B,CAAEhB,QAAS,UAAU,CAAE,EACzGC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAQAgB,cAAcC,EAAgB,CAC1B,OAAO,KAAK3C,KACPwC,IAAoB,oBAAoBG,CAAQ,kBAAmB,CAAEpB,QAAS,UAAU,CAAE,EAC1FC,KAAKC,EAAKC,GAAiC,KAAKvB,gBAAgByC,mCAAmClB,CAAG,CAAC,CAAC,CACjH,CAQAmB,YAAYC,EAAc,CACtB,OAAO,KAAK9C,KACPwC,IAAoB,kBAAkBM,CAAM,kBAAmB,CAAEvB,QAAS,UAAU,CAAE,EACtFC,KAAKC,EAAKC,GAAiC,KAAKvB,gBAAgByC,mCAAmClB,CAAG,CAAC,CAAC,CACjH,CAMAqB,eAAeR,EAAsB,CACjC,OAAO,KAAKvC,KACPwC,IAAkB,GAAG,KAAKjC,WAAW,IAAIgC,CAAc,eAAgB,CAAEhB,QAAS,UAAU,CAAE,EAC9FC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAMAsB,gBAAgBT,EAAsB,CAClC,OAAO,KAAKvC,KACPoC,IAAkB,GAAG,KAAK7B,WAAW,IAAIgC,CAAc,qBAAsB,KAAM,CAAEhB,QAAS,UAAU,CAAE,EAC1GC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAMAuB,MAAMV,EAAsB,CACxB,OAAO,KAAKvC,KACPoC,IAAkB,GAAG,KAAK7B,WAAW,IAAIgC,CAAc,aAAc,KAAM,CAAEhB,QAAS,UAAU,CAAE,EAClGC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAMAwB,IAAIX,EAAsB,CACtB,OAAO,KAAKvC,KACPoC,IAAkB,GAAG,KAAK7B,WAAW,IAAIgC,CAAc,WAAY,KAAM,CAAEhB,QAAS,UAAU,CAAE,EAChGC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAMAyB,WAAWZ,EAAsB,CAC7B,OAAO,KAAKvC,KACPoC,IAAkB,GAAG,KAAK7B,WAAW,IAAIgC,CAAc,eAAgB,KAAM,CAAEhB,QAAS,UAAU,CAAE,EACpGC,KAAKC,EAAKC,GAA4B,KAAKvB,gBAAgBwB,8BAA8BD,CAAG,CAAC,CAAC,CACvG,CAMA0B,WAAWC,EAAmB,CAC1B,OAAO,KAAKrD,KAAKoC,IAAe,GAAG,KAAK7B,WAAW,IAAI8C,CAAW,eAAgB,KAAM,CAAE9B,QAAS,UAAU,CAAE,CACnH,CAMA+B,SAASf,EAAsB,CAC3B,OAAO,KAAKvC,KAAKoC,IAAe,GAAG,KAAK7B,WAAW,IAAIgC,CAAc,aAAc,KAAM,CAAEhB,QAAS,UAAU,CAAE,CACpH,CAKAgC,OAAK,CACD,OAAO,KAAKvD,KACPwC,IAAoB,KAAKjC,YAAa,CAAEgB,QAAS,UAAU,CAAE,EAC7DC,KAAKC,EAAKC,GAAiC,KAAKvB,gBAAgByC,mCAAmClB,CAAG,CAAC,CAAC,CACjH,CAMA8B,OAAOjB,EAAsB,CACzB,OAAO,KAAKvC,KAAKwD,OAAO,GAAG,KAAKjD,WAAW,IAAIgC,CAAc,GAAI,CAAEhB,QAAS,UAAU,CAAE,CAC5F,CAEAkC,KAAKlB,EAAwBmB,EAAgB,CACzC,OAAO,KAAK1D,KAAKsB,KAAmB,GAAG,KAAKf,WAAW,IAAIgC,CAAc,QAAS,CAAEmB,SAAAA,CAAQ,EAAI,CAAEnC,QAAS,UAAU,CAAE,CAC3H,CAQAoC,WAAWC,EAAgCC,EAAqBxC,EAAiB,CAE7E,IAAMyC,EAA4B,CAAA,EAElCF,EAAezC,QAAS4C,GAAY,EAC5BF,IAAc,IAAQE,EAASJ,cAC/BI,EAASC,sBAAwBC,OACjCF,EAASG,SAAWD,OACpBH,EAAUK,KAAKJ,CAAQ,EAE/B,CAAC,EACGD,EAAUM,SAAW,GAGzB,KAAKC,6BAA6BP,EAAWzC,GAAY,MAAM,CACnE,CAOAgD,6BAA6BP,EAA2BzC,EAAgB,CACpE,IAAMiD,EAAa,IAAIC,EAAAA,QACjBC,EAAuC,CAAA,EACvCC,EAAWC,KAAKC,UAAUb,CAAS,EACnCc,EAAO,IAAIC,KAAK,CAACJ,CAAQ,EAAG,CAAEK,KAAM,kBAAkB,CAAE,EAsB9D,GArBAhB,EAAU3C,QAAQ,CAAC4C,EAAUgB,IAAiB,CAC1C,GAAIhB,EAASe,OAASE,EAAiBC,cAAe,CAClD,GAAKlB,EAAiCmB,mBAAoB,CACtD,IAAMC,EAAYpB,EAAiCmB,mBAC7CE,EAAoBD,EAASE,MAAM,GAAG,EAAEC,KAAI,EAClDd,EAAaL,KAAK,KAAKoB,iBAAiB,IAAIR,CAAa,eAAeK,CAAiB,GAAId,EAAKa,CAAQ,CAAC,CAC/G,CACKpB,EAAiCyB,WACjCzB,EAAiCyB,WAAWrE,QAAQ,CAACsE,EAAUC,IAAc,CAC1E,GAAID,EAASE,gBAAiB,CAC1B,IAAMR,EAAWM,EAASE,gBACpBP,EAAoBD,EAASE,MAAM,GAAG,EAAEC,KAAI,EAClDd,EAAaL,KAAK,KAAKoB,iBAAiB,IAAIR,CAAa,aAAaW,CAAU,IAAIN,CAAiB,GAAId,EAAKa,CAAQ,CAAC,CAC3H,CACJ,CAAC,CAET,CACA,KAAKS,qBAAqBlB,KAAKC,UAAUZ,CAAQ,CAAC,EAAE5C,QAAS0E,GAAiB,CAC1ErB,EAAaL,KAAK,KAAKoB,iBAAiB,IAAIR,CAAa,IAAIc,EAAc,CAAC,CAAC,GAAIvB,EAAKuB,EAAc,CAAC,CAAC,CAAC,CAC3G,CAAC,CACL,CAAC,EACGrB,EAAaJ,SAAW,EAAG,CAC3B0B,EAAalB,GAAOvD,GAAY,QAAU,OAAO,EACjD,MACJ,CACAiD,EAAIlD,MAAMC,GAAY,QAAU,QAASuD,CAAI,EAC7CmB,EAA4BzB,EAAKE,EAAcnD,CAAQ,CAC3D,CAEAuE,qBAAqBI,EAAmB,CAEpC,IAAMC,EAAqB,uBAC3B,MAAO,CAAC,GAAGD,EAAYE,SAASD,CAAkB,CAAC,CACvD,CAQMV,iBAAiBlE,EAAkBiD,EAAYa,EAAgB,QAAAgB,EAAA,sBACjE,OAAO,KAAK9F,YACP+F,QAAQjB,CAAQ,EAChBkB,KAAMC,GAAc,CACjBhC,EAAIlD,KAAKC,EAAUiF,CAAU,CACjC,CAAC,EACAC,MAAOC,GAAS,CACb,MAAM,IAAIC,MAAM,mBAAmBpF,CAAQ,aAAa8D,CAAQ,wBAA0BqB,CAAK,CACnG,CAAC,CACT,GAQAE,UAAUjG,EAA0B,CAChC,OAAKA,EAAakG,YAGdlG,EAAamG,UACNnG,EAAaoG,kBAAoBC,EAAWC,kBAAoBD,EAAWE,OAElFvG,EAAawG,aAAexG,EAAawG,YAAYC,KAAMC,GAAUA,EAAMC,OAAO,EAC3EN,EAAWO,OAEfP,EAAWQ,QARPR,EAAWS,SAS1B,4CAlTSxH,EAAmB,6BAAnBA,EAAmByH,QAAnBzH,EAAmB0H,UAAAC,WADN,MAAM,CAAA,SACnB3H,CAAmB,GAAA",
  "names": ["import_jszip", "QuizExerciseService", "http", "inject", "HttpClient", "exerciseService", "ExerciseService", "fileService", "FileService", "resourceUrl", "create", "quizExercise", "files", "copy", "convertExerciseDatesFromClient", "categories", "stringifyExerciseCategories", "formData", "FormData", "append", "objectToJsonBlob", "forEach", "file", "fileName", "post", "observe", "pipe", "map", "res", "processExerciseEntityResponse", "import", "adaptedSourceQuizExercise", "setBonusPointsConstrainedByIncludedInOverallScore", "id", "update", "req", "options", "createRequestOption", "put", "params", "find", "quizExerciseId", "get", "recalculate", "findForCourse", "courseId", "processExerciseEntityArrayResponse", "findForExam", "examId", "findForStudent", "openForPractice", "start", "end", "setVisible", "startBatch", "quizBatchId", "addBatch", "query", "delete", "join", "password", "exportQuiz", "quizQuestions", "exportAll", "questions", "question", "quizQuestionStatistic", "undefined", "exercise", "push", "length", "exportAssetsFromAllQuestions", "zip", "JSZip", "filePromises", "quizJson", "JSON", "stringify", "blob", "Blob", "type", "questionIndex", "QuizQuestionType", "DRAG_AND_DROP", "backgroundFilePath", "filePath", "fileNameExtension", "split", "last", "fetchFilePromise", "dragItems", "dragItem", "drag_index", "pictureFilePath", "findImagesInMarkdown", "embeddedImage", "downloadFile", "downloadZipFromFilePromises", "description", "embeddedImageRegex", "matchAll", "__async", "getFile", "then", "fileResult", "catch", "error", "Error", "getStatus", "quizStarted", "quizEnded", "isOpenForPractice", "QuizStatus", "OPEN_FOR_PRACTICE", "CLOSED", "quizBatches", "some", "batch", "started", "ACTIVE", "VISIBLE", "INVISIBLE", "factory", "\u0275fac", "providedIn"]
}
