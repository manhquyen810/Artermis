{
  "version": 3,
  "sources": ["src/main/webapp/app/shared/util/global.utils.ts"],
  "sourcesContent": ["import { HttpErrorResponse } from '@angular/common/http';\r\nimport { AlertService, AlertType } from 'app/core/util/alert.service';\r\n\r\n/**\r\n * Prepares a string for insertion into a regex.\r\n * Example: [test].*[/test] -> \\[test\\].*\\[\\/test\\]\r\n * @param text\r\n */\r\nexport const escapeStringForUseInRegex = (text: string) => {\r\n    return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n};\r\n\r\ntype StringPositions = Array<{ start: number; end: number; word: string }>;\r\n/**\r\n * Insert a string that is segmented by a specified delimiter, and a dictionary that provides the\r\n * start and end positions of the segments.\r\n * E.g.: \"word1, word2\" -> [{start: 0, end: 4, word: \"word1\"}, {start: 6, end: 10, word: \"word2\"}]\r\n * @param stringToSegment string which should be provided segment information about\r\n * @param delimiter delimiter by which the string is segmented (e.g. \", \")\r\n * @param result returns a list of StringPositions\r\n */\r\nexport const getStringSegmentPositions = (stringToSegment: string, delimiter: string, result: StringPositions = []): StringPositions => {\r\n    if (stringToSegment === '') {\r\n        return [...result, { start: 0, end: 0, word: '' }];\r\n    }\r\n    const nextComma = stringToSegment.indexOf(delimiter);\r\n    const lastElement = result.last();\r\n    // End condition: the string does not have any more segments.\r\n    if (nextComma === -1) {\r\n        return [\r\n            ...result,\r\n            {\r\n                start: lastElement ? lastElement.end + delimiter.length + 1 : 0,\r\n                end: ((lastElement && lastElement.end + delimiter.length + 1) || 0) + stringToSegment.length - 1,\r\n                word: stringToSegment,\r\n            },\r\n        ];\r\n    }\r\n    const nextWord = stringToSegment.slice(0, nextComma);\r\n    const newResult = [\r\n        ...result,\r\n        {\r\n            start: lastElement ? lastElement.end + delimiter.length + 1 : 0,\r\n            end: ((lastElement && lastElement.end + delimiter.length + 1) || 0) + nextComma - 1,\r\n            word: nextWord,\r\n        },\r\n    ];\r\n    const restString = stringToSegment.slice(nextComma + delimiter.length);\r\n    return getStringSegmentPositions(restString, delimiter, newResult);\r\n};\r\n\r\nexport type RegExpLineNumberMatchArray = Array<[number, string]>;\r\n/**\r\n * Executes a regex on a multi line text (\"text \\n more text\") and returns the [lineNumber of the match, matched object] in a tuple.\r\n * The given regex must have the global flag, otherwise the multiline match will cause an out of memory exception.\r\n *\r\n * @param multiLineText in which to search for matches of the regex.\r\n * @param regex RegExp object.\r\n * @return the matches found in the multiline string.\r\n * @throws Error if a regex is provided without a global flag.\r\n */\r\nexport const matchRegexWithLineNumbers = (multiLineText: string, regex: RegExp): RegExpLineNumberMatchArray => {\r\n    if (!regex.flags.includes('g')) {\r\n        throw new Error('Regex must contain global flag, otherwise this function will run out of memory.');\r\n    }\r\n    const result: RegExpLineNumberMatchArray = [];\r\n    let match = regex.exec(multiLineText);\r\n    while (match) {\r\n        const lineNumber = multiLineText.substring(0, match.index + match[1].length + 1).split('\\n').length - 1;\r\n        result.push([lineNumber, match[1]]);\r\n        match = regex.exec(multiLineText);\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Use alert service to show the error message from the error response\r\n * @param alertService the service used to show the exception messages to the user\r\n * @param error the error response that's status is used to determine the error message\r\n * @param disableTranslation whether the error message should be translated\r\n */\r\nexport const onError = (alertService: AlertService, error: HttpErrorResponse, disableTranslation: boolean = true) => {\r\n    switch (error.status) {\r\n        case 400:\r\n            alertService.error('error.http.400');\r\n            break;\r\n        case 403:\r\n            alertService.error('error.http.403');\r\n            break;\r\n        case 404:\r\n            alertService.error('error.http.404');\r\n            break;\r\n        case 405:\r\n            alertService.error('error.http.405');\r\n            break;\r\n        case 500:\r\n            // Removed to avoid alerts about internal errors as the user can't do anything about it\r\n            // and the alert does not provide any other value\r\n            break;\r\n        default:\r\n            alertService.addAlert({\r\n                type: AlertType.DANGER,\r\n                message: error.message,\r\n                disableTranslation: disableTranslation,\r\n            });\r\n            break;\r\n    }\r\n};\r\n\r\n/**\r\n * Checks if provided value is undefined. Can be used to filter an array:\r\n * [].filter(notUndefined)\r\n *\r\n * @param anyValue\r\n * @return boolean\r\n */\r\nexport const notUndefined = (anyValue: any): boolean => anyValue !== undefined;\r\n"],
  "mappings": "wCAQO,IAAMA,EAA6BC,GAC/BA,EAAKC,QAAQ,sBAAuB,MAAM,EAoD9C,IAAMC,EAA4BA,CAACC,EAAuBC,IAA6C,CAC1G,GAAI,CAACA,EAAMC,MAAMC,SAAS,GAAG,EACzB,MAAM,IAAIC,MAAM,iFAAiF,EAErG,IAAMC,EAAqC,CAAA,EACvCC,EAAQL,EAAMM,KAAKP,CAAa,EACpC,KAAOM,GAAO,CACV,IAAME,EAAaR,EAAcS,UAAU,EAAGH,EAAMI,MAAQJ,EAAM,CAAC,EAAEK,OAAS,CAAC,EAAEC,MAAM;CAAI,EAAED,OAAS,EACtGN,EAAOQ,KAAK,CAACL,EAAYF,EAAM,CAAC,CAAC,CAAC,EAClCA,EAAQL,EAAMM,KAAKP,CAAa,CACpC,CACA,OAAOK,CACX,EAQaS,EAAUA,CAACC,EAA4BC,EAA0BC,EAA8B,KAAQ,CAChH,OAAQD,EAAME,OAAM,CAChB,IAAK,KACDH,EAAaC,MAAM,gBAAgB,EACnC,MACJ,IAAK,KACDD,EAAaC,MAAM,gBAAgB,EACnC,MACJ,IAAK,KACDD,EAAaC,MAAM,gBAAgB,EACnC,MACJ,IAAK,KACDD,EAAaC,MAAM,gBAAgB,EACnC,MACJ,IAAK,KAGD,MACJ,QACID,EAAaI,SAAS,CAClBC,KAAMC,EAAUC,OAChBC,QAASP,EAAMO,QACfN,mBAAoBA,EACvB,EACD,KACR,CACJ,EASaO,EAAgBC,GAA2BA,IAAaC",
  "names": ["escapeStringForUseInRegex", "text", "replace", "matchRegexWithLineNumbers", "multiLineText", "regex", "flags", "includes", "Error", "result", "match", "exec", "lineNumber", "substring", "index", "length", "split", "push", "onError", "alertService", "error", "disableTranslation", "status", "addAlert", "type", "AlertType", "DANGER", "message", "notUndefined", "anyValue", "undefined"]
}
