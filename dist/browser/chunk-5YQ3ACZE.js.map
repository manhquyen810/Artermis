{
  "version": 3,
  "sources": ["src/main/webapp/app/utils/blob-util.ts"],
  "sourcesContent": ["// Note: these utility functions were taken from https://github.com/nolanlawson/blob-util because it was not maintained any more since May 2018\r\n// All functions were converted into the appropriate TypeScript syntax. Unused functions are commented out\r\n// Removed legacy code as Artemis only supports browsers that support the intended functionality\r\n\r\n/**\r\n * Shim for\r\n * [`new Blob()`](https://developer.mozilla.org/en-US/docs/Web/API/Blob.Blob)\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * var myBlob = blobUtil.createBlob(['hello world'], {type: 'text/plain'});\r\n * ```\r\n *\r\n * @param parts - content of the Blob\r\n * @param properties - usually `{type: myContentType}`, you can also pass a string for the content type\r\n * @returns Blob\r\n */\r\nexport function createBlob(parts: BlobPart[], properties?: BlobPropertyBag | string): Blob {\r\n    parts = parts || [];\r\n    properties = properties || {};\r\n    if (typeof properties === 'string') {\r\n        properties = { type: properties }; // infer content type\r\n    }\r\n    return new Blob(parts, properties);\r\n}\r\n\r\n/**\r\n * Convert any object into a blob of a JSON representation of the object.\r\n *\r\n * @param obj - the object to convert to a blob\r\n */\r\nexport function objectToJsonBlob(obj: object) {\r\n    return createBlob([JSON.stringify(obj)], { type: 'application/json' });\r\n}\r\n\r\n/**\r\n * Convert a `Blob` to a binary string.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * blobUtil.blobToBinaryString(blob).then((binaryString) => {\r\n *   // success\r\n * }).catch((err) => {\r\n *   // error\r\n * });\r\n * ```\r\n *\r\n * @param blob\r\n * @returns Promise that resolves with the binary string\r\n */\r\nexport function blobToBinaryString(blob: Blob): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = () => {\r\n            return resolve((reader.result as string) || '');\r\n        };\r\n        reader.onerror = reject;\r\n        reader.readAsBinaryString(blob);\r\n    });\r\n}\r\n\r\n/**\r\n * Convert a base64-encoded string to a `Blob`.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * var blob = blobUtil.base64StringToBlob(base64String);\r\n * ```\r\n * @param base64 - base64-encoded string\r\n * @param type - the content type (optional)\r\n * @returns Blob\r\n */\r\nexport function base64StringToBlob(base64: string, type?: string): Blob {\r\n    const parts = [binaryStringToArrayBuffer(window.atob(base64))];\r\n    return type ? createBlob(parts, { type }) : createBlob(parts);\r\n}\r\n\r\n/**\r\n * Convert a `Blob` to a binary string.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * blobUtil.blobToBase64String(blob).then((base64String) => {\r\n *   // success\r\n * }).catch((err) => {\r\n *   // error\r\n * });\r\n * ```\r\n *\r\n * @param blob\r\n * @returns Promise that resolves with the binary string\r\n */\r\nexport function blobToBase64String(blob: Blob): Promise<string> {\r\n    return blobToBinaryString(blob).then((binaryString) => window.btoa(binaryString));\r\n}\r\n\r\n/**\r\n * Convert an `ArrayBuffer` to a binary string.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\r\n * ```\r\n *\r\n * @param buffer - array buffer\r\n * @returns binary string\r\n */\r\nexport function arrayBufferToBinaryString(buffer: ArrayBuffer): string {\r\n    let binary = '';\r\n    const bytes = new Uint8Array(buffer);\r\n    const length = bytes.byteLength;\r\n    let i = -1;\r\n    while (++i < length) {\r\n        binary += String.fromCharCode(bytes[i]);\r\n    }\r\n    return binary;\r\n}\r\n\r\n/**\r\n * Convert a binary string to an `ArrayBuffer`.\r\n *\r\n * ```js\r\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\r\n * ```\r\n *\r\n * @param binary - binary string\r\n * @returns array buffer\r\n */\r\nexport function binaryStringToArrayBuffer(binary: string): ArrayBuffer {\r\n    const length = binary.length;\r\n    const buf = new ArrayBuffer(length);\r\n    const arr = new Uint8Array(buf);\r\n    let i = -1;\r\n    while (++i < length) {\r\n        arr[i] = binary.charCodeAt(i);\r\n    }\r\n    return buf;\r\n}\r\n"],
  "mappings": "AAkBM,SAAUA,EAAWC,EAAmBC,EAAqC,CAC/ED,OAAAA,EAAQA,GAAS,CAAA,EACjBC,EAAaA,GAAc,CAAA,EACvB,OAAOA,GAAe,WACtBA,EAAa,CAAEC,KAAMD,CAAU,GAE5B,IAAIE,KAAKH,EAAOC,CAAU,CACrC,CAOM,SAAUG,EAAiBC,EAAW,CACxC,OAAON,EAAW,CAACO,KAAKC,UAAUF,CAAG,CAAC,EAAG,CAAEH,KAAM,kBAAkB,CAAE,CACzE,CAkBM,SAAUM,EAAmBC,EAAU,CACzC,OAAO,IAAIC,QAAQ,CAACC,EAASC,IAAU,CACnC,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,UAAY,IACRJ,EAASE,EAAOG,QAAqB,EAAE,EAElDH,EAAOI,QAAUL,EACjBC,EAAOK,mBAAmBT,CAAI,CAClC,CAAC,CACL,CAcM,SAAUU,EAAmBC,EAAgBlB,EAAa,CAC5D,IAAMF,EAAQ,CAACqB,EAA0BC,OAAOC,KAAKH,CAAM,CAAC,CAAC,EAC7D,OAAOlB,EAAOH,EAAWC,EAAO,CAAEE,KAAAA,CAAI,CAAE,EAAIH,EAAWC,CAAK,CAChE,CAkBM,SAAUwB,EAAmBf,EAAU,CACzC,OAAOD,EAAmBC,CAAI,EAAEgB,KAAMC,GAAiBJ,OAAOK,KAAKD,CAAY,CAAC,CACpF,CAmCM,SAAUE,EAA0BC,EAAc,CACpD,IAAMC,EAASD,EAAOC,OAChBC,EAAM,IAAIC,YAAYF,CAAM,EAC5BG,EAAM,IAAIC,WAAWH,CAAG,EAC1BI,EAAI,GACR,KAAO,EAAEA,EAAIL,GACTG,EAAIE,CAAC,EAAIN,EAAOO,WAAWD,CAAC,EAEhC,OAAOJ,CACX",
  "names": ["createBlob", "parts", "properties", "type", "Blob", "objectToJsonBlob", "obj", "JSON", "stringify", "blobToBinaryString", "blob", "Promise", "resolve", "reject", "reader", "FileReader", "onloadend", "result", "onerror", "readAsBinaryString", "base64StringToBlob", "base64", "binaryStringToArrayBuffer", "window", "atob", "blobToBase64String", "then", "binaryString", "btoa", "binaryStringToArrayBuffer", "binary", "length", "buf", "ArrayBuffer", "arr", "Uint8Array", "i", "charCodeAt"]
}
