{"version":3,"sources":["src/main/webapp/app/entities/competency/standardized-competency.model.ts","node_modules/@angular/cdk/fesm2022/tree.mjs","node_modules/@angular/material/fesm2022/tree.mjs","src/main/webapp/app/shared/standardized-competencies/knowledge-area-tree.component.ts","src/main/webapp/app/shared/standardized-competencies/knowledge-area-tree.component.html"],"sourcesContent":["import { CompetencyTaxonomy, CourseCompetency } from 'app/entities/competency.model';\r\nimport { BaseEntity } from 'app/shared/model/base-entity';\r\nimport { BaseCompetency } from 'app/entities/competency.model';\r\n\r\nexport interface StandardizedCompetency extends BaseCompetency {\r\n    version?: string;\r\n    knowledgeArea?: KnowledgeArea;\r\n    source?: Source;\r\n    firstVersion?: StandardizedCompetency;\r\n    childVersions?: StandardizedCompetency[];\r\n    linkedCompetencies?: CourseCompetency[];\r\n}\r\n\r\nexport interface StandardizedCompetencyDTO extends BaseEntity {\r\n    title?: string;\r\n    description?: string;\r\n    taxonomy?: CompetencyTaxonomy;\r\n    version?: string;\r\n    knowledgeAreaId?: number;\r\n    sourceId?: number;\r\n}\r\n\r\nexport interface KnowledgeArea extends BaseEntity {\r\n    title?: string;\r\n    shortTitle?: string;\r\n    description?: string;\r\n    parent?: KnowledgeArea;\r\n    children?: KnowledgeArea[];\r\n    competencies?: StandardizedCompetency[];\r\n}\r\n\r\nexport interface KnowledgeAreaDTO extends BaseEntity {\r\n    title?: string;\r\n    shortTitle?: string;\r\n    description?: string;\r\n    parentId?: number;\r\n    children?: KnowledgeAreaDTO[];\r\n    competencies?: StandardizedCompetencyDTO[];\r\n}\r\n\r\nexport interface Source extends BaseEntity {\r\n    title?: string;\r\n    author?: string;\r\n    uri?: string;\r\n    competencies?: StandardizedCompetency[];\r\n}\r\n\r\nexport enum StandardizedCompetencyValidators {\r\n    TITLE_MAX = 255,\r\n    DESCRIPTION_MAX = 2000,\r\n}\r\n\r\nexport enum KnowledgeAreaValidators {\r\n    TITLE_MAX = 255,\r\n    SHORT_TITLE_MAX = 10,\r\n    DESCRIPTION_MAX = 2000,\r\n}\r\n\r\n/**\r\n * KnowledgeAreaDTO with additional information for the tree view:\r\n * isVisible: if it should be shown or not (used for filters)\r\n * level: nesting level (used for indentations)\r\n */\r\nexport interface KnowledgeAreaForTree extends KnowledgeAreaDTO {\r\n    isVisible: boolean;\r\n    level: number;\r\n    children?: KnowledgeAreaForTree[];\r\n    competencies?: StandardizedCompetencyForTree[];\r\n}\r\n\r\nexport interface KnowledgeAreasForImportDTO {\r\n    knowledgeAreas: KnowledgeAreaDTO[];\r\n    sources: Source[];\r\n}\r\n\r\n/**\r\n * StandardizedCompetencyDTO with additional information for the tree view\r\n * isVisible: if it should be shown or not (used for filters)\r\n */\r\nexport interface StandardizedCompetencyForTree extends StandardizedCompetencyDTO {\r\n    isVisible: boolean;\r\n}\r\n\r\nexport function sourceToString(source: Source) {\r\n    const author = source.author ?? '';\r\n    const title = source.title ?? '';\r\n    const uri = source.uri ?? '';\r\n\r\n    if (!author) {\r\n        return `\"${title}\". ${uri}`;\r\n    } else {\r\n        return `${author}. \"${title}\". ${uri}`;\r\n    }\r\n}\r\n\r\nexport function convertToStandardizedCompetencyForTree(competencyDTO: StandardizedCompetencyDTO, isVisible: boolean) {\r\n    const competencyForTree: StandardizedCompetencyForTree = { ...competencyDTO, isVisible: isVisible };\r\n    return competencyForTree;\r\n}\r\n\r\nexport function convertToKnowledgeAreaForTree(knowledgeAreaDTO: KnowledgeAreaDTO, isVisible = true, level = 0): KnowledgeAreaForTree {\r\n    const children = knowledgeAreaDTO.children?.map((child) => convertToKnowledgeAreaForTree(child, isVisible, level + 1));\r\n    const competencies = knowledgeAreaDTO.competencies?.map((competency) => convertToStandardizedCompetencyForTree(competency, isVisible));\r\n    return { ...knowledgeAreaDTO, children: children, competencies: competencies, level: level, isVisible: isVisible };\r\n}\r\n","import { SelectionModel, isDataSource } from '@angular/cdk/collections';\nimport { isObservable, Subject, BehaviorSubject, of, combineLatest, EMPTY, concat } from 'rxjs';\nimport { take, filter, takeUntil, startWith, tap, switchMap, map, reduce, concatMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ViewContainerRef, Directive, TemplateRef, IterableDiffers, ChangeDetectorRef, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, ContentChildren, EventEmitter, booleanAttribute, Output, numberAttribute, NgModule } from '@angular/core';\nimport { TREE_KEY_MANAGER } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceObservable } from '@angular/cdk/coercion/private';\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nclass BaseTreeControl {\n  /** Saved data node for `expandAll` action. */\n  dataNodes;\n  /** A selection model with multi-selection to track expansion status. */\n  expansionModel = /*#__PURE__*/new SelectionModel(true);\n  /**\n   * Returns the identifier by which a dataNode should be tracked, should its\n   * reference change.\n   *\n   * Similar to trackBy for *ngFor\n   */\n  trackBy;\n  /** Get depth of a given data node, return the level number. This is for flat tree node. */\n  getLevel;\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   */\n  isExpandable;\n  /** Gets a stream that emits whenever the given data node's children change. */\n  getChildren;\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(dataNode) {\n    this.expansionModel.toggle(this._trackByValue(dataNode));\n  }\n  /** Expands one single data node. */\n  expand(dataNode) {\n    this.expansionModel.select(this._trackByValue(dataNode));\n  }\n  /** Collapses one single data node. */\n  collapse(dataNode) {\n    this.expansionModel.deselect(this._trackByValue(dataNode));\n  }\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(dataNode) {\n    return this.expansionModel.isSelected(this._trackByValue(dataNode));\n  }\n  /** Toggles a subtree rooted at `node` recursively. */\n  toggleDescendants(dataNode) {\n    this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);\n  }\n  /** Collapse all dataNodes in the tree. */\n  collapseAll() {\n    this.expansionModel.clear();\n  }\n  /** Expands a subtree rooted at given data node recursively. */\n  expandDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  /** Collapses a subtree rooted at given data node recursively. */\n  collapseDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  _trackByValue(value) {\n    return this.trackBy ? this.trackBy(value) : value;\n  }\n}\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass FlatTreeControl extends BaseTreeControl {\n  getLevel;\n  isExpandable;\n  options;\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(getLevel, isExpandable, options) {\n    super();\n    this.getLevel = getLevel;\n    this.isExpandable = isExpandable;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n  }\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode) {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results = [];\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n  }\n}\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass NestedTreeControl extends BaseTreeControl {\n  getChildren;\n  options;\n  /** Construct with nested tree function getChildren. */\n  constructor(getChildren, options) {\n    super();\n    this.getChildren = getChildren;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n    if (this.options?.isExpandable) {\n      this.isExpandable = this.options.isExpandable;\n    }\n  }\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce((accumulator, dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n    this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n  }\n  /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n  getDescendants(dataNode) {\n    const descendants = [];\n    this._getDescendants(descendants, dataNode);\n    // Remove the node itself\n    return descendants.splice(1);\n  }\n  /** A helper function to get descendants recursively. */\n  _getDescendants(descendants, dataNode) {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach(child => this._getDescendants(descendants, child));\n    } else if (isObservable(childrenNodes)) {\n      // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n      // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n      childrenNodes.pipe(take(1), filter(Boolean)).subscribe(children => {\n        for (const child of children) {\n          this._getDescendants(descendants, child);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst CDK_TREE_NODE_OUTLET_NODE = /*#__PURE__*/new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nlet CdkTreeNodeOutlet = /*#__PURE__*/(() => {\n  class CdkTreeNodeOutlet {\n    viewContainer = inject(ViewContainerRef);\n    _node = inject(CDK_TREE_NODE_OUTLET_NODE, {\n      optional: true\n    });\n    constructor() {}\n    static ɵfac = function CdkTreeNodeOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeOutlet,\n      selectors: [[\"\", \"cdkTreeNodeOutlet\", \"\"]]\n    });\n  }\n  return CdkTreeNodeOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Context provided to the tree node component. */\nclass CdkTreeNodeOutletContext {\n  /** Data for the node. */\n  $implicit;\n  /** Depth of the node. */\n  level;\n  /** Index location of the node. */\n  index;\n  /** Length of the number of total dataNodes. */\n  count;\n  constructor(data) {\n    this.$implicit = data;\n  }\n}\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nlet CdkTreeNodeDef = /*#__PURE__*/(() => {\n  class CdkTreeNodeDef {\n    /** @docs-private */\n    template = inject(TemplateRef);\n    /**\n     * Function that should return true if this node template should be used for the provided node\n     * data and index. If left undefined, this node will be considered the default node template to\n     * use when no other when functions return true for the data.\n     * For every node, there must be at least one when function that passes or an undefined to\n     * default.\n     */\n    when;\n    constructor() {}\n    static ɵfac = function CdkTreeNodeDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeDef)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeDef,\n      selectors: [[\"\", \"cdkTreeNodeDef\", \"\"]],\n      inputs: {\n        when: [0, \"cdkTreeNodeDefWhen\", \"when\"]\n      }\n    });\n  }\n  return CdkTreeNodeDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nfunction getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nfunction getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nfunction getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\n/**\n * Returns an error to be thrown when there is no tree control.\n * @docs-private\n */\nfunction getTreeControlMissingError() {\n  return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\n/**\n * Returns an error to be thrown when there are multiple ways of specifying children or level\n * provided to the tree.\n * @docs-private\n */\nfunction getMultipleTreeControlsError() {\n  return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\nlet CdkTree = /*#__PURE__*/(() => {\n  class CdkTree {\n    _differs = inject(IterableDiffers);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality);\n    /** Subject that emits when the component has been destroyed. */\n    _onDestroy = new Subject();\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** Stores the node definition that does not have a when predicate. */\n    _defaultNodeDef;\n    /** Data subscription */\n    _dataSubscription;\n    /** Level of nodes */\n    _levels = new Map();\n    /** The immediate parents for a node. This is `null` if there is no parent. */\n    _parents = new Map();\n    /**\n     * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.\n     *\n     * Lookup key is the parent of a set. Root nodes have key of null.\n     *\n     * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the\n     * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.\n     */\n    _ariaSets = new Map();\n    /**\n     * Provides a stream containing the latest data array to render. Influenced by the tree's\n     * stream of view window (what dataNodes are currently on screen).\n     * Data source can be an observable of data array, or a data array to render.\n     */\n    get dataSource() {\n      return this._dataSource;\n    }\n    set dataSource(dataSource) {\n      if (this._dataSource !== dataSource) {\n        this._switchDataSource(dataSource);\n      }\n    }\n    _dataSource;\n    /**\n     * The tree controller\n     *\n     * @deprecated Use one of `levelAccessor` or `childrenAccessor` instead. To be removed in a\n     * future version.\n     * @breaking-change 21.0.0\n     */\n    treeControl;\n    /**\n     * Given a data node, determines what tree level the node is at.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    levelAccessor;\n    /**\n     * Given a data node, determines what the children of that node are.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    childrenAccessor;\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n     * relative to the function to know if a node should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    trackBy;\n    /**\n     * Given a data node, determines the key by which we determine whether or not this node is expanded.\n     */\n    expansionKey;\n    // Outlets within the tree's template where the dataNodes will be inserted.\n    _nodeOutlet;\n    /** The tree node template for the tree */\n    _nodeDefs;\n    // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n    //     Remove the MAX_VALUE in viewChange\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n    viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n    /** Keep track of which nodes are expanded. */\n    _expansionModel;\n    /**\n     * Maintain a synchronous cache of flattened data nodes. This will only be\n     * populated after initial render, and in certain cases, will be delayed due to\n     * relying on Observable `getChildren` calls.\n     */\n    _flattenedNodes = new BehaviorSubject([]);\n    /** The automatically determined node type for the tree. */\n    _nodeType = new BehaviorSubject(null);\n    /** The mapping between data and the node that is rendered. */\n    _nodes = new BehaviorSubject(new Map());\n    /**\n     * Synchronous cache of nodes for the `TreeKeyManager`. This is separate\n     * from `_flattenedNodes` so they can be independently updated at different\n     * times.\n     */\n    _keyManagerNodes = new BehaviorSubject([]);\n    _keyManagerFactory = inject(TREE_KEY_MANAGER);\n    /** The key manager for this tree. Handles focus and activation based on user keyboard input. */\n    _keyManager;\n    _viewInit = false;\n    constructor() {}\n    ngAfterContentInit() {\n      this._initializeKeyManager();\n    }\n    ngAfterContentChecked() {\n      this._updateDefaultNodeDefinition();\n      this._subscribeToDataChanges();\n    }\n    ngOnDestroy() {\n      this._nodeOutlet.viewContainer.clear();\n      this.viewChange.complete();\n      this._onDestroy.next();\n      this._onDestroy.complete();\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      // In certain tests, the tree might be destroyed before this is initialized\n      // in `ngAfterContentInit`.\n      this._keyManager?.destroy();\n    }\n    ngOnInit() {\n      this._checkTreeControlUsage();\n      this._initializeDataDiffer();\n    }\n    ngAfterViewInit() {\n      this._viewInit = true;\n    }\n    _updateDefaultNodeDefinition() {\n      const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n      if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMultipleDefaultNodeDefsError();\n      }\n      this._defaultNodeDef = defaultNodeDefs[0];\n    }\n    /**\n     * Sets the node type for the tree, if it hasn't been set yet.\n     *\n     * This will be called by the first node that's rendered in order for the tree\n     * to determine what data transformations are required.\n     */\n    _setNodeTypeIfUnset(newType) {\n      const currentType = this._nodeType.value;\n      if (currentType === null) {\n        this._nodeType.next(newType);\n      } else if ((typeof ngDevMode === 'undefined' || ngDevMode) && currentType !== newType) {\n        console.warn(`Tree is using conflicting node types which can cause unexpected behavior. ` + `Please use tree nodes of the same type (e.g. only flat or only nested). ` + `Current node type: \"${currentType}\", new node type \"${newType}\".`);\n      }\n    }\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     */\n    _switchDataSource(dataSource) {\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      // Remove the all dataNodes if there is now no data source\n      if (!dataSource) {\n        this._nodeOutlet.viewContainer.clear();\n      }\n      this._dataSource = dataSource;\n      if (this._nodeDefs) {\n        this._subscribeToDataChanges();\n      }\n    }\n    _getExpansionModel() {\n      if (!this.treeControl) {\n        this._expansionModel ??= new SelectionModel(true);\n        return this._expansionModel;\n      }\n      return this.treeControl.expansionModel;\n    }\n    /** Set up a subscription for the data provided by the data source. */\n    _subscribeToDataChanges() {\n      if (this._dataSubscription) {\n        return;\n      }\n      let dataStream;\n      if (isDataSource(this._dataSource)) {\n        dataStream = this._dataSource.connect(this);\n      } else if (isObservable(this._dataSource)) {\n        dataStream = this._dataSource;\n      } else if (Array.isArray(this._dataSource)) {\n        dataStream = of(this._dataSource);\n      }\n      if (!dataStream) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          throw getTreeNoValidDataSourceError();\n        }\n        return;\n      }\n      this._dataSubscription = this._getRenderData(dataStream).pipe(takeUntil(this._onDestroy)).subscribe(renderingData => {\n        this._renderDataChanges(renderingData);\n      });\n    }\n    /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */\n    _getRenderData(dataStream) {\n      const expansionModel = this._getExpansionModel();\n      return combineLatest([dataStream, this._nodeType,\n      // We don't use the expansion data directly, however we add it here to essentially\n      // trigger data rendering when expansion changes occur.\n      expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {\n        this._emitExpansionChanges(expansionChanges);\n      }))]).pipe(switchMap(([data, nodeType]) => {\n        if (nodeType === null) {\n          return of({\n            renderNodes: data,\n            flattenedNodes: null,\n            nodeType\n          });\n        }\n        // If we're here, then we know what our node type is, and therefore can\n        // perform our usual rendering pipeline, which necessitates converting the data\n        return this._computeRenderingData(data, nodeType).pipe(map(convertedData => ({\n          ...convertedData,\n          nodeType\n        })));\n      }));\n    }\n    _renderDataChanges(data) {\n      if (data.nodeType === null) {\n        this.renderNodeChanges(data.renderNodes);\n        return;\n      }\n      // If we're here, then we know what our node type is, and therefore can\n      // perform our usual rendering pipeline.\n      this._updateCachedData(data.flattenedNodes);\n      this.renderNodeChanges(data.renderNodes);\n      this._updateKeyManagerItems(data.flattenedNodes);\n    }\n    _emitExpansionChanges(expansionChanges) {\n      if (!expansionChanges) {\n        return;\n      }\n      const nodes = this._nodes.value;\n      for (const added of expansionChanges.added) {\n        const node = nodes.get(added);\n        node?._emitExpansionState(true);\n      }\n      for (const removed of expansionChanges.removed) {\n        const node = nodes.get(removed);\n        node?._emitExpansionState(false);\n      }\n    }\n    _initializeKeyManager() {\n      const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items, data) => {\n        const node = renderNodes.get(this._getExpansionKey(data));\n        if (node) {\n          items.push(node);\n        }\n        return items;\n      }, [])));\n      const keyManagerOptions = {\n        trackBy: node => this._getExpansionKey(node.data),\n        skipPredicate: node => !!node.isDisabled,\n        typeAheadDebounceInterval: true,\n        horizontalOrientation: this._dir.value\n      };\n      this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n    }\n    _initializeDataDiffer() {\n      // Provide a default trackBy based on `_getExpansionKey` if one isn't provided.\n      const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));\n      this._dataDiffer = this._differs.find([]).create(trackBy);\n    }\n    _checkTreeControlUsage() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Verify that Tree follows API contract of using one of TreeControl, levelAccessor or\n        // childrenAccessor. Throw an appropriate error if contract is not met.\n        let numTreeControls = 0;\n        if (this.treeControl) {\n          numTreeControls++;\n        }\n        if (this.levelAccessor) {\n          numTreeControls++;\n        }\n        if (this.childrenAccessor) {\n          numTreeControls++;\n        }\n        if (!numTreeControls) {\n          throw getTreeControlMissingError();\n        } else if (numTreeControls > 1) {\n          throw getMultipleTreeControlsError();\n        }\n      }\n    }\n    /** Check for changes made in the data and render each change (node added/removed/moved). */\n    renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {\n      const changes = dataDiffer.diff(data);\n      // Some tree consumers expect change detection to propagate to nodes\n      // even when the array itself hasn't changed; we explicitly detect changes\n      // anyways in order for nodes to update their data.\n      //\n      // However, if change detection is called while the component's view is\n      // still initing, then the order of child views initing will be incorrect;\n      // to prevent this, we only exit early if the view hasn't initialized yet.\n      if (!changes && !this._viewInit) {\n        return;\n      }\n      changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n        if (item.previousIndex == null) {\n          this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex);\n          viewContainer.move(view, currentIndex);\n        }\n      });\n      // If the data itself changes, but keeps the same trackBy, we need to update the templates'\n      // context to reflect the new object.\n      changes?.forEachIdentityChange(record => {\n        const newData = record.item;\n        if (record.currentIndex != undefined) {\n          const view = viewContainer.get(record.currentIndex);\n          view.context.$implicit = newData;\n        }\n      });\n      // Note: we only `detectChanges` from a top-level call, otherwise we risk overflowing\n      // the call stack since this method is called recursively (see #29733.)\n      // TODO: change to `this._changeDetectorRef.markForCheck()`,\n      // or just switch this component to use signals.\n      if (parentData) {\n        this._changeDetectorRef.markForCheck();\n      } else {\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     */\n    _getNodeDef(data, i) {\n      if (this._nodeDefs.length === 1) {\n        return this._nodeDefs.first;\n      }\n      const nodeDef = this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n      if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMissingMatchingNodeDefError();\n      }\n      return nodeDef;\n    }\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     */\n    insertNode(nodeData, index, viewContainer, parentData) {\n      const levelAccessor = this._getLevelAccessor();\n      const node = this._getNodeDef(nodeData, index);\n      const key = this._getExpansionKey(nodeData);\n      // Node context that will be provided to created embedded view\n      const context = new CdkTreeNodeOutletContext(nodeData);\n      parentData ??= this._parents.get(key) ?? undefined;\n      // If the tree is flat tree, then use the `getLevel` function in flat tree control\n      // Otherwise, use the level of parent node.\n      if (levelAccessor) {\n        context.level = levelAccessor(nodeData);\n      } else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n        context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;\n      } else {\n        context.level = 0;\n      }\n      this._levels.set(key, context.level);\n      // Use default tree nodeOutlet, or nested node's nodeOutlet\n      const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n      container.createEmbeddedView(node.template, context, index);\n      // Set the data to just created `CdkTreeNode`.\n      // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n      //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n      if (CdkTreeNode.mostRecentTreeNode) {\n        CdkTreeNode.mostRecentTreeNode.data = nodeData;\n      }\n    }\n    /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */\n    isExpanded(dataNode) {\n      return !!(this.treeControl?.isExpanded(dataNode) || this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));\n    }\n    /** If the data node is currently expanded, collapse it. Otherwise, expand it. */\n    toggle(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggle(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.toggle(this._getExpansionKey(dataNode));\n      }\n    }\n    /** Expand the data node. If it is already expanded, does nothing. */\n    expand(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expand(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.select(this._getExpansionKey(dataNode));\n      }\n    }\n    /** Collapse the data node. If it is already collapsed, does nothing. */\n    collapse(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapse(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.deselect(this._getExpansionKey(dataNode));\n      }\n    }\n    /**\n     * If the data node is currently expanded, collapse it and all its descendants.\n     * Otherwise, expand it and all its descendants.\n     */\n    toggleDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggleDescendants(dataNode);\n      } else if (this._expansionModel) {\n        if (this.isExpanded(dataNode)) {\n          this.collapseDescendants(dataNode);\n        } else {\n          this.expandDescendants(dataNode);\n        }\n      }\n    }\n    /**\n     * Expand the data node and all its descendants. If they are already expanded, does nothing.\n     */\n    expandDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expandDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.select(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */\n    collapseDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapseDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.deselect(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    /** Expands all data nodes in the tree. */\n    expandAll() {\n      if (this.treeControl) {\n        this.treeControl.expandAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.select(...keys));\n      }\n    }\n    /** Collapse all data nodes in the tree. */\n    collapseAll() {\n      if (this.treeControl) {\n        this.treeControl.collapseAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.deselect(...keys));\n      }\n    }\n    /** Level accessor, used for compatibility between the old Tree and new Tree */\n    _getLevelAccessor() {\n      return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n    }\n    /** Children accessor, used for compatibility between the old Tree and new Tree */\n    _getChildrenAccessor() {\n      return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n    }\n    /**\n     * Gets the direct children of a node; used for compatibility between the old tree and the\n     * new tree.\n     */\n    _getDirectChildren(dataNode) {\n      const levelAccessor = this._getLevelAccessor();\n      const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n      if (!expansionModel) {\n        return of([]);\n      }\n      const key = this._getExpansionKey(dataNode);\n      const isExpanded = expansionModel.changed.pipe(switchMap(changes => {\n        if (changes.added.includes(key)) {\n          return of(true);\n        } else if (changes.removed.includes(key)) {\n          return of(false);\n        }\n        return EMPTY;\n      }), startWith(this.isExpanded(dataNode)));\n      if (levelAccessor) {\n        return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {\n          if (!expanded) {\n            return [];\n          }\n          return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n        }));\n      }\n      const childrenAccessor = this._getChildrenAccessor();\n      if (childrenAccessor) {\n        return coerceObservable(childrenAccessor(dataNode) ?? []);\n      }\n      throw getTreeControlMissingError();\n    }\n    /**\n     * Given the list of flattened nodes, the level accessor, and the level range within\n     * which to consider children, finds the children for a given node.\n     *\n     * For example, for direct children, `levelDelta` would be 1. For all descendants,\n     * `levelDelta` would be Infinity.\n     */\n    _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {\n      const key = this._getExpansionKey(dataNode);\n      const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n      const dataNodeLevel = levelAccessor(dataNode);\n      const expectedLevel = dataNodeLevel + levelDelta;\n      const results = [];\n      // Goes through flattened tree nodes in the `flattenedNodes` array, and get all\n      // descendants within a certain level range.\n      //\n      // If we reach a node whose level is equal to or less than the level of the tree node,\n      // we hit a sibling or parent's sibling, and should stop.\n      for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n        const currentLevel = levelAccessor(flattenedNodes[i]);\n        if (currentLevel <= dataNodeLevel) {\n          break;\n        }\n        if (currentLevel <= expectedLevel) {\n          results.push(flattenedNodes[i]);\n        }\n      }\n      return results;\n    }\n    /**\n     * Adds the specified node component to the tree's internal registry.\n     *\n     * This primarily facilitates keyboard navigation.\n     */\n    _registerNode(node) {\n      this._nodes.value.set(this._getExpansionKey(node.data), node);\n      this._nodes.next(this._nodes.value);\n    }\n    /** Removes the specified node component from the tree's internal registry. */\n    _unregisterNode(node) {\n      this._nodes.value.delete(this._getExpansionKey(node.data));\n      this._nodes.next(this._nodes.value);\n    }\n    /**\n     * For the given node, determine the level where this node appears in the tree.\n     *\n     * This is intended to be used for `aria-level` but is 0-indexed.\n     */\n    _getLevel(node) {\n      return this._levels.get(this._getExpansionKey(node));\n    }\n    /**\n     * For the given node, determine the size of the parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      return set.length;\n    }\n    /**\n     * For the given node, determine the index (starting from 1) of the node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      const key = this._getExpansionKey(dataNode);\n      return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n    }\n    /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */\n    _getNodeParent(node) {\n      const parent = this._parents.get(this._getExpansionKey(node.data));\n      return parent && this._nodes.value.get(this._getExpansionKey(parent));\n    }\n    /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */\n    _getNodeChildren(node) {\n      return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {\n        const value = this._nodes.value.get(this._getExpansionKey(child));\n        if (value) {\n          nodes.push(value);\n        }\n        return nodes;\n      }, [])));\n    }\n    /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */\n    _sendKeydownToKeyManager(event) {\n      // Only handle events directly on the tree or directly on one of the nodes, otherwise\n      // we risk interfering with events in the projected content (see #29828).\n      if (event.target === this._elementRef.nativeElement) {\n        this._keyManager.onKeydown(event);\n      } else {\n        const nodes = this._nodes.getValue();\n        for (const [, node] of nodes) {\n          if (event.target === node._elementRef.nativeElement) {\n            this._keyManager.onKeydown(event);\n            break;\n          }\n        }\n      }\n    }\n    /** Gets all nested descendants of a given node. */\n    _getDescendants(dataNode) {\n      if (this.treeControl) {\n        return of(this.treeControl.getDescendants(dataNode));\n      }\n      if (this.levelAccessor) {\n        const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);\n        return of(results);\n      }\n      if (this.childrenAccessor) {\n        return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {\n          allChildren.push(...nextChildren);\n          return allChildren;\n        }, []));\n      }\n      throw getTreeControlMissingError();\n    }\n    /**\n     * Gets all children and sub-children of the provided node.\n     *\n     * This will emit multiple times, in the order that the children will appear\n     * in the tree, and can be combined with a `reduce` operator.\n     */\n    _getAllChildrenRecursively(dataNode) {\n      if (!this.childrenAccessor) {\n        return of([]);\n      }\n      return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {\n        // Here, we cache the parents of a particular child so that we can compute the levels.\n        for (const child of children) {\n          this._parents.set(this._getExpansionKey(child), dataNode);\n        }\n        return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));\n      }));\n    }\n    _getExpansionKey(dataNode) {\n      // In the case that a key accessor function was not provided by the\n      // tree user, we'll default to using the node object itself as the key.\n      //\n      // This cast is safe since:\n      // - if an expansionKey is provided, TS will infer the type of K to be\n      //   the return type.\n      // - if it's not, then K will be defaulted to T.\n      return this.expansionKey?.(dataNode) ?? dataNode;\n    }\n    _getAriaSet(node) {\n      const key = this._getExpansionKey(node);\n      const parent = this._parents.get(key);\n      const parentKey = parent ? this._getExpansionKey(parent) : null;\n      const set = this._ariaSets.get(parentKey);\n      return set ?? [node];\n    }\n    /**\n     * Finds the parent for the given node. If this is a root node, this\n     * returns null. If we're unable to determine the parent, for example,\n     * if we don't have cached node data, this returns undefined.\n     */\n    _findParentForNode(node, index, cachedNodes) {\n      // In all cases, we have a mapping from node to level; all we need to do here is backtrack in\n      // our flattened list of nodes to determine the first node that's of a level lower than the\n      // provided node.\n      if (!cachedNodes.length) {\n        return null;\n      }\n      const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n      for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n        const parentNode = cachedNodes[parentIndex];\n        const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n        if (parentLevel < currentLevel) {\n          return parentNode;\n        }\n      }\n      return null;\n    }\n    /**\n     * Given a set of root nodes and the current node level, flattens any nested\n     * nodes into a single array.\n     *\n     * If any nodes are not expanded, then their children will not be added into the array.\n     * This will still traverse all nested children in order to build up our internal data\n     * models, but will not include them in the returned array.\n     */\n    _flattenNestedNodesWithExpansion(nodes, level = 0) {\n      const childrenAccessor = this._getChildrenAccessor();\n      // If we're using a level accessor, we don't need to flatten anything.\n      if (!childrenAccessor) {\n        return of([...nodes]);\n      }\n      return of(...nodes).pipe(concatMap(node => {\n        const parentKey = this._getExpansionKey(node);\n        if (!this._parents.has(parentKey)) {\n          this._parents.set(parentKey, null);\n        }\n        this._levels.set(parentKey, level);\n        const children = coerceObservable(childrenAccessor(node));\n        return concat(of([node]), children.pipe(take(1), tap(childNodes => {\n          this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n          for (const child of childNodes ?? []) {\n            const childKey = this._getExpansionKey(child);\n            this._parents.set(childKey, node);\n            this._levels.set(childKey, level + 1);\n          }\n        }), switchMap(childNodes => {\n          if (!childNodes) {\n            return of([]);\n          }\n          return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => this.isExpanded(node) ? nestedNodes : []));\n        })));\n      }), reduce((results, children) => {\n        results.push(...children);\n        return results;\n      }, []));\n    }\n    /**\n     * Converts children for certain tree configurations.\n     *\n     * This also computes parent, level, and group data.\n     */\n    _computeRenderingData(nodes, nodeType) {\n      // The only situations where we have to convert children types is when\n      // they're mismatched; i.e. if the tree is using a childrenAccessor and the\n      // nodes are flat, or if the tree is using a levelAccessor and the nodes are\n      // nested.\n      if (this.childrenAccessor && nodeType === 'flat') {\n        // This flattens children into a single array.\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: flattenedNodes,\n          flattenedNodes\n        })));\n      } else if (this.levelAccessor && nodeType === 'nested') {\n        // In the nested case, we only look for root nodes. The CdkNestedNode\n        // itself will handle rendering each individual node's children.\n        const levelAccessor = this.levelAccessor;\n        return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({\n          renderNodes: rootNodes,\n          flattenedNodes: nodes\n        })), tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else if (nodeType === 'flat') {\n        // In the case of a TreeControl, we know that the node type matches up\n        // with the TreeControl, and so no conversions are necessary. Otherwise,\n        // we've already confirmed that the data model matches up with the\n        // desired node type here.\n        return of({\n          renderNodes: nodes,\n          flattenedNodes: nodes\n        }).pipe(tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else {\n        // For nested nodes, we still need to perform the node flattening in order\n        // to maintain our caches for various tree operations.\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: nodes,\n          flattenedNodes\n        })));\n      }\n    }\n    _updateCachedData(flattenedNodes) {\n      this._flattenedNodes.next(flattenedNodes);\n    }\n    _updateKeyManagerItems(flattenedNodes) {\n      this._keyManagerNodes.next(flattenedNodes);\n    }\n    /** Traverse the flattened node data and compute parents, levels, and group data. */\n    _calculateParents(flattenedNodes) {\n      const levelAccessor = this._getLevelAccessor();\n      if (!levelAccessor) {\n        return;\n      }\n      this._parents.clear();\n      this._ariaSets.clear();\n      for (let index = 0; index < flattenedNodes.length; index++) {\n        const dataNode = flattenedNodes[index];\n        const key = this._getExpansionKey(dataNode);\n        this._levels.set(key, levelAccessor(dataNode));\n        const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n        this._parents.set(key, parent);\n        const parentKey = parent ? this._getExpansionKey(parent) : null;\n        const group = this._ariaSets.get(parentKey) ?? [];\n        group.splice(index, 0, dataNode);\n        this._ariaSets.set(parentKey, group);\n      }\n    }\n    /** Invokes a callback with all node expansion keys. */\n    _forEachExpansionKey(callback) {\n      const toToggle = [];\n      const observables = [];\n      this._nodes.value.forEach(node => {\n        toToggle.push(this._getExpansionKey(node.data));\n        observables.push(this._getDescendants(node.data));\n      });\n      if (observables.length > 0) {\n        combineLatest(observables).pipe(take(1), takeUntil(this._onDestroy)).subscribe(results => {\n          results.forEach(inner => inner.forEach(r => toToggle.push(this._getExpansionKey(r))));\n          callback(toToggle);\n        });\n      } else {\n        callback(toToggle);\n      }\n    }\n    static ɵfac = function CdkTree_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTree)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkTree,\n      selectors: [[\"cdk-tree\"]],\n      contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeDefs = _t);\n        }\n      },\n      viewQuery: function CdkTree_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(CdkTreeNodeOutlet, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"tree\", 1, \"cdk-tree\"],\n      hostBindings: function CdkTree_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function CdkTree_keydown_HostBindingHandler($event) {\n            return ctx._sendKeydownToKeyManager($event);\n          });\n        }\n      },\n      inputs: {\n        dataSource: \"dataSource\",\n        treeControl: \"treeControl\",\n        levelAccessor: \"levelAccessor\",\n        childrenAccessor: \"childrenAccessor\",\n        trackBy: \"trackBy\",\n        expansionKey: \"expansionKey\"\n      },\n      exportAs: [\"cdkTree\"],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkTreeNodeOutlet\", \"\"]],\n      template: function CdkTree_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkTreeNodeOutlet],\n      encapsulation: 2\n    });\n  }\n  return CdkTree;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\nlet CdkTreeNode = /*#__PURE__*/(() => {\n  class CdkTreeNode {\n    _elementRef = inject(ElementRef);\n    _tree = inject(CdkTree);\n    _tabindex = -1;\n    _type = 'flat';\n    /**\n     * The role of the tree node.\n     *\n     * @deprecated This will be ignored; the tree will automatically determine the appropriate role\n     * for tree node. This input will be removed in a future version.\n     * @breaking-change 21.0.0\n     */\n    get role() {\n      return 'treeitem';\n    }\n    set role(_role) {\n      // ignore any role setting, we handle this internally.\n    }\n    /**\n     * Whether or not this node is expandable.\n     *\n     * If not using `FlatTreeControl`, or if `isExpandable` is not provided to\n     * `NestedTreeControl`, this should be provided for correct node a11y.\n     */\n    get isExpandable() {\n      return this._isExpandable();\n    }\n    set isExpandable(isExpandable) {\n      this._inputIsExpandable = isExpandable;\n      if (this.data && !this._isExpandable || !this._inputIsExpandable) {\n        return;\n      }\n      // If the node is being set to expandable, ensure that the status of the\n      // node is propagated\n      if (this._inputIsExpanded) {\n        this.expand();\n      } else if (this._inputIsExpanded === false) {\n        this.collapse();\n      }\n    }\n    get isExpanded() {\n      return this._tree.isExpanded(this._data);\n    }\n    set isExpanded(isExpanded) {\n      this._inputIsExpanded = isExpanded;\n      if (isExpanded) {\n        this.expand();\n      } else {\n        this.collapse();\n      }\n    }\n    /**\n     * Whether or not this node is disabled. If it's disabled, then the user won't be able to focus\n     * or activate this node.\n     */\n    isDisabled;\n    /**\n     * The text used to locate this item during typeahead. If not specified, the `textContent` will\n     * will be used.\n     */\n    typeaheadLabel;\n    getLabel() {\n      return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    /** This emits when the node has been programatically activated or activated by keyboard. */\n    activation = new EventEmitter();\n    /** This emits when the node's expansion status has been changed. */\n    expandedChange = new EventEmitter();\n    /**\n     * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n     * in `CdkTree` and set the data to it.\n     */\n    static mostRecentTreeNode = null;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** Emits when the node's data has changed. */\n    _dataChanges = new Subject();\n    _inputIsExpandable = false;\n    _inputIsExpanded = undefined;\n    /**\n     * Flag used to determine whether or not we should be focusing the actual element based on\n     * some user interaction (click or focus). On click, we don't forcibly focus the element\n     * since the click could trigger some other component that wants to grab its own focus\n     * (e.g. menu, dialog).\n     */\n    _shouldFocus = true;\n    _parentNodeAriaLevel;\n    /** The tree node's data. */\n    get data() {\n      return this._data;\n    }\n    set data(value) {\n      if (value !== this._data) {\n        this._data = value;\n        this._dataChanges.next();\n      }\n    }\n    _data;\n    /* If leaf node, return true to not assign aria-expanded attribute */\n    get isLeafNode() {\n      // If flat tree node data returns false for expandable property, it's a leaf node\n      if (this._tree.treeControl?.isExpandable !== undefined && !this._tree.treeControl.isExpandable(this._data)) {\n        return true;\n        // If nested tree node data returns 0 descendants, it's a leaf node\n      } else if (this._tree.treeControl?.isExpandable === undefined && this._tree.treeControl?.getDescendants(this._data).length === 0) {\n        return true;\n      }\n      return false;\n    }\n    get level() {\n      // If the tree has a levelAccessor, use it to get the level. Otherwise read the\n      // aria-level off the parent node and use it as the level for this node (note aria-level is\n      // 1-indexed, while this property is 0-indexed, so we don't need to increment).\n      return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n    }\n    /** Determines if the tree node is expandable. */\n    _isExpandable() {\n      if (this._tree.treeControl) {\n        if (this.isLeafNode) {\n          return false;\n        }\n        // For compatibility with trees created using TreeControl before we added\n        // CdkTreeNode#isExpandable.\n        return true;\n      }\n      return this._inputIsExpandable;\n    }\n    /**\n     * Determines the value for `aria-expanded`.\n     *\n     * For non-expandable nodes, this is `null`.\n     */\n    _getAriaExpanded() {\n      if (!this._isExpandable()) {\n        return null;\n      }\n      return String(this.isExpanded);\n    }\n    /**\n     * Determines the size of this node's parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize() {\n      return this._tree._getSetSize(this._data);\n    }\n    /**\n     * Determines the index (starting from 1) of this node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet() {\n      return this._tree._getPositionInSet(this._data);\n    }\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    constructor() {\n      CdkTreeNode.mostRecentTreeNode = this;\n    }\n    ngOnInit() {\n      this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n      this._tree._getExpansionModel().changed.pipe(map(() => this.isExpanded), distinctUntilChanged()).subscribe(() => this._changeDetectorRef.markForCheck());\n      this._tree._setNodeTypeIfUnset(this._type);\n      this._tree._registerNode(this);\n    }\n    ngOnDestroy() {\n      // If this is the last tree node being destroyed,\n      // clear out the reference to avoid leaking memory.\n      if (CdkTreeNode.mostRecentTreeNode === this) {\n        CdkTreeNode.mostRecentTreeNode = null;\n      }\n      this._dataChanges.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    getParent() {\n      return this._tree._getNodeParent(this) ?? null;\n    }\n    getChildren() {\n      return this._tree._getNodeChildren(this);\n    }\n    /** Focuses this data node. Implemented for TreeKeyManagerItem. */\n    focus() {\n      this._tabindex = 0;\n      if (this._shouldFocus) {\n        this._elementRef.nativeElement.focus();\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Defocus this data node. */\n    unfocus() {\n      this._tabindex = -1;\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Emits an activation event. Implemented for TreeKeyManagerItem. */\n    activate() {\n      if (this.isDisabled) {\n        return;\n      }\n      this.activation.next(this._data);\n    }\n    /** Collapses this data node. Implemented for TreeKeyManagerItem. */\n    collapse() {\n      if (this.isExpandable) {\n        this._tree.collapse(this._data);\n      }\n    }\n    /** Expands this data node. Implemented for TreeKeyManagerItem. */\n    expand() {\n      if (this.isExpandable) {\n        this._tree.expand(this._data);\n      }\n    }\n    /** Makes the node focusable. Implemented for TreeKeyManagerItem. */\n    makeFocusable() {\n      this._tabindex = 0;\n      this._changeDetectorRef.markForCheck();\n    }\n    _focusItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._tree._keyManager.focusItem(this);\n    }\n    _setActiveItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._shouldFocus = false;\n      this._tree._keyManager.focusItem(this);\n      this._shouldFocus = true;\n    }\n    _emitExpansionState(expanded) {\n      this.expandedChange.emit(expanded);\n    }\n    static ɵfac = function CdkTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNode)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNode,\n      selectors: [[\"cdk-tree-node\"]],\n      hostAttrs: [\"role\", \"treeitem\", 1, \"cdk-tree-node\"],\n      hostVars: 5,\n      hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNode_click_HostBindingHandler() {\n            return ctx._setActiveItem();\n          })(\"focus\", function CdkTreeNode_focus_HostBindingHandler() {\n            return ctx._focusItem();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabindex\", ctx._tabindex);\n          i0.ɵɵattribute(\"aria-expanded\", ctx._getAriaExpanded())(\"aria-level\", ctx.level + 1)(\"aria-posinset\", ctx._getPositionInSet())(\"aria-setsize\", ctx._getSetSize());\n        }\n      },\n      inputs: {\n        role: \"role\",\n        isExpandable: [2, \"isExpandable\", \"isExpandable\", booleanAttribute],\n        isExpanded: \"isExpanded\",\n        isDisabled: [2, \"isDisabled\", \"isDisabled\", booleanAttribute],\n        typeaheadLabel: [0, \"cdkTreeNodeTypeaheadLabel\", \"typeaheadLabel\"]\n      },\n      outputs: {\n        activation: \"activation\",\n        expandedChange: \"expandedChange\"\n      },\n      exportAs: [\"cdkTreeNode\"]\n    });\n  }\n  return CdkTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getParentNodeAriaLevel(nodeElement) {\n  let parent = nodeElement.parentElement;\n  while (parent && !isNodeElement(parent)) {\n    parent = parent.parentElement;\n  }\n  if (!parent) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error('Incorrect tree structure containing detached node.');\n    } else {\n      return -1;\n    }\n  } else if (parent.classList.contains('cdk-nested-tree-node')) {\n    return numberAttribute(parent.getAttribute('aria-level'));\n  } else {\n    // The ancestor element is the cdk-tree itself\n    return 0;\n  }\n}\nfunction isNodeElement(element) {\n  const classList = element.classList;\n  return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\nlet CdkNestedTreeNode = /*#__PURE__*/(() => {\n  class CdkNestedTreeNode extends CdkTreeNode {\n    _type = 'nested';\n    _differs = inject(IterableDiffers);\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n    _children;\n    /** The children node placeholder. */\n    nodeOutlet;\n    constructor() {\n      super();\n    }\n    ngAfterContentInit() {\n      this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n      this._tree._getDirectChildren(this.data).pipe(takeUntil(this._destroyed)).subscribe(result => this.updateChildrenNodes(result));\n      this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());\n    }\n    ngOnDestroy() {\n      this._clear();\n      super.ngOnDestroy();\n    }\n    /** Add children dataNodes to the NodeOutlet */\n    updateChildrenNodes(children) {\n      const outlet = this._getNodeOutlet();\n      if (children) {\n        this._children = children;\n      }\n      if (outlet && this._children) {\n        const viewContainer = outlet.viewContainer;\n        this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n      } else {\n        // Reset the data differ if there's no children nodes displayed\n        this._dataDiffer.diff([]);\n      }\n    }\n    /** Clear the children dataNodes. */\n    _clear() {\n      const outlet = this._getNodeOutlet();\n      if (outlet) {\n        outlet.viewContainer.clear();\n        this._dataDiffer.diff([]);\n      }\n    }\n    /** Gets the outlet for the current node. */\n    _getNodeOutlet() {\n      const outlets = this.nodeOutlet;\n      // Note that since we use `descendants: true` on the query, we have to ensure\n      // that we don't pick up the outlet of a child node by accident.\n      return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n    }\n    static ɵfac = function CdkNestedTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkNestedTreeNode)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkNestedTreeNode,\n      selectors: [[\"cdk-nested-tree-node\"]],\n      contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t);\n        }\n      },\n      hostAttrs: [1, \"cdk-nested-tree-node\"],\n      exportAs: [\"cdkNestedTreeNode\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return CdkNestedTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\nlet CdkTreeNodePadding = /*#__PURE__*/(() => {\n  class CdkTreeNodePadding {\n    _treeNode = inject(CdkTreeNode);\n    _tree = inject(CdkTree);\n    _element = inject(ElementRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n    _currentPadding;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** CSS units used for the indentation value. */\n    indentUnits = 'px';\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level() {\n      return this._level;\n    }\n    set level(value) {\n      this._setLevelInput(value);\n    }\n    _level;\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     */\n    get indent() {\n      return this._indent;\n    }\n    set indent(indent) {\n      this._setIndentInput(indent);\n    }\n    _indent = 40;\n    constructor() {\n      this._setPadding();\n      this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n      // In Ivy the indentation binding might be set before the tree node's data has been added,\n      // which means that we'll miss the first render. We have to subscribe to changes in the\n      // data to ensure that everything is up to date.\n      this._treeNode._dataChanges.subscribe(() => this._setPadding());\n    }\n    ngOnDestroy() {\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n    _paddingIndent() {\n      const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n      const level = this._level == null ? nodeLevel : this._level;\n      return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n    }\n    _setPadding(forceChange = false) {\n      const padding = this._paddingIndent();\n      if (padding !== this._currentPadding || forceChange) {\n        const element = this._element.nativeElement;\n        const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n        const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n        element.style[paddingProp] = padding || '';\n        element.style[resetProp] = '';\n        this._currentPadding = padding;\n      }\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setLevelInput(value) {\n      // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n      // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n      // they set 0 explicitly.\n      this._level = isNaN(value) ? null : value;\n      this._setPadding();\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setIndentInput(indent) {\n      let value = indent;\n      let units = 'px';\n      if (typeof indent === 'string') {\n        const parts = indent.split(cssUnitPattern);\n        value = parts[0];\n        units = parts[1] || units;\n      }\n      this.indentUnits = units;\n      this._indent = numberAttribute(value);\n      this._setPadding();\n    }\n    static ɵfac = function CdkTreeNodePadding_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodePadding)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodePadding,\n      selectors: [[\"\", \"cdkTreeNodePadding\", \"\"]],\n      inputs: {\n        level: [2, \"cdkTreeNodePadding\", \"level\", numberAttribute],\n        indent: [0, \"cdkTreeNodePaddingIndent\", \"indent\"]\n      }\n    });\n  }\n  return CdkTreeNodePadding;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Node toggle to expand and collapse the node.\n */\nlet CdkTreeNodeToggle = /*#__PURE__*/(() => {\n  class CdkTreeNodeToggle {\n    _tree = inject(CdkTree);\n    _treeNode = inject(CdkTreeNode);\n    /** Whether expand/collapse the node recursively. */\n    recursive = false;\n    constructor() {}\n    // Toggle the expanded or collapsed state of this node.\n    //\n    // Focus this node with expanding or collapsing it. This ensures that the active node will always\n    // be visible when expanding and collapsing.\n    _toggle() {\n      this.recursive ? this._tree.toggleDescendants(this._treeNode.data) : this._tree.toggle(this._treeNode.data);\n      this._tree._keyManager.focusItem(this._treeNode);\n    }\n    static ɵfac = function CdkTreeNodeToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeToggle)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTreeNodeToggle,\n      selectors: [[\"\", \"cdkTreeNodeToggle\", \"\"]],\n      hostAttrs: [\"tabindex\", \"-1\"],\n      hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function CdkTreeNodeToggle_click_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.stopPropagation();\n          })(\"keydown.Enter\", function CdkTreeNodeToggle_keydown_Enter_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          })(\"keydown.Space\", function CdkTreeNodeToggle_keydown_Space_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          });\n        }\n      },\n      inputs: {\n        recursive: [2, \"cdkTreeNodeToggleRecursive\", \"recursive\", booleanAttribute]\n      }\n    });\n  }\n  return CdkTreeNodeToggle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\nlet CdkTreeModule = /*#__PURE__*/(() => {\n  class CdkTreeModule {\n    static ɵfac = function CdkTreeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CdkTreeModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return CdkTreeModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getMultipleTreeControlsError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };\n","import { CdkTreeNode, CdkTreeNodeDef, CdkNestedTreeNode, CDK_TREE_NODE_OUTLET_NODE, CdkTreeNodePadding, CdkTreeNodeOutlet, CdkTree, CdkTreeNodeToggle, CdkTreeModule } from '@angular/cdk/tree';\nimport * as i0 from '@angular/core';\nimport { inject, HostAttributeToken, numberAttribute, booleanAttribute, Directive, Input, ViewContainerRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nimport { DataSource } from '@angular/cdk/collections';\nimport { BehaviorSubject, merge } from 'rxjs';\nimport { take, map } from 'rxjs/operators';\n\n/**\n * Determinte if argument TreeKeyManager is the NoopTreeKeyManager. This function is safe to use with SSR.\n */\nfunction isNoopTreeKeyManager(keyManager) {\n  return !!keyManager._isNoopTreeKeyManager;\n}\n/**\n * Wrapper for the CdkTree node with Material design styles.\n */\nlet MatTreeNode = /*#__PURE__*/(() => {\n  class MatTreeNode extends CdkTreeNode {\n    /**\n     * The tabindex of the tree node.\n     *\n     * @deprecated By default MatTreeNode manages focus using TreeKeyManager instead of tabIndex.\n     *   Recommend to avoid setting tabIndex directly to prevent TreeKeyManager form getting into\n     *   an unexpected state. Tabindex to be removed in a future version.\n     * @breaking-change 21.0.0 Remove this attribute.\n     */\n    get tabIndexInputBinding() {\n      return this._tabIndexInputBinding;\n    }\n    set tabIndexInputBinding(value) {\n      // If the specified tabIndex value is null or undefined, fall back to the default value.\n      this._tabIndexInputBinding = value;\n    }\n    _tabIndexInputBinding;\n    /**\n     * The default tabindex of the tree node.\n     *\n     * @deprecated By default MatTreeNode manages focus using TreeKeyManager instead of tabIndex.\n     *   Recommend to avoid setting tabIndex directly to prevent TreeKeyManager form getting into\n     *   an unexpected state. Tabindex to be removed in a future version.\n     * @breaking-change 21.0.0 Remove this attribute.\n     */\n    defaultTabIndex = 0;\n    _getTabindexAttribute() {\n      if (isNoopTreeKeyManager(this._tree._keyManager)) {\n        return this.tabIndexInputBinding;\n      }\n      return this._tabindex;\n    }\n    /**\n     * Whether the component is disabled.\n     *\n     * @deprecated This is an alias for `isDisabled`.\n     * @breaking-change 21.0.0 Remove this input\n     */\n    get disabled() {\n      return this.isDisabled;\n    }\n    set disabled(value) {\n      this.isDisabled = value;\n    }\n    constructor() {\n      super();\n      const tabIndex = inject(new HostAttributeToken('tabindex'), {\n        optional: true\n      });\n      this.tabIndexInputBinding = Number(tabIndex) || this.defaultTabIndex;\n    }\n    // This is a workaround for https://github.com/angular/angular/issues/23091\n    // In aot mode, the lifecycle hooks from parent class are not called.\n    ngOnInit() {\n      super.ngOnInit();\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n    }\n    static ɵfac = function MatTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatTreeNode)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatTreeNode,\n      selectors: [[\"mat-tree-node\"]],\n      hostAttrs: [1, \"mat-tree-node\"],\n      hostVars: 5,\n      hostBindings: function MatTreeNode_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatTreeNode_click_HostBindingHandler() {\n            return ctx._focusItem();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabindex\", ctx._getTabindexAttribute());\n          i0.ɵɵattribute(\"aria-expanded\", ctx._getAriaExpanded())(\"aria-level\", ctx.level + 1)(\"aria-posinset\", ctx._getPositionInSet())(\"aria-setsize\", ctx._getSetSize());\n        }\n      },\n      inputs: {\n        tabIndexInputBinding: [2, \"tabIndex\", \"tabIndexInputBinding\", value => value == null ? 0 : numberAttribute(value)],\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute]\n      },\n      outputs: {\n        activation: \"activation\",\n        expandedChange: \"expandedChange\"\n      },\n      exportAs: [\"matTreeNode\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNode,\n        useExisting: MatTreeNode\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Wrapper for the CdkTree node definition with Material design styles.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nlet MatTreeNodeDef = /*#__PURE__*/(() => {\n  class MatTreeNodeDef extends CdkTreeNodeDef {\n    data;\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatTreeNodeDef_BaseFactory;\n      return function MatTreeNodeDef_Factory(__ngFactoryType__) {\n        return (ɵMatTreeNodeDef_BaseFactory || (ɵMatTreeNodeDef_BaseFactory = i0.ɵɵgetInheritedFactory(MatTreeNodeDef)))(__ngFactoryType__ || MatTreeNodeDef);\n      };\n    })();\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatTreeNodeDef,\n      selectors: [[\"\", \"matTreeNodeDef\", \"\"]],\n      inputs: {\n        when: [0, \"matTreeNodeDefWhen\", \"when\"],\n        data: [0, \"matTreeNode\", \"data\"]\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNodeDef,\n        useExisting: MatTreeNodeDef\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatTreeNodeDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Wrapper for the CdkTree nested node with Material design styles.\n */\nlet MatNestedTreeNode = /*#__PURE__*/(() => {\n  class MatNestedTreeNode extends CdkNestedTreeNode {\n    node;\n    /**\n     * Whether the node is disabled.\n     *\n     * @deprecated This is an alias for `isDisabled`.\n     * @breaking-change 21.0.0 Remove this input\n     */\n    get disabled() {\n      return this.isDisabled;\n    }\n    set disabled(value) {\n      this.isDisabled = value;\n    }\n    /** Tabindex of the node. */\n    get tabIndex() {\n      return this.isDisabled ? -1 : this._tabIndex;\n    }\n    set tabIndex(value) {\n      // If the specified tabIndex value is null or undefined, fall back to the default value.\n      this._tabIndex = value;\n    }\n    _tabIndex;\n    // This is a workaround for https://github.com/angular/angular/issues/19145\n    // In aot mode, the lifecycle hooks from parent class are not called.\n    // TODO(tinayuangao): Remove when the angular issue #19145 is fixed\n    ngOnInit() {\n      super.ngOnInit();\n    }\n    ngAfterContentInit() {\n      super.ngAfterContentInit();\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatNestedTreeNode_BaseFactory;\n      return function MatNestedTreeNode_Factory(__ngFactoryType__) {\n        return (ɵMatNestedTreeNode_BaseFactory || (ɵMatNestedTreeNode_BaseFactory = i0.ɵɵgetInheritedFactory(MatNestedTreeNode)))(__ngFactoryType__ || MatNestedTreeNode);\n      };\n    })();\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatNestedTreeNode,\n      selectors: [[\"mat-nested-tree-node\"]],\n      hostAttrs: [1, \"mat-nested-tree-node\"],\n      inputs: {\n        node: [0, \"matNestedTreeNode\", \"node\"],\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        tabIndex: [2, \"tabIndex\", \"tabIndex\", value => value == null ? 0 : numberAttribute(value)]\n      },\n      outputs: {\n        activation: \"activation\",\n        expandedChange: \"expandedChange\"\n      },\n      exportAs: [\"matNestedTreeNode\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkNestedTreeNode,\n        useExisting: MatNestedTreeNode\n      }, {\n        provide: CdkTreeNode,\n        useExisting: MatNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: MatNestedTreeNode\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatNestedTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Wrapper for the CdkTree padding with Material design styles.\n */\nlet MatTreeNodePadding = /*#__PURE__*/(() => {\n  class MatTreeNodePadding extends CdkTreeNodePadding {\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level() {\n      return this._level;\n    }\n    set level(value) {\n      this._setLevelInput(value);\n    }\n    /** The indent for each level. Default number 40px from material design menu sub-menu spec. */\n    get indent() {\n      return this._indent;\n    }\n    set indent(indent) {\n      this._setIndentInput(indent);\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatTreeNodePadding_BaseFactory;\n      return function MatTreeNodePadding_Factory(__ngFactoryType__) {\n        return (ɵMatTreeNodePadding_BaseFactory || (ɵMatTreeNodePadding_BaseFactory = i0.ɵɵgetInheritedFactory(MatTreeNodePadding)))(__ngFactoryType__ || MatTreeNodePadding);\n      };\n    })();\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatTreeNodePadding,\n      selectors: [[\"\", \"matTreeNodePadding\", \"\"]],\n      inputs: {\n        level: [2, \"matTreeNodePadding\", \"level\", numberAttribute],\n        indent: [0, \"matTreeNodePaddingIndent\", \"indent\"]\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNodePadding,\n        useExisting: MatTreeNodePadding\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatTreeNodePadding;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Outlet for nested CdkNode. Put `[matTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nlet MatTreeNodeOutlet = /*#__PURE__*/(() => {\n  class MatTreeNodeOutlet {\n    viewContainer = inject(ViewContainerRef);\n    _node = inject(CDK_TREE_NODE_OUTLET_NODE, {\n      optional: true\n    });\n    static ɵfac = function MatTreeNodeOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatTreeNodeOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatTreeNodeOutlet,\n      selectors: [[\"\", \"matTreeNodeOutlet\", \"\"]],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNodeOutlet,\n        useExisting: MatTreeNodeOutlet\n      }])]\n    });\n  }\n  return MatTreeNodeOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Wrapper for the CdkTable with Material design styles.\n */\nlet MatTree = /*#__PURE__*/(() => {\n  class MatTree extends CdkTree {\n    // Outlets within the tree's template where the dataNodes will be inserted.\n    // We need an initializer here to avoid a TS error. The value will be set in `ngAfterViewInit`.\n    _nodeOutlet = undefined;\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatTree_BaseFactory;\n      return function MatTree_Factory(__ngFactoryType__) {\n        return (ɵMatTree_BaseFactory || (ɵMatTree_BaseFactory = i0.ɵɵgetInheritedFactory(MatTree)))(__ngFactoryType__ || MatTree);\n      };\n    })();\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatTree,\n      selectors: [[\"mat-tree\"]],\n      viewQuery: function MatTree_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(MatTreeNodeOutlet, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-tree\"],\n      exportAs: [\"matTree\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTree,\n        useExisting: MatTree\n      }]), i0.ɵɵInheritDefinitionFeature],\n      decls: 1,\n      vars: 0,\n      consts: [[\"matTreeNodeOutlet\", \"\"]],\n      template: function MatTree_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementContainer(0, 0);\n        }\n      },\n      dependencies: [MatTreeNodeOutlet],\n      styles: [\".mat-tree{display:block;background-color:var(--mat-tree-container-background-color, var(--mat-sys-surface))}.mat-tree-node,.mat-nested-tree-node{color:var(--mat-tree-node-text-color, var(--mat-sys-on-surface));font-family:var(--mat-tree-node-text-font, var(--mat-sys-body-large-font));font-size:var(--mat-tree-node-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-tree-node-text-weight, var(--mat-sys-body-large-weight))}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word;min-height:var(--mat-tree-node-min-height, 48px)}.mat-nested-tree-node{border-bottom-width:0}\"],\n      encapsulation: 2\n    });\n  }\n  return MatTree;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Wrapper for the CdkTree's toggle with Material design styles.\n */\nlet MatTreeNodeToggle = /*#__PURE__*/(() => {\n  class MatTreeNodeToggle extends CdkTreeNodeToggle {\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatTreeNodeToggle_BaseFactory;\n      return function MatTreeNodeToggle_Factory(__ngFactoryType__) {\n        return (ɵMatTreeNodeToggle_BaseFactory || (ɵMatTreeNodeToggle_BaseFactory = i0.ɵɵgetInheritedFactory(MatTreeNodeToggle)))(__ngFactoryType__ || MatTreeNodeToggle);\n      };\n    })();\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatTreeNodeToggle,\n      selectors: [[\"\", \"matTreeNodeToggle\", \"\"]],\n      inputs: {\n        recursive: [0, \"matTreeNodeToggleRecursive\", \"recursive\"]\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkTreeNodeToggle,\n        useExisting: MatTreeNodeToggle\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatTreeNodeToggle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MAT_TREE_DIRECTIVES = [MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet];\nlet MatTreeModule = /*#__PURE__*/(() => {\n  class MatTreeModule {\n    static ɵfac = function MatTreeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatTreeModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatTreeModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CdkTreeModule, MatCommonModule, MatCommonModule]\n    });\n  }\n  return MatTreeModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Tree flattener to convert a normal type of node to node with children & level information.\n * Transform nested nodes of type `T` to flattened nodes of type `F`.\n *\n * For example, the input data of type `T` is nested, and contains its children data:\n *   SomeNode: {\n *     key: 'Fruits',\n *     children: [\n *       NodeOne: {\n *         key: 'Apple',\n *       },\n *       NodeTwo: {\n *        key: 'Pear',\n *      }\n *    ]\n *  }\n *  After flattener flatten the tree, the structure will become\n *  SomeNode: {\n *    key: 'Fruits',\n *    expandable: true,\n *    level: 1\n *  },\n *  NodeOne: {\n *    key: 'Apple',\n *    expandable: false,\n *    level: 2\n *  },\n *  NodeTwo: {\n *   key: 'Pear',\n *   expandable: false,\n *   level: 2\n * }\n * and the output flattened type is `F` with additional information.\n *\n * @deprecated Use MatTree#childrenAccessor and MatTreeNode#isExpandable\n * instead. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nclass MatTreeFlattener {\n  transformFunction;\n  getLevel;\n  isExpandable;\n  getChildren;\n  constructor(transformFunction, getLevel, isExpandable, getChildren) {\n    this.transformFunction = transformFunction;\n    this.getLevel = getLevel;\n    this.isExpandable = isExpandable;\n    this.getChildren = getChildren;\n  }\n  _flattenNode(node, level, resultNodes, parentMap) {\n    const flatNode = this.transformFunction(node, level);\n    resultNodes.push(flatNode);\n    if (this.isExpandable(flatNode)) {\n      const childrenNodes = this.getChildren(node);\n      if (childrenNodes) {\n        if (Array.isArray(childrenNodes)) {\n          this._flattenChildren(childrenNodes, level, resultNodes, parentMap);\n        } else {\n          childrenNodes.pipe(take(1)).subscribe(children => {\n            this._flattenChildren(children, level, resultNodes, parentMap);\n          });\n        }\n      }\n    }\n    return resultNodes;\n  }\n  _flattenChildren(children, level, resultNodes, parentMap) {\n    children.forEach((child, index) => {\n      let childParentMap = parentMap.slice();\n      childParentMap.push(index != children.length - 1);\n      this._flattenNode(child, level + 1, resultNodes, childParentMap);\n    });\n  }\n  /**\n   * Flatten a list of node type T to flattened version of node F.\n   * Please note that type T may be nested, and the length of `structuredData` may be different\n   * from that of returned list `F[]`.\n   */\n  flattenNodes(structuredData) {\n    let resultNodes = [];\n    structuredData.forEach(node => this._flattenNode(node, 0, resultNodes, []));\n    return resultNodes;\n  }\n  /**\n   * Expand flattened node with current expansion status.\n   * The returned list may have different length.\n   */\n  expandFlattenedNodes(nodes, treeControl) {\n    let results = [];\n    let currentExpand = [];\n    currentExpand[0] = true;\n    nodes.forEach(node => {\n      let expand = true;\n      for (let i = 0; i <= this.getLevel(node); i++) {\n        expand = expand && currentExpand[i];\n      }\n      if (expand) {\n        results.push(node);\n      }\n      if (this.isExpandable(node)) {\n        currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);\n      }\n    });\n    return results;\n  }\n}\n/**\n * Data source for flat tree.\n * The data source need to handle expansion/collapsion of the tree node and change the data feed\n * to `MatTree`.\n * The nested tree nodes of type `T` are flattened through `MatTreeFlattener`, and converted\n * to type `F` for `MatTree` to consume.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass MatTreeFlatDataSource extends DataSource {\n  _treeControl;\n  _treeFlattener;\n  _flattenedData = /*#__PURE__*/new BehaviorSubject([]);\n  _expandedData = /*#__PURE__*/new BehaviorSubject([]);\n  get data() {\n    return this._data.value;\n  }\n  set data(value) {\n    this._data.next(value);\n    this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));\n    this._treeControl.dataNodes = this._flattenedData.value;\n  }\n  _data = /*#__PURE__*/new BehaviorSubject([]);\n  constructor(_treeControl, _treeFlattener, initialData) {\n    super();\n    this._treeControl = _treeControl;\n    this._treeFlattener = _treeFlattener;\n    if (initialData) {\n      // Assign the data through the constructor to ensure that all of the logic is executed.\n      this.data = initialData;\n    }\n  }\n  connect(collectionViewer) {\n    return merge(collectionViewer.viewChange, this._treeControl.expansionModel.changed, this._flattenedData).pipe(map(() => {\n      this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this._treeControl));\n      return this._expandedData.value;\n    }));\n  }\n  disconnect() {\n    // no op\n  }\n}\n\n/**\n * Data source for nested tree.\n *\n * The data source for nested tree doesn't have to consider node flattener, or the way to expand\n * or collapse. The expansion/collapsion will be handled by TreeControl and each non-leaf node.\n */\nclass MatTreeNestedDataSource extends DataSource {\n  /**\n   * Data for the nested tree\n   */\n  get data() {\n    return this._data.value;\n  }\n  set data(value) {\n    this._data.next(value);\n  }\n  _data = /*#__PURE__*/new BehaviorSubject([]);\n  connect(collectionViewer) {\n    return merge(...[collectionViewer.viewChange, this._data]).pipe(map(() => this.data));\n  }\n  disconnect() {\n    // no op\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatNestedTreeNode, MatTree, MatTreeFlatDataSource, MatTreeFlattener, MatTreeModule, MatTreeNestedDataSource, MatTreeNode, MatTreeNodeDef, MatTreeNodeOutlet, MatTreeNodePadding, MatTreeNodeToggle };\n","import { NestedTreeControl } from '@angular/cdk/tree';\r\nimport { Component, ContentChild, Input, TemplateRef } from '@angular/core';\r\nimport { faChevronRight } from '@fortawesome/free-solid-svg-icons';\r\nimport { KnowledgeAreaForTree } from 'app/entities/competency/standardized-competency.model';\r\nimport { MatTreeModule, MatTreeNestedDataSource } from '@angular/material/tree';\r\nimport { FaIconComponent } from '@fortawesome/angular-fontawesome';\r\nimport { NgbCollapse } from '@ng-bootstrap/ng-bootstrap';\r\nimport { TranslateDirective } from 'app/shared/language/translate.directive';\r\nimport { CommonModule } from '@angular/common';\r\n\r\n@Component({\r\n    selector: 'jhi-knowledge-area-tree',\r\n    templateUrl: './knowledge-area-tree.component.html',\r\n    styleUrls: ['./knowledge-area-tree.component.scss'],\r\n    imports: [MatTreeModule, FaIconComponent, NgbCollapse, TranslateDirective, CommonModule],\r\n})\r\nexport class KnowledgeAreaTreeComponent {\r\n    @Input() dataSource: MatTreeNestedDataSource<KnowledgeAreaForTree> = new MatTreeNestedDataSource<KnowledgeAreaForTree>();\r\n    @Input() treeControl: NestedTreeControl<KnowledgeAreaForTree> = new NestedTreeControl<KnowledgeAreaForTree>((node) => node.children);\r\n\r\n    @ContentChild('knowledgeAreaTemplate') knowledgeAreaTemplate: TemplateRef<any>;\r\n    @ContentChild('competencyTemplate') competencyTemplate: TemplateRef<any>;\r\n\r\n    //Icons\r\n    protected readonly faChevronRight = faChevronRight;\r\n    //constants\r\n    readonly trackBy = (_: number, node: KnowledgeAreaForTree) => node.id;\r\n}\r\n","<mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" [trackBy]=\"trackBy\" class=\"card w-100\">\r\n    <mat-nested-tree-node *matTreeNodeDef=\"let knowledgeArea\" [class.d-none]=\"!knowledgeArea.isVisible\">\r\n        <div class=\"card tree-card\">\r\n            <div class=\"d-flex align-items-center clickable me-2\" matTreeNodeToggle>\r\n                <div class=\"me-2\">\r\n                    <fa-icon [icon]=\"faChevronRight\" class=\"rotate-icon chevron-position\" [class.rotated]=\"treeControl.isExpanded(knowledgeArea)\" />\r\n                </div>\r\n                <h5 class=\"mb-0\">{{ knowledgeArea.title }}</h5>\r\n            </div>\r\n            <ng-container [ngTemplateOutlet]=\"knowledgeAreaTemplate\" [ngTemplateOutletContext]=\"{ knowledgeArea: knowledgeArea }\" />\r\n        </div>\r\n        <div [ngbCollapse]=\"!treeControl.isExpanded(knowledgeArea)\" class=\"tree-indent\">\r\n            <ng-container matTreeNodeOutlet />\r\n            @for (competency of knowledgeArea.competencies; track competency.id) {\r\n                <div class=\"card tree-card\" [class.d-none]=\"!competency.isVisible\">\r\n                    <ng-container [ngTemplateOutlet]=\"competencyTemplate\" [ngTemplateOutletContext]=\"{ competency: competency, knowledgeArea: knowledgeArea }\" />\r\n                </div>\r\n            }\r\n            @if (!knowledgeArea.children?.length && !knowledgeArea.competencies?.length) {\r\n                <div class=\"card tree-card\">\r\n                    <h6 class=\"mb-0\" jhiTranslate=\"artemisApp.knowledgeArea.empty\"></h6>\r\n                </div>\r\n            }\r\n        </div>\r\n    </mat-nested-tree-node>\r\n</mat-tree>\r\n"],"mappings":"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","names":["StandardizedCompetencyValidators","KnowledgeAreaValidators","sourceToString","source","author","title","uri","convertToStandardizedCompetencyForTree","competencyDTO","isVisible","__spreadProps","__spreadValues","convertToKnowledgeAreaForTree","knowledgeAreaDTO","level","children","map","child","competencies","competency","BaseTreeControl","SelectionModel","dataNode","toBeProcessed","value","NestedTreeControl","BaseTreeControl","getChildren","options","allNodes","accumulator","dataNode","node","descendants","childrenNodes","child","isObservable","take","filter","children","CDK_TREE_NODE_OUTLET_NODE","InjectionToken","CdkTreeNodeOutlet","inject","ViewContainerRef","__ngFactoryType__","ɵɵdefineDirective","CdkTreeNodeOutletContext","data","CdkTreeNodeDef","TemplateRef","getTreeControlMissingError","CdkTree","inject","IterableDiffers","ChangeDetectorRef","ElementRef","Directionality","Subject","dataSource","BehaviorSubject","TREE_KEY_MANAGER","defaultNodeDefs","def","newType","SelectionModel","dataStream","isDataSource","isObservable","of","takeUntil","renderingData","expansionModel","combineLatest","startWith","tap","expansionChanges","switchMap","data","nodeType","map","convertedData","__spreadProps","__spreadValues","nodes","added","removed","items","keyManagerNodes","renderNodes","node","keyManagerOptions","trackBy","_index","item","dataDiffer","viewContainer","parentData","changes","adjustedPreviousIndex","currentIndex","view","record","newData","i","nodeDef","nodeData","index","levelAccessor","key","context","CdkTreeNodeOutletContext","CdkTreeNode","dataNode","take","children","child","keys","isExpanded","EMPTY","expanded","flattenedNodes","childrenAccessor","coerceObservable","getTreeControlMissingError","levelDelta","startIndex","dataNodeLevel","expectedLevel","results","currentLevel","set","parent","value","event","reduce","allChildren","nextChildren","concatMap","concat","parentKey","cachedNodes","parentIndex","parentNode","level","childNodes","childKey","nestedNodes","rootNodes","group","callback","toToggle","observables","inner","r","__ngFactoryType__","ɵɵdefineComponent","rf","ctx","dirIndex","ɵɵcontentQuery","CdkTreeNodeDef","_t","ɵɵqueryRefresh","ɵɵloadQuery","ɵɵviewQuery","CdkTreeNodeOutlet","ɵɵlistener","$event","ɵɵelementContainer","_role","isExpandable","EventEmitter","getParentNodeAriaLevel","distinctUntilChanged","ɵɵdefineDirective","ɵɵhostProperty","ɵɵattribute","booleanAttribute","nodeElement","isNodeElement","numberAttribute","element","classList","CdkNestedTreeNode","result","outlet","outlets","ɵɵProvidersFeature","CDK_TREE_NODE_OUTLET_NODE","ɵɵInheritDefinitionFeature","CdkTreeNodeToggle","inject","CdkTree","CdkTreeNode","__ngFactoryType__","ɵɵdefineDirective","rf","ctx","ɵɵlistener","$event","booleanAttribute","CdkTreeModule","__ngFactoryType__","ɵɵdefineNgModule","ɵɵdefineInjector","MatTreeNodeDef","CdkTreeNodeDef","ɵMatTreeNodeDef_BaseFactory","__ngFactoryType__","ɵɵgetInheritedFactory","ɵɵdefineDirective","ɵɵProvidersFeature","ɵɵInheritDefinitionFeature","MatNestedTreeNode","CdkNestedTreeNode","value","ɵMatNestedTreeNode_BaseFactory","booleanAttribute","numberAttribute","CdkTreeNode","CDK_TREE_NODE_OUTLET_NODE","MatTreeNodeOutlet","inject","ViewContainerRef","CDK_TREE_NODE_OUTLET_NODE","__ngFactoryType__","ɵɵdefineDirective","ɵɵProvidersFeature","CdkTreeNodeOutlet","MatTree","CdkTree","ɵMatTree_BaseFactory","ɵɵgetInheritedFactory","ɵɵdefineComponent","rf","ctx","ɵɵviewQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","ɵɵInheritDefinitionFeature","ɵɵelementContainer","MatTreeNodeToggle","CdkTreeNodeToggle","ɵMatTreeNodeToggle_BaseFactory","MatTreeModule","__ngFactoryType__","ɵɵdefineNgModule","ɵɵdefineInjector","CdkTreeModule","MatCommonModule","MatTreeNestedDataSource","DataSource","value","BehaviorSubject","collectionViewer","merge","map","ɵɵtext","ɵɵelementStart","ɵɵelementContainer","ɵɵelementEnd","ɵɵadvance","ɵɵclassProp","competency_r1","isVisible","ɵɵproperty","ctx_r2","competencyTemplate","ɵɵpureFunction2","_c3","knowledgeArea_r2","ɵɵelement","ɵɵrepeaterCreate","KnowledgeAreaTreeComponent_mat_nested_tree_node_2_For_23_Template","_forTrack0","ɵɵtemplate","KnowledgeAreaTreeComponent_mat_nested_tree_node_2_Conditional_24_Template","treeControl","isExpanded","faChevronRight","ɵɵtextInterpolate","title","knowledgeAreaTemplate","ɵɵpureFunction1","_c2","ɵɵrepeater","competencies","ɵɵconditional","children","length","KnowledgeAreaTreeComponent","dataSource","MatTreeNestedDataSource","NestedTreeControl","node","trackBy","_","id","selectors","contentQueries","rf","ctx","dirIndex","KnowledgeAreaTreeComponent_mat_nested_tree_node_2_Template","MatTreeModule","MatNestedTreeNode","MatTreeNodeDef","MatTreeNodeToggle","MatTree","MatTreeNodeOutlet","FaIconComponent","NgbCollapse","TranslateDirective","CommonModule","NgTemplateOutlet","styles"],"x_google_ignoreList":[1,2]}