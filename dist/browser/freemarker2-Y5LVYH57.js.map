{"version":3,"sources":["node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.js"],"sourcesContent":["/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/basic-languages/freemarker2/freemarker2.ts\nvar EMPTY_ELEMENTS = [\"assign\", \"flush\", \"ftl\", \"return\", \"global\", \"import\", \"include\", \"break\", \"continue\", \"local\", \"nested\", \"nt\", \"setting\", \"stop\", \"t\", \"lt\", \"rt\", \"fallback\"];\nvar BLOCK_ELEMENTS = [\"attempt\", \"autoesc\", \"autoEsc\", \"compress\", \"comment\", \"escape\", \"noescape\", \"function\", \"if\", \"list\", \"items\", \"sep\", \"macro\", \"noparse\", \"noParse\", \"noautoesc\", \"noAutoEsc\", \"outputformat\", \"switch\", \"visit\", \"recurse\"];\nvar TagSyntaxAngle = {\n  close: \">\",\n  id: \"angle\",\n  open: \"<\"\n};\nvar TagSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open: \"\\\\[\"\n};\nvar TagSyntaxAuto = {\n  close: \"[>\\\\]]\",\n  id: \"auto\",\n  open: \"[<\\\\[]\"\n};\nvar InterpolationSyntaxDollar = {\n  close: \"\\\\}\",\n  id: \"dollar\",\n  open1: \"\\\\$\",\n  open2: \"\\\\{\"\n};\nvar InterpolationSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open1: \"\\\\[\",\n  open2: \"=\"\n};\nfunction createLangConfiguration(ts) {\n  return {\n    brackets: [[\"<\", \">\"], [\"[\", \"]\"], [\"(\", \")\"], [\"{\", \"}\"]],\n    comments: {\n      blockComment: [`${ts.open}--`, `--${ts.close}`]\n    },\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [{\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: '\"',\n      close: '\"',\n      notIn: [\"string\"]\n    }, {\n      open: \"'\",\n      close: \"'\",\n      notIn: [\"string\"]\n    }],\n    surroundingPairs: [{\n      open: '\"',\n      close: '\"'\n    }, {\n      open: \"'\",\n      close: \"'\"\n    }, {\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: \"<\",\n      close: \">\"\n    }],\n    folding: {\n      markers: {\n        start: new RegExp(`${ts.open}#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`),\n        end: new RegExp(`${ts.open}/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [{\n      beforeText: new RegExp(`${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`),\n      afterText: new RegExp(`^${ts.open}/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*${ts.close}$`),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n      }\n    }, {\n      beforeText: new RegExp(`${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.Indent\n      }\n    }]\n  };\n}\nfunction createLangConfigurationAuto() {\n  return {\n    // Cannot set block comment delimiter in auto mode...\n    // It depends on the content and the cursor position of the file...\n    brackets: [[\"<\", \">\"], [\"[\", \"]\"], [\"(\", \")\"], [\"{\", \"}\"]],\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [{\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: '\"',\n      close: '\"',\n      notIn: [\"string\"]\n    }, {\n      open: \"'\",\n      close: \"'\",\n      notIn: [\"string\"]\n    }],\n    surroundingPairs: [{\n      open: '\"',\n      close: '\"'\n    }, {\n      open: \"'\",\n      close: \"'\"\n    }, {\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: \"<\",\n      close: \">\"\n    }],\n    folding: {\n      markers: {\n        start: new RegExp(`[<\\\\[]#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/>\\\\]]*(?!/)[>\\\\]])[^<\\\\[]*$`),\n        end: new RegExp(`[<\\\\[]/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [{\n      beforeText: new RegExp(`[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`),\n      afterText: new RegExp(`^[<\\\\[]/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*[>\\\\]]$`),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n      }\n    }, {\n      beforeText: new RegExp(`[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.Indent\n      }\n    }]\n  };\n}\nfunction createMonarchLanguage(ts, is) {\n  const id = `_${ts.id}_${is.id}`;\n  const s = name => name.replace(/__id__/g, id);\n  const r = regexp => {\n    const source = regexp.source.replace(/__id__/g, id);\n    return new RegExp(source, regexp.flags);\n  };\n  return {\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: s(\"default__id__\"),\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [{\n      open: \"{\",\n      close: \"}\",\n      token: \"delimiter.curly\"\n    }, {\n      open: \"[\",\n      close: \"]\",\n      token: \"delimiter.square\"\n    }, {\n      open: \"(\",\n      close: \")\",\n      token: \"delimiter.parenthesis\"\n    }, {\n      open: \"<\",\n      close: \">\",\n      token: \"delimiter.angle\"\n    }],\n    // Dynamic RegExp\n    [s(\"open__id__\")]: new RegExp(ts.open),\n    [s(\"close__id__\")]: new RegExp(ts.close),\n    [s(\"iOpen1__id__\")]: new RegExp(is.open1),\n    [s(\"iOpen2__id__\")]: new RegExp(is.open2),\n    [s(\"iClose__id__\")]: new RegExp(is.close),\n    // <#START_TAG : \"<\" | \"<#\" | \"[#\">\n    // <#END_TAG : \"</\" | \"</#\" | \"[/#\">\n    [s(\"startTag__id__\")]: r(/(@open__id__)(#)/),\n    [s(\"endTag__id__\")]: r(/(@open__id__)(\\/#)/),\n    [s(\"startOrEndTag__id__\")]: r(/(@open__id__)(\\/?#)/),\n    // <#CLOSE_TAG1 : (<BLANK>)* (\">\" | \"]\")>\n    [s(\"closeTag1__id__\")]: r(/((?:@blank)*)(@close__id__)/),\n    // <#CLOSE_TAG2 : (<BLANK>)* (\"/\")? (\">\" | \"]\")>\n    [s(\"closeTag2__id__\")]: r(/((?:@blank)*\\/?)(@close__id__)/),\n    // Static RegExp\n    // <#BLANK : \" \" | \"\\t\" | \"\\n\" | \"\\r\">\n    blank: /[ \\t\\n\\r]/,\n    // <FALSE : \"false\">\n    // <TRUE : \"true\">\n    // <IN : \"in\">\n    // <AS : \"as\">\n    // <USING : \"using\">\n    keywords: [\"false\", \"true\", \"in\", \"as\", \"using\"],\n    // Directive names that cannot have an expression parameters and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartCloseTag1: /attempt|recover|sep|auto[eE]sc|no(?:autoe|AutoE)sc|compress|default|no[eE]scape|comment|no[pP]arse/,\n    // Directive names that cannot have an expression parameter and can be self-closing\n    // E.g. <#if> ... <#else>  ... </#if>\n    // E.g. <#if> ... <#else /></#if>\n    directiveStartCloseTag2: /else|break|continue|return|stop|flush|t|lt|rt|nt|nested|recurse|fallback|ftl/,\n    // Directive names that can have an expression parameter and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartBlank: /if|else[iI]f|list|for[eE]ach|switch|case|assign|global|local|include|import|function|macro|transform|visit|stop|return|call|setting|output[fF]ormat|nested|recurse|escape|ftl|items/,\n    // Directive names that can have an end tag\n    // E.g. </#if>\n    directiveEndCloseTag1: /if|list|items|sep|recover|attempt|for[eE]ach|local|global|assign|function|macro|output[fF]ormat|auto[eE]sc|no(?:autoe|AutoE)sc|compress|transform|switch|escape|no[eE]scape/,\n    // <#ESCAPED_CHAR :\n    //     \"\\\\\"\n    //     (\n    //         (\"n\" | \"t\" | \"r\" | \"f\" | \"b\" | \"g\" | \"l\" | \"a\" | \"\\\\\" | \"'\" | \"\\\"\" | \"{\" | \"=\")\n    //         |\n    //         (\"x\" [\"0\"-\"9\", \"A\"-\"F\", \"a\"-\"f\"])\n    //     )\n    // >\n    // Note: While the JavaCC tokenizer rule only specifies one hex digit,\n    // FreeMarker actually interprets up to 4 hex digits.\n    escapedChar: /\\\\(?:[ntrfbgla\\\\'\"\\{=]|(?:x[0-9A-Fa-f]{1,4}))/,\n    // <#ASCII_DIGIT: [\"0\" - \"9\"]>\n    asciiDigit: /[0-9]/,\n    // <INTEGER : ([\"0\"-\"9\"])+>\n    integer: /[0-9]+/,\n    // <#NON_ESCAPED_ID_START_CHAR:\n    // [\n    // \t  // This was generated on JDK 1.8.0_20 Win64 with src/main/misc/identifierChars/IdentifierCharGenerator.java\n    //    ...\n    // ]\n    nonEscapedIdStartChar: /[\\$@-Z_a-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u1FFF\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183-\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3006\\u3031-\\u3035\\u303B-\\u303C\\u3040-\\u318F\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3300-\\u337F\\u3400-\\u4DB5\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n    // <#ESCAPED_ID_CHAR: \"\\\\\" (\"-\" | \".\" | \":\" | \"#\")>\n    escapedIdChar: /\\\\[\\-\\.:#]/,\n    // <#ID_START_CHAR: <NON_ESCAPED_ID_START_CHAR>|<ESCAPED_ID_CHAR>>\n    idStartChar: /(?:@nonEscapedIdStartChar)|(?:@escapedIdChar)/,\n    // <ID: <ID_START_CHAR> (<ID_START_CHAR>|<ASCII_DIGIT>)*>\n    id: /(?:@idStartChar)(?:(?:@idStartChar)|(?:@asciiDigit))*/,\n    // Certain keywords / operators are allowed to index hashes\n    //\n    // Expression DotVariable(Expression exp) :\n    // {\n    // \tToken t;\n    // }\n    // {\n    // \t\t<DOT>\n    // \t\t(\n    // \t\t\tt = <ID> | t = <TIMES> | t = <DOUBLE_STAR>\n    // \t\t\t|\n    // \t\t\t(\n    // \t\t\t\tt = <LESS_THAN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <LESS_THAN_EQUALS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GT>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GTE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <FALSE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <TRUE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <IN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <AS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <USING>\n    // \t\t\t)\n    // \t\t\t{\n    // \t\t\t\tif (!Character.isLetter(t.image.charAt(0))) {\n    // \t\t\t\t\tthrow new ParseException(t.image + \" is not a valid identifier.\", template, t);\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t)\n    // \t\t{\n    // \t\t\tnotListLiteral(exp, \"hash\");\n    // \t\t\tnotStringLiteral(exp, \"hash\");\n    // \t\t\tnotBooleanLiteral(exp, \"hash\");\n    // \t\t\tDot dot = new Dot(exp, t.image);\n    // \t\t\tdot.setLocation(template, exp, t);\n    // \t\t\treturn dot;\n    // \t\t}\n    // }\n    specialHashKeys: /\\*\\*|\\*|false|true|in|as|using/,\n    // <DOUBLE_EQUALS : \"==\">\n    // <EQUALS : \"=\">\n    // <NOT_EQUALS : \"!=\">\n    // <PLUS_EQUALS : \"+=\">\n    // <MINUS_EQUALS : \"-=\">\n    // <TIMES_EQUALS : \"*=\">\n    // <DIV_EQUALS : \"/=\">\n    // <MOD_EQUALS : \"%=\">\n    // <PLUS_PLUS : \"++\">\n    // <MINUS_MINUS : \"--\">\n    // <LESS_THAN_EQUALS : \"lte\" | \"\\\\lte\" | \"<=\" | \"&lt;=\">\n    // <LESS_THAN : \"lt\" | \"\\\\lt\" | \"<\" | \"&lt;\">\n    // <ESCAPED_GTE : \"gte\" | \"\\\\gte\" | \"&gt;=\">\n    // <ESCAPED_GT: \"gt\" | \"\\\\gt\" |  \"&gt;\">\n    // <DOUBLE_STAR : \"**\">\n    // <PLUS : \"+\">\n    // <MINUS : \"-\">\n    // <TIMES : \"*\">\n    // <PERCENT : \"%\">\n    // <AND : \"&\" | \"&&\" | \"&amp;&amp;\" | \"\\\\and\" >\n    // <OR : \"|\" | \"||\">\n    // <EXCLAM : \"!\">\n    // <COMMA : \",\">\n    // <SEMICOLON : \";\">\n    // <COLON : \":\">\n    // <ELLIPSIS : \"...\">\n    // <DOT_DOT_ASTERISK : \"..*\" >\n    // <DOT_DOT_LESS : \"..<\" | \"..!\" >\n    // <DOT_DOT : \"..\">\n    // <EXISTS : \"??\">\n    // <BUILT_IN : \"?\">\n    // <LAMBDA_ARROW : \"->\" | \"-&gt;\">\n    namedSymbols: /&lt;=|&gt;=|\\\\lte|\\\\lt|&lt;|\\\\gte|\\\\gt|&gt;|&amp;&amp;|\\\\and|-&gt;|->|==|!=|\\+=|-=|\\*=|\\/=|%=|\\+\\+|--|<=|&&|\\|\\||:|\\.\\.\\.|\\.\\.\\*|\\.\\.<|\\.\\.!|\\?\\?|=|<|\\+|-|\\*|\\/|%|\\||\\.\\.|\\?|!|&|\\.|,|;/,\n    arrows: [\"->\", \"-&gt;\"],\n    delimiters: [\";\", \":\", \",\", \".\"],\n    stringOperators: [\"lte\", \"lt\", \"gte\", \"gt\"],\n    noParseTags: [\"noparse\", \"noParse\", \"comment\"],\n    tokenizer: {\n      // Parser states\n      // Plain text\n      [s(\"default__id__\")]: [{\n        include: s(\"@directive_token__id__\")\n      }, {\n        include: s(\"@interpolation_and_text_token__id__\")\n      }],\n      // A FreeMarker expression inside a directive, e.g. <#if 2<3>\n      [s(\"fmExpression__id__.directive\")]: [{\n        include: s(\"@blank_and_expression_comment_token__id__\")\n      }, {\n        include: s(\"@directive_end_token__id__\")\n      }, {\n        include: s(\"@expression_token__id__\")\n      }],\n      // A FreeMarker expression inside an interpolation, e.g. ${2+3}\n      [s(\"fmExpression__id__.interpolation\")]: [{\n        include: s(\"@blank_and_expression_comment_token__id__\")\n      }, {\n        include: s(\"@expression_token__id__\")\n      }, {\n        include: s(\"@greater_operators_token__id__\")\n      }],\n      // In an expression and inside a not-yet closed parenthesis / bracket\n      [s(\"inParen__id__.plain\")]: [{\n        include: s(\"@blank_and_expression_comment_token__id__\")\n      }, {\n        include: s(\"@directive_end_token__id__\")\n      }, {\n        include: s(\"@expression_token__id__\")\n      }],\n      [s(\"inParen__id__.gt\")]: [{\n        include: s(\"@blank_and_expression_comment_token__id__\")\n      }, {\n        include: s(\"@expression_token__id__\")\n      }, {\n        include: s(\"@greater_operators_token__id__\")\n      }],\n      // Expression for the unified call, e.g. <@createMacro() ... >\n      [s(\"noSpaceExpression__id__\")]: [{\n        include: s(\"@no_space_expression_end_token__id__\")\n      }, {\n        include: s(\"@directive_end_token__id__\")\n      }, {\n        include: s(\"@expression_token__id__\")\n      }],\n      // For the function of a unified call. Special case for when the\n      // expression is a simple identifier.\n      // <@join [1,2] \",\">\n      // <@null!join [1,2] \",\">\n      [s(\"unifiedCall__id__\")]: [{\n        include: s(\"@unified_call_token__id__\")\n      }],\n      // For singly and doubly quoted string (that may contain interpolations)\n      [s(\"singleString__id__\")]: [{\n        include: s(\"@string_single_token__id__\")\n      }],\n      [s(\"doubleString__id__\")]: [{\n        include: s(\"@string_double_token__id__\")\n      }],\n      // For singly and doubly quoted string (that may not contain interpolations)\n      [s(\"rawSingleString__id__\")]: [{\n        include: s(\"@string_single_raw_token__id__\")\n      }],\n      [s(\"rawDoubleString__id__\")]: [{\n        include: s(\"@string_double_raw_token__id__\")\n      }],\n      // For a comment in an expression\n      // ${ 1 + <#-- comment --> 2}\n      [s(\"expressionComment__id__\")]: [{\n        include: s(\"@expression_comment_token__id__\")\n      }],\n      // For <#noparse> ... </#noparse>\n      // For <#noParse> ... </#noParse>\n      // For <#comment> ... </#comment>\n      [s(\"noParse__id__\")]: [{\n        include: s(\"@no_parse_token__id__\")\n      }],\n      // For <#-- ... -->\n      [s(\"terseComment__id__\")]: [{\n        include: s(\"@terse_comment_token__id__\")\n      }],\n      // Common rules\n      [s(\"directive_token__id__\")]: [\n      // <ATTEMPT : <START_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <RECOVER : <START_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <SEP : <START_TAG> \"sep\" <CLOSE_TAG1>>\n      // <AUTOESC : <START_TAG> \"auto\" (\"e\"|\"E\") \"sc\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n      // }\n      // <NOAUTOESC : <START_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n      // }\n      // <COMPRESS : <START_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <DEFAUL : <START_TAG> \"default\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <NOESCAPE : <START_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n      // }\n      //\n      // <COMMENT : <START_TAG> \"comment\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); noparseTag = \"comment\";\n      // }\n      // <NOPARSE: <START_TAG> \"no\" (\"p\" | \"P\") \"arse\" <CLOSE_TAG1>> {\n      //     int tagNamingConvention = getTagNamingConvention(matchedToken, 2);\n      //     handleTagSyntaxAndSwitch(matchedToken, tagNamingConvention, NO_PARSE);\n      //     noparseTag = tagNamingConvention == Configuration.CAMEL_CASE_NAMING_CONVENTION ? \"noParse\" : \"noparse\";\n      // }\n      [r(/(?:@startTag__id__)(@directiveStartCloseTag1)(?:@closeTag1__id__)/), ts.id === \"auto\" ? {\n        cases: {\n          \"$1==<\": {\n            token: \"@rematch\",\n            switchTo: `@default_angle_${is.id}`\n          },\n          \"$1==[\": {\n            token: \"@rematch\",\n            switchTo: `@default_bracket_${is.id}`\n          }\n        }\n      } : [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        cases: {\n          \"@noParseTags\": {\n            token: \"tag\",\n            next: s(\"@noParse__id__.$3\")\n          },\n          \"@default\": {\n            token: \"tag\"\n          }\n        }\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"@brackets.directive\"\n      }]],\n      // <ELSE : <START_TAG> \"else\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <BREAK : <START_TAG> \"break\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <CONTINUE : <START_TAG> \"continue\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <SIMPLE_RETURN : <START_TAG> \"return\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <HALT : <START_TAG> \"stop\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <FLUSH : <START_TAG> \"flush\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <TRIM : <START_TAG> \"t\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <LTRIM : <START_TAG> \"lt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <RTRIM : <START_TAG> \"rt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <NOTRIM : <START_TAG> \"nt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <SIMPLE_NESTED : <START_TAG> \"nested\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <SIMPLE_RECURSE : <START_TAG> \"recurse\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <FALLBACK : <START_TAG> \"fallback\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <TRIVIAL_FTL_HEADER : (\"<#ftl\" | \"[#ftl\") (\"/\")? (\">\" | \"]\")> { ftlHeader(matchedToken); }\n      [r(/(?:@startTag__id__)(@directiveStartCloseTag2)(?:@closeTag2__id__)/), ts.id === \"auto\" ? {\n        cases: {\n          \"$1==<\": {\n            token: \"@rematch\",\n            switchTo: `@default_angle_${is.id}`\n          },\n          \"$1==[\": {\n            token: \"@rematch\",\n            switchTo: `@default_bracket_${is.id}`\n          }\n        }\n      } : [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"tag\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"@brackets.directive\"\n      }]],\n      // <IF : <START_TAG> \"if\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <ELSE_IF : <START_TAG> \"else\" (\"i\" | \"I\") \"f\" <BLANK>> {\n      // \thandleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), FM_EXPRESSION);\n      // }\n      // <LIST : <START_TAG> \"list\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <FOREACH : <START_TAG> \"for\" (\"e\" | \"E\") \"ach\" <BLANK>> {\n      //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), FM_EXPRESSION);\n      // }\n      // <SWITCH : <START_TAG> \"switch\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <CASE : <START_TAG> \"case\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <ASSIGN : <START_TAG> \"assign\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <GLOBALASSIGN : <START_TAG> \"global\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <LOCALASSIGN : <START_TAG> \"local\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <_INCLUDE : <START_TAG> \"include\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <IMPORT : <START_TAG> \"import\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <FUNCTION : <START_TAG> \"function\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <MACRO : <START_TAG> \"macro\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <TRANSFORM : <START_TAG> \"transform\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <VISIT : <START_TAG> \"visit\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <STOP : <START_TAG> \"stop\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <RETURN : <START_TAG> \"return\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <CALL : <START_TAG> \"call\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <SETTING : <START_TAG> \"setting\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <OUTPUTFORMAT : <START_TAG> \"output\" (\"f\"|\"F\") \"ormat\" <BLANK>> {\n      //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), FM_EXPRESSION);\n      // }\n      // <NESTED : <START_TAG> \"nested\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <RECURSE : <START_TAG> \"recurse\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      // <ESCAPE : <START_TAG> \"escape\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      //\n      // Note: FreeMarker grammar appears to treat the FTL header as a special case,\n      // in order to remove new lines after the header (?), but since we only need\n      // to tokenize for highlighting, we can include this directive here.\n      // <FTL_HEADER : (\"<#ftl\" | \"[#ftl\") <BLANK>> { ftlHeader(matchedToken); }\n      //\n      // Note: FreeMarker grammar appears to treat the items directive as a special case for\n      // the AST parsing process, but since we only need to tokenize, we can include this\n      // directive here.\n      // <ITEMS : <START_TAG> \"items\" (<BLANK>)+ <AS> <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n      [r(/(?:@startTag__id__)(@directiveStartBlank)(@blank)/), ts.id === \"auto\" ? {\n        cases: {\n          \"$1==<\": {\n            token: \"@rematch\",\n            switchTo: `@default_angle_${is.id}`\n          },\n          \"$1==[\": {\n            token: \"@rematch\",\n            switchTo: `@default_bracket_${is.id}`\n          }\n        }\n      } : [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"tag\"\n      }, {\n        token: \"\",\n        next: s(\"@fmExpression__id__.directive\")\n      }]],\n      // <END_IF : <END_TAG> \"if\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_LIST : <END_TAG> \"list\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_SEP : <END_TAG> \"sep\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_RECOVER : <END_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_ATTEMPT : <END_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_FOREACH : <END_TAG> \"for\" (\"e\" | \"E\") \"ach\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), DEFAULT);\n      // }\n      // <END_LOCAL : <END_TAG> \"local\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_GLOBAL : <END_TAG> \"global\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_ASSIGN : <END_TAG> \"assign\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_FUNCTION : <END_TAG> \"function\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_MACRO : <END_TAG> \"macro\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_OUTPUTFORMAT : <END_TAG> \"output\" (\"f\" | \"F\") \"ormat\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), DEFAULT);\n      // }\n      // <END_AUTOESC : <END_TAG> \"auto\" (\"e\" | \"E\") \"sc\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n      // }\n      // <END_NOAUTOESC : <END_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n      //   handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n      // }\n      // <END_COMPRESS : <END_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_TRANSFORM : <END_TAG> \"transform\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_SWITCH : <END_TAG> \"switch\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_ESCAPE : <END_TAG> \"escape\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n      // <END_NOESCAPE : <END_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n      //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n      // }\n      [r(/(?:@endTag__id__)(@directiveEndCloseTag1)(?:@closeTag1__id__)/), ts.id === \"auto\" ? {\n        cases: {\n          \"$1==<\": {\n            token: \"@rematch\",\n            switchTo: `@default_angle_${is.id}`\n          },\n          \"$1==[\": {\n            token: \"@rematch\",\n            switchTo: `@default_bracket_${is.id}`\n          }\n        }\n      } : [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"tag\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"@brackets.directive\"\n      }]],\n      // <UNIFIED_CALL : \"<@\" | \"[@\" > { unifiedCall(matchedToken); }\n      [r(/(@open__id__)(@)/), ts.id === \"auto\" ? {\n        cases: {\n          \"$1==<\": {\n            token: \"@rematch\",\n            switchTo: `@default_angle_${is.id}`\n          },\n          \"$1==[\": {\n            token: \"@rematch\",\n            switchTo: `@default_bracket_${is.id}`\n          }\n        }\n      } : [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\",\n        next: s(\"@unifiedCall__id__\")\n      }]],\n      // <UNIFIED_CALL_END : (\"<\" | \"[\") \"/@\" ((<ID>) (\".\"<ID>)*)? <CLOSE_TAG1>> { unifiedCallEnd(matchedToken); }\n      [r(/(@open__id__)(\\/@)((?:(?:@id)(?:\\.(?:@id))*)?)(?:@closeTag1__id__)/), [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"tag\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"@brackets.directive\"\n      }]],\n      // <TERSE_COMMENT : (\"<\" | \"[\") \"#--\" > { noparseTag = \"-->\"; handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); }\n      [r(/(@open__id__)#--/), ts.id === \"auto\" ? {\n        cases: {\n          \"$1==<\": {\n            token: \"@rematch\",\n            switchTo: `@default_angle_${is.id}`\n          },\n          \"$1==[\": {\n            token: \"@rematch\",\n            switchTo: `@default_bracket_${is.id}`\n          }\n        }\n      } : {\n        token: \"comment\",\n        next: s(\"@terseComment__id__\")\n      }],\n      // <UNKNOWN_DIRECTIVE : (\"[#\" | \"[/#\" | \"<#\" | \"</#\") ([\"a\"-\"z\", \"A\"-\"Z\", \"_\"])+>\n      [r(/(?:@startOrEndTag__id__)([a-zA-Z_]+)/), ts.id === \"auto\" ? {\n        cases: {\n          \"$1==<\": {\n            token: \"@rematch\",\n            switchTo: `@default_angle_${is.id}`\n          },\n          \"$1==[\": {\n            token: \"@rematch\",\n            switchTo: `@default_bracket_${is.id}`\n          }\n        }\n      } : [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"tag.invalid\",\n        next: s(\"@fmExpression__id__.directive\")\n      }]]],\n      // <DEFAULT, NO_DIRECTIVE> TOKEN :\n      [s(\"interpolation_and_text_token__id__\")]: [\n      // <DOLLAR_INTERPOLATION_OPENING : \"${\"> { startInterpolation(matchedToken); }\n      // <SQUARE_BRACKET_INTERPOLATION_OPENING : \"[=\"> { startInterpolation(matchedToken); }\n      [r(/(@iOpen1__id__)(@iOpen2__id__)/), [{\n        token: is.id === \"bracket\" ? \"@brackets.interpolation\" : \"delimiter.interpolation\"\n      }, {\n        token: is.id === \"bracket\" ? \"delimiter.interpolation\" : \"@brackets.interpolation\",\n        next: s(\"@fmExpression__id__.interpolation\")\n      }]],\n      // <STATIC_TEXT_FALSE_ALARM : \"$\" | \"#\" | \"<\" | \"[\" | \"{\"> // to handle a lone dollar sign or \"<\" or \"# or <@ with whitespace after\"\n      // <STATIC_TEXT_WS : (\"\\n\" | \"\\r\" | \"\\t\" | \" \")+>\n      // <STATIC_TEXT_NON_WS : (~[\"$\", \"<\", \"#\", \"[\", \"{\", \"\\n\", \"\\r\", \"\\t\", \" \"])+>\n      [/[\\$#<\\[\\{]|(?:@blank)+|[^\\$<#\\[\\{\\n\\r\\t ]+/, {\n        token: \"source\"\n      }]],\n      // <STRING_LITERAL :\n      // \t(\n      // \t\t\"\\\"\"\n      // \t\t((~[\"\\\"\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"\\\"\"\n      // \t)\n      // \t|\n      // \t(\n      // \t\t\"'\"\n      // \t\t((~[\"'\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"'\"\n      // \t)\n      // >\n      [s(\"string_single_token__id__\")]: [[/[^'\\\\]/, {\n        token: \"string\"\n      }], [/@escapedChar/, {\n        token: \"string.escape\"\n      }], [/'/, {\n        token: \"string\",\n        next: \"@pop\"\n      }]],\n      [s(\"string_double_token__id__\")]: [[/[^\"\\\\]/, {\n        token: \"string\"\n      }], [/@escapedChar/, {\n        token: \"string.escape\"\n      }], [/\"/, {\n        token: \"string\",\n        next: \"@pop\"\n      }]],\n      // <RAW_STRING : \"r\" ((\"\\\"\" (~[\"\\\"\"])* \"\\\"\") | (\"'\" (~[\"'\"])* \"'\"))>\n      [s(\"string_single_raw_token__id__\")]: [[/[^']+/, {\n        token: \"string.raw\"\n      }], [/'/, {\n        token: \"string.raw\",\n        next: \"@pop\"\n      }]],\n      [s(\"string_double_raw_token__id__\")]: [[/[^\"]+/, {\n        token: \"string.raw\"\n      }], [/\"/, {\n        token: \"string.raw\",\n        next: \"@pop\"\n      }]],\n      // <FM_EXPRESSION, IN_PAREN, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"expression_token__id__\")]: [\n      // Strings\n      [/(r?)(['\"])/, {\n        cases: {\n          \"r'\": [{\n            token: \"keyword\"\n          }, {\n            token: \"string.raw\",\n            next: s(\"@rawSingleString__id__\")\n          }],\n          'r\"': [{\n            token: \"keyword\"\n          }, {\n            token: \"string.raw\",\n            next: s(\"@rawDoubleString__id__\")\n          }],\n          \"'\": [{\n            token: \"source\"\n          }, {\n            token: \"string\",\n            next: s(\"@singleString__id__\")\n          }],\n          '\"': [{\n            token: \"source\"\n          }, {\n            token: \"string\",\n            next: s(\"@doubleString__id__\")\n          }]\n        }\n      }],\n      // Numbers\n      // <INTEGER : ([\"0\"-\"9\"])+>\n      // <DECIMAL : <INTEGER> \".\" <INTEGER>>\n      [/(?:@integer)(?:\\.(?:@integer))?/, {\n        cases: {\n          \"(?:@integer)\": {\n            token: \"number\"\n          },\n          \"@default\": {\n            token: \"number.float\"\n          }\n        }\n      }],\n      // Special hash keys that must not be treated as identifiers\n      // after a period, e.g. a.** is accessing the key \"**\" of a\n      [/(\\.)(@blank*)(@specialHashKeys)/, [{\n        token: \"delimiter\"\n      }, {\n        token: \"\"\n      }, {\n        token: \"identifier\"\n      }]],\n      // Symbols / operators\n      [/(?:@namedSymbols)/, {\n        cases: {\n          \"@arrows\": {\n            token: \"meta.arrow\"\n          },\n          \"@delimiters\": {\n            token: \"delimiter\"\n          },\n          \"@default\": {\n            token: \"operators\"\n          }\n        }\n      }],\n      // Identifiers\n      [/@id/, {\n        cases: {\n          \"@keywords\": {\n            token: \"keyword.$0\"\n          },\n          \"@stringOperators\": {\n            token: \"operators\"\n          },\n          \"@default\": {\n            token: \"identifier\"\n          }\n        }\n      }],\n      // <OPEN_BRACKET : \"[\">\n      // <CLOSE_BRACKET : \"]\">\n      // <OPEN_PAREN : \"(\">\n      // <CLOSE_PAREN : \")\">\n      // <OPENING_CURLY_BRACKET : \"{\">\n      // <CLOSING_CURLY_BRACKET : \"}\">\n      [/[\\[\\]\\(\\)\\{\\}]/, {\n        cases: {\n          \"\\\\[\": {\n            cases: {\n              \"$S2==gt\": {\n                token: \"@brackets\",\n                next: s(\"@inParen__id__.gt\")\n              },\n              \"@default\": {\n                token: \"@brackets\",\n                next: s(\"@inParen__id__.plain\")\n              }\n            }\n          },\n          \"\\\\]\": {\n            cases: {\n              ...(is.id === \"bracket\" ? {\n                \"$S2==interpolation\": {\n                  token: \"@brackets.interpolation\",\n                  next: \"@popall\"\n                }\n              } : {}),\n              // This cannot happen while in auto mode, since this applies only to an\n              // fmExpression inside a directive. But once we encounter the start of a\n              // directive, we can establish the tag syntax mode.\n              ...(ts.id === \"bracket\" ? {\n                \"$S2==directive\": {\n                  token: \"@brackets.directive\",\n                  next: \"@popall\"\n                }\n              } : {}),\n              // Ignore mismatched paren\n              [s(\"$S1==inParen__id__\")]: {\n                token: \"@brackets\",\n                next: \"@pop\"\n              },\n              \"@default\": {\n                token: \"@brackets\"\n              }\n            }\n          },\n          \"\\\\(\": {\n            token: \"@brackets\",\n            next: s(\"@inParen__id__.gt\")\n          },\n          \"\\\\)\": {\n            cases: {\n              [s(\"$S1==inParen__id__\")]: {\n                token: \"@brackets\",\n                next: \"@pop\"\n              },\n              \"@default\": {\n                token: \"@brackets\"\n              }\n            }\n          },\n          \"\\\\{\": {\n            cases: {\n              \"$S2==gt\": {\n                token: \"@brackets\",\n                next: s(\"@inParen__id__.gt\")\n              },\n              \"@default\": {\n                token: \"@brackets\",\n                next: s(\"@inParen__id__.plain\")\n              }\n            }\n          },\n          \"\\\\}\": {\n            cases: {\n              ...(is.id === \"bracket\" ? {} : {\n                \"$S2==interpolation\": {\n                  token: \"@brackets.interpolation\",\n                  next: \"@popall\"\n                }\n              }),\n              // Ignore mismatched paren\n              [s(\"$S1==inParen__id__\")]: {\n                token: \"@brackets\",\n                next: \"@pop\"\n              },\n              \"@default\": {\n                token: \"@brackets\"\n              }\n            }\n          }\n        }\n      }],\n      // <OPEN_MISPLACED_INTERPOLATION : \"${\" | \"#{\" | \"[=\">\n      [/\\$\\{/, {\n        token: \"delimiter.invalid\"\n      }]],\n      // <FM_EXPRESSION, IN_PAREN, NAMED_PARAMETER_EXPRESSION> SKIP :\n      [s(\"blank_and_expression_comment_token__id__\")]: [\n      // < ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )+ >\n      [/(?:@blank)+/, {\n        token: \"\"\n      }],\n      // < (\"<\" | \"[\") (\"#\" | \"!\") \"--\"> : EXPRESSION_COMMENT\n      [/[<\\[][#!]--/, {\n        token: \"comment\",\n        next: s(\"@expressionComment__id__\")\n      }]],\n      // <FM_EXPRESSION, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"directive_end_token__id__\")]: [\n      // <DIRECTIVE_END : \">\">\n      // {\n      //     if (inFTLHeader) {\n      //         eatNewline();\n      //         inFTLHeader = false;\n      //     }\n      //     if (squBracTagSyntax || postInterpolationLexState != -1 /* We are in an interpolation */) {\n      //         matchedToken.kind = NATURAL_GT;\n      //     } else {\n      //         SwitchTo(DEFAULT);\n      //     }\n      // }\n      // This cannot happen while in auto mode, since this applies only to an\n      // fmExpression inside a directive. But once we encounter the start of a\n      // directive, we can establish the tag syntax mode.\n      [/>/, ts.id === \"bracket\" ? {\n        token: \"operators\"\n      } : {\n        token: \"@brackets.directive\",\n        next: \"@popall\"\n      }],\n      // <EMPTY_DIRECTIVE_END : \"/>\" | \"/]\">\n      // It is a syntax error to end a tag with the wrong close token\n      // Let's indicate that to the user by not closing the tag\n      [r(/(\\/)(@close__id__)/), [{\n        token: \"delimiter.directive\"\n      }, {\n        token: \"@brackets.directive\",\n        next: \"@popall\"\n      }]]],\n      // <IN_PAREN> TOKEN :\n      [s(\"greater_operators_token__id__\")]: [\n      // <NATURAL_GT : \">\">\n      [/>/, {\n        token: \"operators\"\n      }],\n      // <NATURAL_GTE : \">=\">\n      [/>=/, {\n        token: \"operators\"\n      }]],\n      // <NO_SPACE_EXPRESSION> TOKEN :\n      [s(\"no_space_expression_end_token__id__\")]: [\n      // <TERMINATING_WHITESPACE :  ([\"\\n\", \"\\r\", \"\\t\", \" \"])+> : FM_EXPRESSION\n      [/(?:@blank)+/, {\n        token: \"\",\n        switchTo: s(\"@fmExpression__id__.directive\")\n      }]],\n      [s(\"unified_call_token__id__\")]: [\n      // Special case for a call where the expression is just an ID\n      // <UNIFIED_CALL> <ID> <BLANK>+\n      [/(@id)((?:@blank)+)/, [{\n        token: \"tag\"\n      }, {\n        token: \"\",\n        next: s(\"@fmExpression__id__.directive\")\n      }]], [r(/(@id)(\\/?)(@close__id__)/), [{\n        token: \"tag\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"@brackets.directive\",\n        next: \"@popall\"\n      }]], [/./, {\n        token: \"@rematch\",\n        next: s(\"@noSpaceExpression__id__\")\n      }]],\n      // <NO_PARSE> TOKEN :\n      [s(\"no_parse_token__id__\")]: [\n      // <MAYBE_END :\n      // \t (\"<\" | \"[\")\n      // \t \"/\"\n      // \t (\"#\")?\n      // \t ([\"a\"-\"z\", \"A\"-\"Z\"])+\n      // \t ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )*\n      // \t (\">\" | \"]\")\n      // >\n      [r(/(@open__id__)(\\/#?)([a-zA-Z]+)((?:@blank)*)(@close__id__)/), {\n        cases: {\n          \"$S2==$3\": [{\n            token: \"@brackets.directive\"\n          }, {\n            token: \"delimiter.directive\"\n          }, {\n            token: \"tag\"\n          }, {\n            token: \"\"\n          }, {\n            token: \"@brackets.directive\",\n            next: \"@popall\"\n          }],\n          \"$S2==comment\": [{\n            token: \"comment\"\n          }, {\n            token: \"comment\"\n          }, {\n            token: \"comment\"\n          }, {\n            token: \"comment\"\n          }, {\n            token: \"comment\"\n          }],\n          \"@default\": [{\n            token: \"source\"\n          }, {\n            token: \"source\"\n          }, {\n            token: \"source\"\n          }, {\n            token: \"source\"\n          }, {\n            token: \"source\"\n          }]\n        }\n      }],\n      // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n      // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n      [/[^<\\[\\-]+|[<\\[\\-]/, {\n        cases: {\n          \"$S2==comment\": {\n            token: \"comment\"\n          },\n          \"@default\": {\n            token: \"source\"\n          }\n        }\n      }]],\n      // <EXPRESSION_COMMENT> SKIP:\n      [s(\"expression_comment_token__id__\")]: [\n      // < \"-->\" | \"--]\">\n      [/--[>\\]]/, {\n        token: \"comment\",\n        next: \"@pop\"\n      }],\n      // < (~[\"-\", \">\", \"]\"])+ >\n      // < \">\">\n      // < \"]\">\n      // < \"-\">\n      [/[^\\->\\]]+|[>\\]\\-]/, {\n        token: \"comment\"\n      }]],\n      [s(\"terse_comment_token__id__\")]: [\n      //  <TERSE_COMMENT_END : \"-->\" | \"--]\">\n      [r(/--(?:@close__id__)/), {\n        token: \"comment\",\n        next: \"@popall\"\n      }],\n      // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n      // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n      [/[^<\\[\\-]+|[<\\[\\-]/, {\n        token: \"comment\"\n      }]]\n    }\n  };\n}\nfunction createMonarchLanguageAuto(is) {\n  const angle = createMonarchLanguage(TagSyntaxAngle, is);\n  const bracket = createMonarchLanguage(TagSyntaxBracket, is);\n  const auto = createMonarchLanguage(TagSyntaxAuto, is);\n  return {\n    // Angle and bracket syntax mode\n    // We switch to one of these once we have determined the mode\n    ...angle,\n    ...bracket,\n    ...auto,\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: `default_auto_${is.id}`,\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [{\n      open: \"{\",\n      close: \"}\",\n      token: \"delimiter.curly\"\n    }, {\n      open: \"[\",\n      close: \"]\",\n      token: \"delimiter.square\"\n    }, {\n      open: \"(\",\n      close: \")\",\n      token: \"delimiter.parenthesis\"\n    }, {\n      open: \"<\",\n      close: \">\",\n      token: \"delimiter.angle\"\n    }],\n    tokenizer: {\n      ...angle.tokenizer,\n      ...bracket.tokenizer,\n      ...auto.tokenizer\n    }\n  };\n}\nvar TagAngleInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxDollar)\n};\nvar TagBracketInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxDollar)\n};\nvar TagAngleInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxBracket)\n};\nvar TagBracketInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxBracket)\n};\nvar TagAutoInterpolationDollar = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxDollar)\n};\nvar TagAutoInterpolationBracket = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxBracket)\n};\nexport { TagAngleInterpolationBracket, TagAngleInterpolationDollar, TagAutoInterpolationBracket, TagAutoInterpolationDollar, TagBracketInterpolationBracket, TagBracketInterpolationDollar };"],"mappings":"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","names":["__defProp","__getOwnPropDesc","__getOwnPropNames","__hasOwnProp","__copyProps","to","from","except","desc","key","__reExport","target","mod","secondTarget","monaco_editor_core_exports","editor_api_exports","EMPTY_ELEMENTS","BLOCK_ELEMENTS","TagSyntaxAngle","TagSyntaxBracket","TagSyntaxAuto","InterpolationSyntaxDollar","InterpolationSyntaxBracket","createLangConfiguration","ts","createLangConfigurationAuto","createMonarchLanguage","is","id","s","name","r","regexp","source","__spreadProps","__spreadValues","createMonarchLanguageAuto","angle","bracket","auto","TagAngleInterpolationDollar","TagBracketInterpolationDollar","TagAngleInterpolationBracket","TagBracketInterpolationBracket","TagAutoInterpolationDollar","TagAutoInterpolationBracket"],"x_google_ignoreList":[0]}