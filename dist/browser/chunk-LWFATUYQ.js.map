{
  "version": 3,
  "sources": ["src/main/webapp/app/entities/faq-category.model.ts", "src/main/webapp/app/faq/faq.service.ts", "src/main/webapp/app/entities/faq.model.ts"],
  "sourcesContent": ["export class FaqCategory {\r\n    public color?: string;\r\n\r\n    public category?: string;\r\n\r\n    constructor(category: string | undefined, color: string | undefined) {\r\n        this.color = color;\r\n        this.category = category;\r\n    }\r\n\r\n    equals(otherFaqCategory: FaqCategory): boolean {\r\n        return this.color === otherFaqCategory.color && this.category === otherFaqCategory.category;\r\n    }\r\n\r\n    /**\r\n     * @param otherFaqCategory\r\n     * @returns the alphanumerical order of the two categories based on their display text\r\n     */\r\n    compare(otherFaqCategory: FaqCategory): number {\r\n        if (this.category === otherFaqCategory.category) {\r\n            return 0;\r\n        }\r\n\r\n        const displayText = this.category?.toLowerCase() ?? '';\r\n        const otherCategoryDisplayText = otherFaqCategory.category?.toLowerCase() ?? '';\r\n\r\n        return displayText < otherCategoryDisplayText ? -1 : 1;\r\n    }\r\n}\r\n", "import { Injectable, inject } from '@angular/core';\r\nimport { HttpClient, HttpParams, HttpResponse } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\nimport { Faq, FaqState } from 'app/entities/faq.model';\r\nimport { FaqCategory } from 'app/entities/faq-category.model';\r\n\r\ntype EntityResponseType = HttpResponse<Faq>;\r\ntype EntityArrayResponseType = HttpResponse<Faq[]>;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class FaqService {\r\n    public resourceUrl = 'api/communication/courses';\r\n\r\n    private http = inject(HttpClient);\r\n\r\n    create(courseId: number, faq: Faq): Observable<EntityResponseType> {\r\n        const copy = FaqService.convertFaqFromClient(faq);\r\n        return this.http.post<Faq>(`${this.resourceUrl}/${courseId}/faqs`, copy, { observe: 'response' }).pipe(\r\n            map((res: EntityResponseType) => {\r\n                return res;\r\n            }),\r\n        );\r\n    }\r\n\r\n    update(courseId: number, faq: Faq): Observable<EntityResponseType> {\r\n        const copy = FaqService.convertFaqFromClient(faq);\r\n        return this.http.put<Faq>(`${this.resourceUrl}/${courseId}/faqs/${faq.id}`, copy, { observe: 'response' }).pipe(\r\n            map((res: EntityResponseType) => {\r\n                return res;\r\n            }),\r\n        );\r\n    }\r\n\r\n    find(courseId: number, faqId: number): Observable<EntityResponseType> {\r\n        return this.http\r\n            .get<Faq>(`${this.resourceUrl}/${courseId}/faqs/${faqId}`, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => FaqService.convertFaqCategoriesFromServer(res)));\r\n    }\r\n\r\n    findAllByCourseId(courseId: number): Observable<EntityArrayResponseType> {\r\n        return this.http\r\n            .get<Faq[]>(`${this.resourceUrl}/${courseId}/faqs`, {\r\n                observe: 'response',\r\n            })\r\n            .pipe(map((res: EntityArrayResponseType) => FaqService.convertFaqCategoryArrayFromServer(res)));\r\n    }\r\n\r\n    findAllByCourseIdAndState(courseId: number, faqState: FaqState): Observable<EntityArrayResponseType> {\r\n        return this.http\r\n            .get<Faq[]>(`${this.resourceUrl}/${courseId}/faq-state/${faqState}`, {\r\n                observe: 'response',\r\n            })\r\n            .pipe(map((res: EntityArrayResponseType) => FaqService.convertFaqCategoryArrayFromServer(res)));\r\n    }\r\n\r\n    delete(courseId: number, faqId: number): Observable<HttpResponse<any>> {\r\n        return this.http.delete<any>(`${this.resourceUrl}/${courseId}/faqs/${faqId}`, { observe: 'response' });\r\n    }\r\n\r\n    findAllCategoriesByCourseId(courseId: number) {\r\n        return this.http.get<string[]>(`${this.resourceUrl}/${courseId}/faq-categories`, {\r\n            observe: 'response',\r\n        });\r\n    }\r\n    /**\r\n     * Converts the faq category json string into FaqCategory objects (if it exists).\r\n     * @param res the response\r\n     */\r\n    static convertFaqCategoriesFromServer<ERT extends EntityResponseType>(res: ERT): ERT {\r\n        if (res.body?.categories) {\r\n            FaqService.parseFaqCategories(res.body);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Converts a faqs categories into a json string (to send them to the server). Does nothing if no categories exist\r\n     * @param faq the faq\r\n     */\r\n    static stringifyFaqCategories(faq: Faq) {\r\n        return faq.categories?.map((category) => JSON.stringify(category) as unknown as FaqCategory);\r\n    }\r\n\r\n    convertFaqCategoriesAsStringFromServer(categories: string[]): FaqCategory[] {\r\n        return categories.map((category) => JSON.parse(category));\r\n    }\r\n\r\n    /**\r\n     * Converts the faq category json strings into FaqCategory objects (if it exists).\r\n     * @param res the response\r\n     */\r\n    static convertFaqCategoryArrayFromServer<E extends Faq, EART extends EntityArrayResponseType>(res: EART): EART {\r\n        if (res.body) {\r\n            res.body.forEach((faq: E) => FaqService.parseFaqCategories(faq));\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Parses the faq categories JSON string into {@link FaqCategory} objects.\r\n     * @param faq - the faq\r\n     */\r\n    static parseFaqCategories(faq?: Faq) {\r\n        if (faq?.categories) {\r\n            faq.categories = faq.categories.map((category) => {\r\n                const categoryObj = JSON.parse(category as unknown as string);\r\n                return new FaqCategory(categoryObj.category, categoryObj.color);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepare client-faq to be uploaded to the server\r\n     * @param { Faq } faq - faq that will be modified\r\n     */\r\n    static convertFaqFromClient<F extends Faq>(faq: F): Faq {\r\n        const copy = Object.assign({}, faq);\r\n        copy.categories = FaqService.stringifyFaqCategories(copy);\r\n        return copy;\r\n    }\r\n\r\n    toggleFilter(category: string, activeFilters: Set<string>) {\r\n        if (activeFilters.has(category)) {\r\n            activeFilters.delete(category);\r\n        } else {\r\n            activeFilters.add(category);\r\n        }\r\n        return activeFilters;\r\n    }\r\n\r\n    applyFilters(activeFilters: Set<string>, faqs: Faq[]): Faq[] {\r\n        if (activeFilters.size === 0) {\r\n            // If no filters selected, show all faqs\r\n            return faqs;\r\n        } else {\r\n            return faqs.filter((faq) => this.hasFilteredCategory(faq, activeFilters));\r\n        }\r\n    }\r\n\r\n    hasFilteredCategory(faq: Faq, filteredCategory: Set<string>) {\r\n        const categories = faq.categories?.map((category) => category.category);\r\n        if (categories) {\r\n            return categories.some((category) => filteredCategory.has(category!));\r\n        }\r\n    }\r\n\r\n    hasSearchTokens(faq: Faq, searchTerm: string): boolean {\r\n        if (searchTerm === '') {\r\n            return true;\r\n        }\r\n        const tokens = searchTerm.toLowerCase().split(' ');\r\n        const faqText = `${faq.questionTitle ?? ''} ${faq.questionAnswer ?? ''}`.toLowerCase();\r\n        return tokens.every((token) => faqText.includes(token));\r\n    }\r\n\r\n    findAllCategoriesByCourseIdAndCategory(courseId: number, faqState: FaqState) {\r\n        return this.http.get<string[]>(`${this.resourceUrl}/${courseId}/faq-categories/${faqState}`, {\r\n            observe: 'response',\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Trigger the Ingestion of all Faqs in the course.\r\n     */\r\n    ingestFaqsInPyris(courseId: number): Observable<HttpResponse<void>> {\r\n        const params = new HttpParams();\r\n        return this.http.post<void>(`api/communication/courses/${courseId}/faqs/ingest`, null, {\r\n            params: params,\r\n            observe: 'response',\r\n        });\r\n    }\r\n}\r\n", "import { BaseEntity } from 'app/shared/model/base-entity';\r\nimport { Course } from 'app/entities/course.model';\r\nimport { FaqCategory } from './faq-category.model';\r\n\r\nexport enum FaqState {\r\n    ACCEPTED = 'ACCEPTED',\r\n    REJECTED = 'REJECTED',\r\n    PROPOSED = 'PROPOSED',\r\n}\r\n\r\nexport class Faq implements BaseEntity {\r\n    public id?: number;\r\n    public questionTitle?: string;\r\n    public questionAnswer?: string;\r\n    public faqState?: FaqState;\r\n    public course?: Course;\r\n    public categories?: FaqCategory[];\r\n}\r\n"],
  "mappings": "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",
  "names": ["FaqCategory", "color", "category", "constructor", "equals", "otherFaqCategory", "compare", "displayText", "toLowerCase", "otherCategoryDisplayText", "FaqService", "resourceUrl", "http", "inject", "HttpClient", "create", "courseId", "faq", "copy", "convertFaqFromClient", "post", "observe", "pipe", "map", "res", "update", "put", "id", "find", "faqId", "get", "convertFaqCategoriesFromServer", "findAllByCourseId", "convertFaqCategoryArrayFromServer", "findAllByCourseIdAndState", "faqState", "delete", "findAllCategoriesByCourseId", "body", "categories", "parseFaqCategories", "stringifyFaqCategories", "category", "JSON", "stringify", "convertFaqCategoriesAsStringFromServer", "parse", "forEach", "categoryObj", "FaqCategory", "color", "Object", "assign", "toggleFilter", "activeFilters", "has", "add", "applyFilters", "faqs", "size", "filter", "hasFilteredCategory", "filteredCategory", "some", "hasSearchTokens", "searchTerm", "tokens", "toLowerCase", "split", "faqText", "questionTitle", "questionAnswer", "every", "token", "includes", "findAllCategoriesByCourseIdAndCategory", "ingestFaqsInPyris", "params", "HttpParams", "factory", "\u0275fac", "providedIn", "FaqState", "Faq", "id", "questionTitle", "questionAnswer", "faqState", "course", "categories"]
}
