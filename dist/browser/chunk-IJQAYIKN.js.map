{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/quiz/shared/short-answer-question-util.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\r\nimport { ShortAnswerQuestion } from 'app/entities/quiz/short-answer-question.model';\r\nimport { ShortAnswerMapping } from 'app/entities/quiz/short-answer-mapping.model';\r\nimport { ShortAnswerSpot } from 'app/entities/quiz/short-answer-spot.model';\r\nimport { ShortAnswerSolution } from 'app/entities/quiz/short-answer-solution.model';\r\nimport { cloneDeep } from 'lodash-es';\r\nimport { htmlForMarkdown } from 'app/shared/util/markdown.conversion.util';\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ShortAnswerQuestionUtil {\r\n    /**\r\n     * Validate that no mapping exists that makes it impossible to solve the question.\r\n     * We iterate through all spots and remove all possible mappings (solutions) for that spot.\r\n     * If there are still mappings (solutions) left for the other spots everything is ok.\r\n     * In case we have multiple mappings for spots, we check whether there are an equal or greater amount of mappings than spots.\r\n     *\r\n     * @param question {object} the question to check\r\n     * @return {boolean} true, if the condition is met, otherwise false\r\n     */\r\n\r\n    validateNoMisleadingShortAnswerMapping(question: ShortAnswerQuestion) {\r\n        if (!question.correctMappings) {\r\n            // no correct mappings at all means there can be no misleading mappings\r\n            return true;\r\n        }\r\n\r\n        let unusedMappings: ShortAnswerMapping[] = cloneDeep(question.correctMappings);\r\n        const spotsCanBeSolved: boolean[] = [];\r\n\r\n        for (const spot of question.spots!) {\r\n            let atLeastOneMapping = false;\r\n            const solutionsForSpots = this.getAllSolutionsForSpot(question.correctMappings, spot)!;\r\n\r\n            solutionsForSpots.forEach((solution) => {\r\n                if (unusedMappings.length > 0 && unusedMappings.length !== question.correctMappings!.length) {\r\n                    atLeastOneMapping = true;\r\n                }\r\n                // unusedMappings.length > 0 will be always true for the first iteration, therefore we need a special check\r\n                if (unusedMappings.length === question.correctMappings!.length) {\r\n                    // We need to verify if the first spot has mappings (solutions) that is only for itself\r\n                    // In case there are multiple mappings (solutions) for spots, we use hasSpotEnoughSolutions\r\n                    const allSolutionsForSpot = this.getAllSolutionsForSpot(question.correctMappings, spot)!;\r\n                    const allSolutionsOnlyForSpot = allSolutionsForSpot.filter(\r\n                        (solutionForSpot) => this.getAllSpotsForSolutions(question.correctMappings, solutionForSpot)!.length === 1,\r\n                    );\r\n\r\n                    if (allSolutionsOnlyForSpot.length > 0) {\r\n                        atLeastOneMapping = true;\r\n                    }\r\n                }\r\n                // Remove every solution for a spot in the mapping\r\n                unusedMappings = unusedMappings.filter((mapping) => !this.isSameSolution(solution, mapping.solution));\r\n            });\r\n\r\n            // In case there are multiple mappings for the spots there have to be at least as many solutions as spots\r\n            const hasSpotEnoughSolutions = this.getAllSolutionsForSpot(question.correctMappings, spot)!.length >= question.spots!.length;\r\n            // Check whether a mapping is still left to solve a spot correctly.\r\n            if (atLeastOneMapping || hasSpotEnoughSolutions) {\r\n                spotsCanBeSolved.push(true);\r\n            } else {\r\n                spotsCanBeSolved.push(false);\r\n            }\r\n        }\r\n        return !spotsCanBeSolved.includes(false);\r\n    }\r\n\r\n    /**\r\n     * Check if the given solution and spot are mapped together in the given mappings\r\n     *\r\n     * @param mappings {Array} the existing mappings to consider\r\n     * @param solution {object} the solution to search for\r\n     * @param spot {object} the spot to search for\r\n     * @return {boolean} true if they are mapped together, otherwise false\r\n     */\r\n    isMappedTogether(mappings?: ShortAnswerMapping[], solution?: ShortAnswerSolution, spot?: ShortAnswerSpot) {\r\n        return !!this.getShortAnswerMapping(mappings, solution, spot);\r\n    }\r\n\r\n    /**\r\n     * Get all spots that are mapped to the given solutions\r\n     *\r\n     * @param mappings {Array} the existing mappings to consider\r\n     * @param solution {object} the solution that the returned spots have to be mapped to\r\n     * @return {Array} the resulting spots\r\n     */\r\n    getAllSpotsForSolutions(mappings?: ShortAnswerMapping[], solution?: ShortAnswerSolution) {\r\n        return mappings\r\n            ?.filter(function (mapping) {\r\n                return this.isSameSolution(mapping.solution, solution);\r\n            }, this)\r\n            .map(function (mapping) {\r\n                return mapping.spot!;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Get all solutions that are mapped to the given spot\r\n     *\r\n     * @param mappings {Array} the existing mappings to consider\r\n     * @param spot {object} the spot for which to get the solutions\r\n     * @return {Array} the resulting solutions\r\n     */\r\n    getAllSolutionsForSpot(mappings?: ShortAnswerMapping[], spot?: ShortAnswerSpot) {\r\n        return mappings\r\n            ?.filter((mapping) => {\r\n                return this.isSameSpot(mapping.spot, spot);\r\n            }, this)\r\n            .map((mapping) => {\r\n                return mapping.solution!;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Check if set1 and set2 contain the same solutions or spots\r\n     *\r\n     * @param set1 {Array} one set of solutions or spots\r\n     * @param set2 {Array} another set of solutions or spots\r\n     * @return {boolean} true if the sets contain the same items, otherwise false\r\n     */\r\n    isSameSetOfSpots(set1?: ShortAnswerSpot[], set2?: ShortAnswerSpot[]) {\r\n        if (set1?.length !== set2?.length) {\r\n            // different number of elements => impossible to contain the same elements\r\n            return false;\r\n        }\r\n        return (\r\n            // for every element in set1 there has to be an identical element in set2 and vice versa\r\n            set1?.every((spot1) => {\r\n                return set2?.some((spot2) => {\r\n                    return this.isSameSpot(spot1, spot2);\r\n                });\r\n            }) &&\r\n            set2?.every((spot2) => {\r\n                return set1?.some((spot1) => {\r\n                    return this.isSameSpot(spot1, spot2);\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the mapping that maps the given solution and spot together\r\n     *\r\n     * @param mappings {Array} the existing mappings to consider\r\n     * @param solution {object} the solution to search for\r\n     * @param spot {object} the spot to search for\r\n     * @return the found mapping, or undefined if it doesn't exist\r\n     */\r\n    getShortAnswerMapping(mappings?: ShortAnswerMapping[], solution?: ShortAnswerSolution, spot?: ShortAnswerSpot) {\r\n        return mappings?.find((mapping: ShortAnswerMapping) => {\r\n            return this.isSameSpot(spot, mapping.spot) && this.isSameSolution(solution, mapping.solution);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * compare if the two objects are the same spot\r\n     *\r\n     * @param a {object} a spot\r\n     * @param b {object} another spot\r\n     * @return {boolean}\r\n     */\r\n    isSameSpot(a?: ShortAnswerSpot, b?: ShortAnswerSpot): boolean {\r\n        return a === b || (a !== undefined && b !== undefined && ((a.id && b.id && a.id === b.id) || (a.tempID != undefined && b.tempID != undefined && a.tempID === b.tempID)));\r\n    }\r\n\r\n    /**\r\n     * compare if the two objects are the same solution\r\n     *\r\n     * @param a {object} a solution\r\n     * @param b {object} another solution\r\n     * @return {boolean}\r\n     */\r\n    isSameSolution(a?: ShortAnswerSolution, b?: ShortAnswerSolution): boolean {\r\n        return a === b || (a !== undefined && b !== undefined && ((a.id && b.id && a.id === b.id) || (a.tempID != undefined && b.tempID != undefined && a.tempID === b.tempID)));\r\n    }\r\n\r\n    /**\r\n     * checks if every spot has a solution\r\n     *\r\n     * @param mappings {object} mappings\r\n     * @param spots {object} spots\r\n     * @return {boolean}\r\n     */\r\n    everySpotHasASolution(mappings: ShortAnswerMapping[], spots: ShortAnswerSpot[]): boolean {\r\n        let i = 0;\r\n        for (const spot of spots) {\r\n            const solutions = this.getAllSolutionsForSpot(mappings, spot);\r\n            if (solutions && solutions.length > 0) {\r\n                i++;\r\n            }\r\n        }\r\n        return i === spots.length;\r\n    }\r\n\r\n    /**\r\n     * checks if every mapped solution has a spot\r\n     *\r\n     * @param mappings {object} mappings\r\n     * @return {boolean}\r\n     */\r\n    everyMappedSolutionHasASpot(mappings: ShortAnswerMapping[]): boolean {\r\n        return !(mappings.filter((mapping) => mapping.spot === undefined).length > 0);\r\n    }\r\n\r\n    /**\r\n     * checks if mappings have duplicate values\r\n     *\r\n     * @param mappings\r\n     * @return {boolean}\r\n     */\r\n    hasMappingDuplicateValues(mappings: ShortAnswerMapping[]): boolean {\r\n        if (mappings.filter((mapping) => mapping.spot === undefined).length > 0) {\r\n            return false;\r\n        }\r\n        let duplicateValues = 0;\r\n        for (let i = 0; i < mappings.length - 1; i++) {\r\n            for (let j = i + 1; j < mappings.length; j++) {\r\n                if (mappings[i].spot!.spotNr === mappings[j].spot!.spotNr && mappings[i].solution!.text! === mappings[j].solution!.text!) {\r\n                    duplicateValues++;\r\n                }\r\n            }\r\n        }\r\n        return duplicateValues > 0;\r\n    }\r\n\r\n    /**\r\n     * Display a sample solution instead of the student's answer\r\n     *\r\n     * @param {ShortAnswerQuestion} question\r\n     * @returns {ShortAnswerSolution[]}\r\n     */\r\n    getSampleSolutions(question: ShortAnswerQuestion): ShortAnswerSolution[] {\r\n        const sampleSolutions: ShortAnswerSolution[] = [];\r\n        for (const spot of question.spots!) {\r\n            const solutionsForSpot = this.getAllSolutionsForSpot(question.correctMappings!, spot);\r\n            for (const mapping of question.correctMappings!) {\r\n                if (\r\n                    mapping.spot!.id === spot.id &&\r\n                    !sampleSolutions.some(\r\n                        (sampleSolution) => sampleSolution.text === mapping.solution!.text && !this.allSolutionsAreInSampleSolution(solutionsForSpot, sampleSolutions),\r\n                    )\r\n                ) {\r\n                    sampleSolutions.push(mapping.solution!);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampleSolutions;\r\n    }\r\n\r\n    /**\r\n     * checks if all solutions are in the sample solution\r\n     *\r\n     * @param {ShortAnswerSolution[]} solutionsForSpot\r\n     * @param {ShortAnswerSolution[]} sampleSolutions\r\n     * @returns {boolean}\r\n     */\r\n    allSolutionsAreInSampleSolution(solutionsForSpot?: ShortAnswerSolution[], sampleSolutions?: ShortAnswerSolution[]): boolean {\r\n        let i = 0;\r\n        for (const solutionForSpot of solutionsForSpot || []) {\r\n            for (const sampleSolution of sampleSolutions || []) {\r\n                if (solutionForSpot.text === sampleSolution.text) {\r\n                    i++;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return i === solutionsForSpot?.length;\r\n    }\r\n\r\n    /**\r\n     * checks if at least there are as many solutions as spots\r\n     *\r\n     * @param {ShortAnswerQuestion} question\r\n     * @returns {boolean}\r\n     */\r\n    atLeastAsManySolutionsAsSpots(question: ShortAnswerQuestion): boolean {\r\n        return question.spots!.length <= question.solutions!.length;\r\n    }\r\n\r\n    /**\r\n     * We create now the structure on how to display the text of the question\r\n     * 1. The question text is split at every new line. The first element of the array would be then the first line of the question text.\r\n     * 2. Now each line of the question text will be divided into text before spot tag, spot tag and text after spot tag.\r\n     * (e.g 'Enter [-spot 1] long [-spot 2] if needed' will be transformed to [[\"Enter\", \"[-spot 1]\", \"long\", \"[-spot 2]\", \"if needed\"]])\r\n     *\r\n     * @param questionText\r\n     * @returns {string[][]}\r\n     */\r\n    divideQuestionTextIntoTextParts(questionText: string): string[][] {\r\n        const spotRegExpo = /\\[-spot\\s*[0-9]+\\]/g;\r\n\r\n        /**\r\n         * Interleaves elements of two lists xs and ys recursively\r\n         * @param x First element\r\n         * @param xs Rest of the list\r\n         * @param ys Other list\r\n         */\r\n        function interleave([x, ...xs]: string[], ys: string[] = []): string[] {\r\n            return x === undefined\r\n                ? ys // base: no x\r\n                : [x, ...interleave(ys, xs)]; // inductive: some x\r\n        }\r\n\r\n        return questionText.split(/\\n/g).map((line) => {\r\n            const spots = line.match(spotRegExpo) || [];\r\n            const texts = line.split(spotRegExpo).map((text) => text.trim());\r\n            return interleave(texts, spots).filter((x) => x.length > 0);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * checks if text is an input field (check for spot tag)\r\n     * @param text\r\n     */\r\n    isInputField(text: string): boolean {\r\n        return !(text.search(/\\[-spot/g) === -1);\r\n    }\r\n\r\n    /**\r\n     * gets just the spot number\r\n     * @param text\r\n     */\r\n    getSpotNr(text: string): number {\r\n        // separate \"[-spot 1]\" into just \"1\"\r\n        return +text\r\n            .split(/\\[-spot/g)[1]\r\n            .split(']')[0]\r\n            .trim();\r\n    }\r\n\r\n    /**\r\n     * gets the spot for a specific spotNr\r\n     * @param spotNr the spot number for which the sport should be retrived\r\n     * @param question\r\n     */\r\n    getSpot(spotNr: number, question: ShortAnswerQuestion): ShortAnswerSpot {\r\n        return question.spots!.filter((spot) => spot.spotNr === spotNr)[0];\r\n    }\r\n\r\n    /**\r\n     * We transform now the different text parts of the question text to HTML.\r\n     * 1. We iterate through every line of the question text.\r\n     * 2. We iterate through every element of each line of the question text and set each element with the new HTML.\r\n     * @param textParts\r\n     * @returns {string[][]}\r\n     */\r\n    transformTextPartsIntoHTML(textParts: string[][]): string[][] {\r\n        const formattedTextParts = textParts.map((textPart) => textPart.map((element) => htmlForMarkdown(element.trim())));\r\n        return this.addIndentationToTextParts(textParts, formattedTextParts);\r\n    }\r\n\r\n    /**\r\n     * @function addIndentationToTextParts\r\n     * @desc Formats the first word of each line with the indentation it originally had.\r\n     * @param originalTextParts {string[][]} the text parts without html formatting\r\n     * @param formattedTextParts {string[][]} the text parts with html formatting\r\n     */\r\n    addIndentationToTextParts(originalTextParts: string[][], formattedTextParts: string[][]): string[][] {\r\n        for (let i = 0; i < formattedTextParts.length; i++) {\r\n            const element = formattedTextParts[i][0];\r\n            let firstWord = '';\r\n            // check if first word is a spot (first array element will be an empty string)\r\n            if (originalTextParts[i].length > 1) {\r\n                firstWord =\r\n                    formattedTextParts[i][0] === '' && originalTextParts[i][1].startsWith('[-spot')\r\n                        ? this.getFirstWord(originalTextParts[i][1])\r\n                        : this.getFirstWord(originalTextParts[i][0]);\r\n            } else {\r\n                firstWord = this.getFirstWord(originalTextParts[i][0]);\r\n            }\r\n            if (firstWord === '') {\r\n                continue;\r\n            }\r\n\r\n            const firstWordIndex = element.indexOf(firstWord);\r\n            const whitespace = '&nbsp;'.repeat(this.getIndentation(originalTextParts[i][0]).length);\r\n            formattedTextParts[i][0] = [element.substring(0, firstWordIndex), whitespace, element.substring(firstWordIndex).trim()].join('');\r\n        }\r\n        return formattedTextParts;\r\n    }\r\n\r\n    /**\r\n     * @function getIndentation\r\n     * @desc Returns the whitespace in front of the text.\r\n     * @param text {string} the text for which we get the indentation\r\n     */\r\n    public getIndentation(text: string): string {\r\n        if (!text) {\r\n            return '';\r\n        }\r\n        if (text.startsWith('`')) {\r\n            text = text.substring(1);\r\n        }\r\n        let index = 0;\r\n        let indentation = '';\r\n        while (text[index] === ' ') {\r\n            indentation = indentation.concat(' ');\r\n            index++;\r\n        }\r\n        return indentation;\r\n    }\r\n\r\n    /**\r\n     * @function getFirstWord\r\n     * @desc Returns the first word in a text.\r\n     * @param text {string} for which the first word is returned\r\n     */\r\n    getFirstWord(text: string): string {\r\n        if (!text) {\r\n            return '';\r\n        }\r\n        const words = text\r\n            .trim()\r\n            .split(' ')\r\n            .filter((word) => word !== '');\r\n        if (words.length === 0) {\r\n            return '';\r\n        } else if (words[0] === '`') {\r\n            return words[1];\r\n        } else {\r\n            return words[0].startsWith('`') ? words[0].substring(1) : words[0];\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ShortAnswerQuestionUtil", "validateNoMisleadingShortAnswerMapping", "question", "correctMappings", "unusedMappings", "cloneDeep", "spotsCanBeSolved", "spot", "spots", "atLeastOneMapping", "getAllSolutionsForSpot", "forEach", "solution", "length", "filter", "solutionForSpot", "getAllSpotsForSolutions", "mapping", "isSameSolution", "hasSpotEnoughSolutions", "push", "includes", "isMappedTogether", "mappings", "getShortAnswerMapping", "map", "isSameSpot", "isSameSetOfSpots", "set1", "set2", "every", "spot1", "some", "spot2", "find", "a", "b", "undefined", "id", "tempID", "everySpotHasASolution", "i", "solutions", "everyMappedSolutionHasASpot", "hasMappingDuplicateValues", "duplicateValues", "j", "spotNr", "text", "getSampleSolutions", "sampleSolutions", "solutionsForSpot", "sampleSolution", "allSolutionsAreInSampleSolution", "atLeastAsManySolutionsAsSpots", "divideQuestionTextIntoTextParts", "questionText", "spotRegExpo", "interleave", "x", "xs", "ys", "split", "line", "match", "texts", "trim", "isInputField", "search", "getSpotNr", "getSpot", "transformTextPartsIntoHTML", "textParts", "formattedTextParts", "textPart", "element", "htmlForMarkdown", "addIndentationToTextParts", "originalTextParts", "firstWord", "startsWith", "getFirstWord", "firstWordIndex", "indexOf", "whitespace", "repeat", "getIndentation", "substring", "join", "index", "indentation", "concat", "words", "word", "factory", "\u0275fac", "providedIn"]
}
