{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/text/manage/text-exercise/text-exercise.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport { HttpClient, HttpResponse } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\n\r\nimport { TextExercise } from 'app/entities/text/text-exercise.model';\r\nimport { createRequestOption } from 'app/shared/util/request.util';\r\nimport { ExerciseServicable, ExerciseService } from 'app/exercises/shared/exercise/exercise.service';\r\nimport { TextPlagiarismResult } from 'app/exercises/shared/plagiarism/types/text/TextPlagiarismResult';\r\nimport { PlagiarismOptions } from 'app/exercises/shared/plagiarism/types/PlagiarismOptions';\r\nimport { TutorEffort } from 'app/entities/tutor-effort.model';\r\nimport { PlagiarismResultDTO } from 'app/exercises/shared/plagiarism/types/PlagiarismResultDTO';\r\n\r\nexport type EntityResponseType = HttpResponse<TextExercise>;\r\nexport type EntityArrayResponseType = HttpResponse<TextExercise[]>;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class TextExerciseService implements ExerciseServicable<TextExercise> {\r\n    private http = inject(HttpClient);\r\n    private exerciseService = inject(ExerciseService);\r\n\r\n    private resourceUrl = 'api/text/text-exercises';\r\n\r\n    /**\r\n     * Store a new text exercise on the server.\r\n     * @param textExercise that should be stored of type {TextExercise}\r\n     */\r\n    create(textExercise: TextExercise): Observable<EntityResponseType> {\r\n        let copy = ExerciseService.convertExerciseDatesFromClient(textExercise);\r\n        copy = ExerciseService.setBonusPointsConstrainedByIncludedInOverallScore(copy);\r\n        copy.categories = ExerciseService.stringifyExerciseCategories(copy);\r\n        return this.http\r\n            .post<TextExercise>(this.resourceUrl, copy, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Imports a text exercise by cloning the entity itself plus example solutions and example submissions\r\n     *\r\n     * @param adaptedSourceTextExercise The exercise that should be imported, including adapted values for the\r\n     * new exercise. E.g. with another title than the original exercise. Old values that should get discarded\r\n     * (like the old ID) will be handled by the server.\r\n     */\r\n    import(adaptedSourceTextExercise: TextExercise) {\r\n        let copy = ExerciseService.convertExerciseDatesFromClient(adaptedSourceTextExercise);\r\n        copy = ExerciseService.setBonusPointsConstrainedByIncludedInOverallScore(copy);\r\n        copy.categories = ExerciseService.stringifyExerciseCategories(copy);\r\n        return this.http\r\n            .post<TextExercise>(`${this.resourceUrl}/import/${adaptedSourceTextExercise.id}`, copy, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Updates an existing text exercise.\r\n     * @param textExercise that should be updated of type {TextExercise}\r\n     * @param req optional request options\r\n     */\r\n    update(textExercise: TextExercise, req?: any): Observable<EntityResponseType> {\r\n        const options = createRequestOption(req);\r\n        let copy = ExerciseService.convertExerciseDatesFromClient(textExercise);\r\n        copy = ExerciseService.setBonusPointsConstrainedByIncludedInOverallScore(copy);\r\n        copy.categories = ExerciseService.stringifyExerciseCategories(copy);\r\n        return this.http\r\n            .put<TextExercise>(this.resourceUrl, copy, { params: options, observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Finds the text exercise of the given exerciseId.\r\n     * @param exerciseId of text exercise of type {number}\r\n     * @param withPlagiarismDetectionConfig true if plagiarism detection context should be fetched with the exercise\r\n     */\r\n    find(exerciseId: number, withPlagiarismDetectionConfig: boolean = false): Observable<EntityResponseType> {\r\n        return this.http\r\n            .get<TextExercise>(`${this.resourceUrl}/${exerciseId}`, { observe: 'response', params: { withPlagiarismDetectionConfig: withPlagiarismDetectionConfig } })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Queries all text exercises for the given request options.\r\n     * @param req optional request options\r\n     */\r\n    query(req?: any): Observable<EntityArrayResponseType> {\r\n        const options = createRequestOption(req);\r\n        return this.http\r\n            .get<TextExercise[]>(this.resourceUrl, { params: options, observe: 'response' })\r\n            .pipe(map((res: EntityArrayResponseType) => this.exerciseService.processExerciseEntityArrayResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Deletes the text exercise with the given id.\r\n     * @param exerciseId of the text exercise of type {number}\r\n     */\r\n    delete(exerciseId: number): Observable<HttpResponse<any>> {\r\n        return this.http.delete(`${this.resourceUrl}/${exerciseId}`, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Check plagiarism with JPlag\r\n     *\r\n     * @param exerciseId\r\n     * @param options\r\n     */\r\n    checkPlagiarism(exerciseId: number, options?: PlagiarismOptions): Observable<PlagiarismResultDTO<TextPlagiarismResult>> {\r\n        return this.http\r\n            .get<PlagiarismResultDTO<TextPlagiarismResult>>(`${this.resourceUrl}/${exerciseId}/check-plagiarism`, {\r\n                observe: 'response',\r\n                params: {\r\n                    ...options?.toParams(),\r\n                },\r\n            })\r\n            .pipe(map((response: HttpResponse<PlagiarismResultDTO<TextPlagiarismResult>>) => response.body!));\r\n    }\r\n\r\n    /**\r\n     * Get the latest plagiarism result for the exercise with the given ID.\r\n     *\r\n     * @param exerciseId\r\n     */\r\n    getLatestPlagiarismResult(exerciseId: number): Observable<PlagiarismResultDTO<TextPlagiarismResult>> {\r\n        return this.http\r\n            .get<PlagiarismResultDTO<TextPlagiarismResult>>(`${this.resourceUrl}/${exerciseId}/plagiarism-result`, {\r\n                observe: 'response',\r\n            })\r\n            .pipe(map((response: HttpResponse<PlagiarismResultDTO<TextPlagiarismResult>>) => response.body!));\r\n    }\r\n\r\n    /**\r\n     * Re-evaluates and updates an existing text exercise.\r\n     *\r\n     * @param textExercise that should be updated of type {TextExercise}\r\n     * @param req optional request options\r\n     */\r\n    reevaluateAndUpdate(textExercise: TextExercise, req?: any): Observable<EntityResponseType> {\r\n        const options = createRequestOption(req);\r\n        let copy = ExerciseService.convertExerciseDatesFromClient(textExercise);\r\n        copy = ExerciseService.setBonusPointsConstrainedByIncludedInOverallScore(copy);\r\n        copy.categories = ExerciseService.stringifyExerciseCategories(copy);\r\n        return this.http\r\n            .put<TextExercise>(`${this.resourceUrl}/${textExercise.id}/re-evaluate`, copy, { params: options, observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.exerciseService.processExerciseEntityResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Retrieves the tutor effort in assessing a specific text exercise\r\n     * @param exerciseId the id of the exercise to check for\r\n     * @param courseId the id of the course to check for\r\n     */\r\n    public calculateTutorEffort(exerciseId: number, courseId: number): Observable<TutorEffort[]> {\r\n        return this.http\r\n            .get<TutorEffort[]>(`api/assessment/courses/${courseId}/exercises/${exerciseId}/tutor-effort`, { observe: 'response' })\r\n            .pipe(map((res: HttpResponse<TutorEffort[]>) => res.body!));\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["TextExerciseService", "http", "inject", "HttpClient", "exerciseService", "ExerciseService", "resourceUrl", "create", "textExercise", "copy", "convertExerciseDatesFromClient", "setBonusPointsConstrainedByIncludedInOverallScore", "categories", "stringifyExerciseCategories", "post", "observe", "pipe", "map", "res", "processExerciseEntityResponse", "import", "adaptedSourceTextExercise", "id", "update", "req", "options", "createRequestOption", "put", "params", "find", "exerciseId", "withPlagiarismDetectionConfig", "get", "query", "processExerciseEntityArrayResponse", "delete", "checkPlagiarism", "__spreadValues", "toParams", "response", "body", "getLatestPlagiarismResult", "reevaluateAndUpdate", "calculateTutorEffort", "courseId", "factory", "\u0275fac", "providedIn"]
}
