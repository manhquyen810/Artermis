{
  "version": 3,
  "sources": ["src/main/webapp/app/shared/constants/authority.constants.ts", "src/main/webapp/app/core/auth/account.service.ts"],
  "sourcesContent": ["export enum Authority {\r\n    ADMIN = 'ROLE_ADMIN',\r\n    INSTRUCTOR = 'ROLE_INSTRUCTOR',\r\n    EDITOR = 'ROLE_EDITOR',\r\n    TA = 'ROLE_TA',\r\n    USER = 'ROLE_USER',\r\n}\r\n", "import { Injectable, inject } from '@angular/core';\r\nimport { SessionStorageService } from 'ngx-webstorage';\r\nimport { HttpClient, HttpParams, HttpResponse } from '@angular/common/http';\r\nimport { BehaviorSubject, Observable, lastValueFrom, of } from 'rxjs';\r\nimport { catchError, distinctUntilChanged, map } from 'rxjs/operators';\r\nimport { Course } from 'app/entities/course.model';\r\nimport { User } from 'app/core/user/user.model';\r\nimport { WebsocketService } from 'app/core/websocket/websocket.service';\r\nimport { FeatureToggleService } from 'app/shared/feature-toggle/feature-toggle.service';\r\nimport { setUser } from '@sentry/angular';\r\nimport { StudentParticipation } from 'app/entities/participation/student-participation.model';\r\nimport { Exercise, getCourseFromExercise } from 'app/entities/exercise.model';\r\nimport { Authority } from 'app/shared/constants/authority.constants';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { EntityResponseType } from 'app/complaints/complaint.service';\r\nimport dayjs from 'dayjs/esm';\r\n\r\nexport interface IAccountService {\r\n    save: (account: any) => Observable<HttpResponse<any>>;\r\n    authenticate: (identity?: User) => void;\r\n    hasAnyAuthority: (authorities: string[]) => Promise<boolean>;\r\n    hasAnyAuthorityDirect: (authorities: string[]) => boolean;\r\n    hasAuthority: (authority: string) => Promise<boolean>;\r\n    identity: (force?: boolean) => Promise<User | undefined>;\r\n    isAtLeastTutorInCourse: (course: Course) => boolean;\r\n    isAtLeastTutorForExercise: (exercise?: Exercise) => boolean;\r\n    isAtLeastEditorInCourse: (course: Course) => boolean;\r\n    isAtLeastEditorForExercise: (exercise?: Exercise) => boolean;\r\n    isAtLeastInstructorForExercise: (exercise?: Exercise) => boolean;\r\n    isAtLeastInstructorInCourse: (course: Course) => boolean;\r\n    isAuthenticated: () => boolean;\r\n    getAuthenticationState: () => Observable<User | undefined>;\r\n    getImageUrl: () => string | undefined;\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class AccountService implements IAccountService {\r\n    private translateService = inject(TranslateService);\r\n    private sessionStorage = inject(SessionStorageService);\r\n    private http = inject(HttpClient);\r\n    private websocketService = inject(WebsocketService);\r\n    private featureToggleService = inject(FeatureToggleService);\r\n\r\n    // cached value of the user to avoid unnecessary requests to the server\r\n    private userIdentityValue?: User;\r\n    private authenticated = false;\r\n    private authenticationState = new BehaviorSubject<User | undefined>(undefined);\r\n    private prefilledUsernameValue?: string;\r\n\r\n    get userIdentity() {\r\n        return this.userIdentityValue;\r\n    }\r\n\r\n    set userIdentity(user: User | undefined) {\r\n        this.userIdentityValue = user;\r\n        this.authenticated = !!user;\r\n        // Alert subscribers about user updates, that is when the user logs in or logs out (undefined).\r\n        this.authenticationState.next(user);\r\n\r\n        // We only subscribe the feature toggle updates when the user is logged in, otherwise we unsubscribe them.\r\n        if (user) {\r\n            this.websocketService.enableReconnect();\r\n            this.websocketService.connect();\r\n            this.featureToggleService.subscribeFeatureToggleUpdates();\r\n        } else {\r\n            this.websocketService.disableReconnect();\r\n            if (this.websocketService.isConnected()) {\r\n                this.websocketService.disconnect();\r\n            }\r\n            this.featureToggleService.unsubscribeFeatureToggleUpdates();\r\n        }\r\n    }\r\n\r\n    private fetch(): Observable<HttpResponse<User>> {\r\n        return this.http.get<User>('api/core/public/account', { observe: 'response' });\r\n    }\r\n\r\n    save(user: User): Observable<HttpResponse<any>> {\r\n        return this.http.put('api/core/account', user, { observe: 'response' });\r\n    }\r\n\r\n    authenticate(identity?: User) {\r\n        this.userIdentity = identity;\r\n    }\r\n\r\n    syncGroups(groups: string[]) {\r\n        this.userIdentity!.groups = groups;\r\n    }\r\n\r\n    hasAnyAuthority(authorities: string[]): Promise<boolean> {\r\n        return Promise.resolve(this.hasAnyAuthorityDirect(authorities));\r\n    }\r\n\r\n    hasAnyAuthorityDirect(authorities: string[]): boolean {\r\n        if (!this.authenticated || !this.userIdentity || !this.userIdentity.authorities) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < authorities.length; i++) {\r\n            if (this.userIdentity.authorities.includes(authorities[i])) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    hasAuthority(authority: string): Promise<boolean> {\r\n        if (!this.authenticated) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        return this.identity().then(\r\n            (id) => {\r\n                const authorities = id!.authorities!;\r\n                return Promise.resolve(authorities && authorities.includes(authority));\r\n            },\r\n            () => {\r\n                return Promise.resolve(false);\r\n            },\r\n        );\r\n    }\r\n\r\n    hasGroup(group?: string): boolean {\r\n        if (!this.authenticated || !this.userIdentity || !this.userIdentity.authorities || !this.userIdentity.groups || !group) {\r\n            return false;\r\n        }\r\n\r\n        return this.userIdentity.groups.some((userGroup: string) => userGroup === group);\r\n    }\r\n\r\n    identity(force?: boolean): Promise<User | undefined> {\r\n        if (force) {\r\n            this.userIdentity = undefined;\r\n        }\r\n\r\n        // check and see if we have retrieved the userIdentity data from the server.\r\n        // if we have, reuse it by immediately resolving\r\n        if (this.userIdentity) {\r\n            return Promise.resolve(this.userIdentity);\r\n        }\r\n\r\n        // retrieve the userIdentity data from the server, update the identity object, and then resolve.\r\n        return lastValueFrom(\r\n            this.fetch().pipe(\r\n                map((response: HttpResponse<User>) => {\r\n                    const user = response.body!;\r\n                    if (user) {\r\n                        this.userIdentity = user;\r\n\r\n                        // improved error tracking in sentry\r\n                        setUser({ username: user.login! });\r\n\r\n                        // After retrieve the account info, the language will be changed to\r\n                        // the user's preferred language configured in the account setting\r\n                        const langKey = this.userIdentity.langKey || this.sessionStorage.retrieve('locale');\r\n                        this.translateService.use(langKey);\r\n                    } else {\r\n                        this.userIdentity = undefined;\r\n                    }\r\n                    return this.userIdentity;\r\n                }),\r\n                catchError(() => {\r\n                    this.userIdentity = undefined;\r\n                    return of(undefined);\r\n                }),\r\n            ),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * checks if the currently logged-in user is at least tutor in the given course\r\n     * @param course\r\n     */\r\n    isAtLeastTutorInCourse(course?: Course): boolean {\r\n        return (\r\n            this.hasGroup(course?.instructorGroupName) ||\r\n            this.hasGroup(course?.editorGroupName) ||\r\n            this.hasGroup(course?.teachingAssistantGroupName) ||\r\n            this.hasAnyAuthorityDirect([Authority.ADMIN])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * checks if the currently logged-in user is at least editor in the given course\r\n     * @param course\r\n     */\r\n    isAtLeastEditorInCourse(course?: Course): boolean {\r\n        return this.hasGroup(course?.instructorGroupName) || this.hasGroup(course?.editorGroupName) || this.hasAnyAuthorityDirect([Authority.ADMIN]);\r\n    }\r\n\r\n    /**\r\n     * checks if the currently logged-in user is at least instructor in the given course\r\n     * @param course\r\n     */\r\n    isAtLeastInstructorInCourse(course?: Course): boolean {\r\n        return this.hasGroup(course?.instructorGroupName) || this.hasAnyAuthorityDirect([Authority.ADMIN]);\r\n    }\r\n\r\n    /**\r\n     * checks if the currently logged-in user is at least tutor for the exercise (directly) in the course or the exercise in the exam in the course\r\n     * @param exercise\r\n     */\r\n    isAtLeastTutorForExercise(exercise?: Exercise): boolean {\r\n        return this.isAtLeastTutorInCourse(exercise?.course || exercise?.exerciseGroup?.exam?.course);\r\n    }\r\n\r\n    /**\r\n     * checks if the currently logged-in user is at least editor for the exercise (directly) in the course or the exercise in the exam in the course\r\n     * @param exercise\r\n     */\r\n    isAtLeastEditorForExercise(exercise?: Exercise): boolean {\r\n        return this.isAtLeastEditorInCourse(exercise?.course || exercise?.exerciseGroup?.exam?.course);\r\n    }\r\n\r\n    /**\r\n     * checks if the currently logged-in user is at least instructor for the exercise (directly) in the course or the exercise in the exam in the course\r\n     * @param exercise\r\n     */\r\n    isAtLeastInstructorForExercise(exercise?: Exercise): boolean {\r\n        return this.isAtLeastInstructorInCourse(exercise?.course || exercise?.exerciseGroup?.exam?.course);\r\n    }\r\n\r\n    isAdmin(): boolean {\r\n        return this.hasAnyAuthorityDirect([Authority.ADMIN]);\r\n    }\r\n\r\n    isAtLeastTutor(): boolean {\r\n        return this.hasAnyAuthorityDirect([Authority.ADMIN, Authority.EDITOR, Authority.INSTRUCTOR, Authority.TA]);\r\n    }\r\n\r\n    isAuthenticated(): boolean {\r\n        return this.authenticated;\r\n    }\r\n\r\n    getAuthenticationState(): Observable<User | undefined> {\r\n        return this.authenticationState.asObservable().pipe(\r\n            // We don't want to emit here e.g. [undefined, undefined] as it is still the same information [logged out, logged out].\r\n            distinctUntilChanged(),\r\n        );\r\n    }\r\n\r\n    setAccessRightsForExerciseAndReferencedCourse(exercise: Exercise) {\r\n        this.setAccessRightsForExercise(exercise);\r\n        const course = getCourseFromExercise(exercise);\r\n        if (course) {\r\n            this.setAccessRightsForCourse(course);\r\n        }\r\n    }\r\n\r\n    setAccessRightsForCourseAndReferencedExercises(course: Course) {\r\n        this.setAccessRightsForCourse(course);\r\n        if (course.exercises) {\r\n            course.exercises.forEach((exercise: Exercise) => this.setAccessRightsForExercise(exercise));\r\n        }\r\n    }\r\n\r\n    setAccessRightsForExercise(exercise: Exercise) {\r\n        exercise.isAtLeastTutor = this.isAtLeastTutorForExercise(exercise);\r\n        exercise.isAtLeastEditor = this.isAtLeastEditorForExercise(exercise);\r\n        exercise.isAtLeastInstructor = this.isAtLeastInstructorForExercise(exercise);\r\n    }\r\n\r\n    setAccessRightsForCourse(course: Course) {\r\n        course.isAtLeastTutor = this.isAtLeastTutorInCourse(course);\r\n        course.isAtLeastEditor = this.isAtLeastEditorInCourse(course);\r\n        course.isAtLeastInstructor = this.isAtLeastInstructorInCourse(course);\r\n    }\r\n\r\n    /**\r\n     * Checks whether current user is owner of the participation or whether he is part of the team\r\n     *\r\n     * @param participation - Participation that is checked\r\n     */\r\n    isOwnerOfParticipation(participation: StudentParticipation): boolean {\r\n        if (participation.student) {\r\n            return this.userIdentity?.login === participation.student.login;\r\n        } else if (participation.team?.students) {\r\n            return participation.team.students.some((student) => this.userIdentity?.login === student.login);\r\n        }\r\n        throw new Error('Participation does not have any owners');\r\n    }\r\n\r\n    /**\r\n     * Returns the image url of the user or undefined.\r\n     *\r\n     * Returns undefined if the user is not authenticated or the user does not have an image.\r\n     */\r\n    getImageUrl() {\r\n        return this.isAuthenticated() && this.userIdentity ? this.userIdentity.imageUrl : undefined;\r\n    }\r\n\r\n    setImageUrl(url: string | undefined) {\r\n        if (this.userIdentity != null) {\r\n            this.userIdentity!.imageUrl = url;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new language key for the current user\r\n     *\r\n     * @param languageKey The new languageKey\r\n     */\r\n    updateLanguage(languageKey: string): Observable<void> {\r\n        return this.http.post<void>('api/core/public/account/change-language', languageKey);\r\n    }\r\n\r\n    /**\r\n     * Returns the current prefilled username and clears it. Necessary as we don't want to show the prefilled username after a later log out.\r\n     *\r\n     * @returns the prefilled username\r\n     */\r\n    getAndClearPrefilledUsername(): string | undefined {\r\n        const prefilledUsername = this.prefilledUsernameValue;\r\n        this.prefilledUsernameValue = undefined;\r\n        return prefilledUsername;\r\n    }\r\n\r\n    /**\r\n     * Sets the prefilled username\r\n     *\r\n     * @param prefilledUsername The new prefilled username\r\n     */\r\n    setPrefilledUsername(prefilledUsername: string) {\r\n        this.prefilledUsernameValue = prefilledUsername;\r\n    }\r\n\r\n    /**\r\n     * Sends a request to the server to delete the user's current vcsAccessToken\r\n     */\r\n    deleteUserVcsAccessToken(): Observable<void> {\r\n        return this.http.delete<void>('api/core/account/user-vcs-access-token');\r\n    }\r\n\r\n    /**\r\n     * Sends a request to the server to create a new vcsAccessToken for the user\r\n     *\r\n     * @param expiryDate The expiry date which should get set for the vcsAccessToken\r\n     */\r\n    addNewVcsAccessToken(expiryDate: string): Observable<EntityResponseType> {\r\n        const params = new HttpParams().set('expiryDate', expiryDate);\r\n        return this.http.put<User>('api/core/account/user-vcs-access-token', null, { observe: 'response', params });\r\n    }\r\n\r\n    /**\r\n     * Sends a request to the server to obtain the VCS access token for a specific participation.\r\n     * Users can use this access token to clone the repository belonging to a participation.\r\n     *\r\n     * @param participationId The participation for which the VCS access token is requested\r\n     */\r\n    getVcsAccessToken(participationId: number): Observable<HttpResponse<string>> {\r\n        const params = new HttpParams().set('participationId', participationId);\r\n        return this.http.get<string>('api/core/account/participation-vcs-access-token', { observe: 'response', params, responseType: 'text' as 'json' });\r\n    }\r\n\r\n    /**\r\n     * Sends a request to the server, to create a VCS access token for a specific participation.\r\n     * Users can use this access token to clone the repository belonging to a participation.\r\n     *\r\n     * @param participationId The participation for which the VCS access token should get created\r\n     */\r\n    createVcsAccessToken(participationId: number): Observable<HttpResponse<string>> {\r\n        const params = new HttpParams().set('participationId', participationId);\r\n        return this.http.put<string>('api/core/account/participation-vcs-access-token', null, { observe: 'response', params, responseType: 'text' as 'json' });\r\n    }\r\n\r\n    /**\r\n     * Sets externalLLMUsageAccepted to current timestamp locally, to omit accepting external LLM usage\r\n     * popup appearing multiple time before user refreshes the page.\r\n     */\r\n    setUserAcceptedExternalLLMUsage(): void {\r\n        if (this.userIdentity) {\r\n            this.userIdentity.externalLLMUsageAccepted = dayjs();\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["Authority", "AccountService", "translateService", "inject", "TranslateService", "sessionStorage", "SessionStorageService", "http", "HttpClient", "websocketService", "WebsocketService", "featureToggleService", "FeatureToggleService", "userIdentityValue", "authenticated", "authenticationState", "BehaviorSubject", "undefined", "prefilledUsernameValue", "userIdentity", "user", "next", "enableReconnect", "connect", "subscribeFeatureToggleUpdates", "disableReconnect", "isConnected", "disconnect", "unsubscribeFeatureToggleUpdates", "fetch", "get", "observe", "save", "put", "authenticate", "identity", "syncGroups", "groups", "hasAnyAuthority", "authorities", "Promise", "resolve", "hasAnyAuthorityDirect", "i", "length", "includes", "hasAuthority", "authority", "then", "id", "hasGroup", "group", "some", "userGroup", "force", "lastValueFrom", "pipe", "map", "response", "body", "setUser", "username", "login", "langKey", "retrieve", "use", "catchError", "of", "isAtLeastTutorInCourse", "course", "instructorGroupName", "editorGroupName", "teachingAssistantGroupName", "Authority", "ADMIN", "isAtLeastEditorInCourse", "isAtLeastInstructorInCourse", "isAtLeastTutorForExercise", "exercise", "exerciseGroup", "exam", "isAtLeastEditorForExercise", "isAtLeastInstructorForExercise", "isAdmin", "isAtLeastTutor", "EDITOR", "INSTRUCTOR", "TA", "isAuthenticated", "getAuthenticationState", "asObservable", "distinctUntilChanged", "setAccessRightsForExerciseAndReferencedCourse", "setAccessRightsForExercise", "getCourseFromExercise", "setAccessRightsForCourse", "setAccessRightsForCourseAndReferencedExercises", "exercises", "forEach", "isAtLeastEditor", "isAtLeastInstructor", "isOwnerOfParticipation", "participation", "student", "team", "students", "Error", "getImageUrl", "imageUrl", "setImageUrl", "url", "updateLanguage", "languageKey", "post", "getAndClearPrefilledUsername", "prefilledUsername", "setPrefilledUsername", "deleteUserVcsAccessToken", "delete", "addNewVcsAccessToken", "expiryDate", "params", "HttpParams", "set", "getVcsAccessToken", "participationId", "responseType", "createVcsAccessToken", "setUserAcceptedExternalLLMUsage", "externalLLMUsageAccepted", "dayjs", "factory", "\u0275fac", "providedIn"]
}
