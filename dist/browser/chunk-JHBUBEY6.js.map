{
  "version": 3,
  "sources": ["src/main/webapp/app/overview/participation-websocket.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport { BehaviorSubject, of, pipe } from 'rxjs';\r\nimport { switchMap, tap } from 'rxjs/operators';\r\nimport { Participation } from 'app/entities/participation/participation.model';\r\nimport { Result } from 'app/entities/result.model';\r\nimport { Exercise, ExerciseType } from 'app/entities/exercise.model';\r\nimport { StudentParticipation } from 'app/entities/participation/student-participation.model';\r\nimport { ParticipationService } from 'app/exercises/shared/participation/participation.service';\r\nimport { WebsocketService } from 'app/core/websocket/websocket.service';\r\nimport dayjs from 'dayjs/esm';\r\nimport { cloneDeep } from 'lodash-es';\r\nimport { ProgrammingExercise } from 'app/entities/programming/programming-exercise.model';\r\n\r\nconst PERSONAL_PARTICIPATION_TOPIC = `/user/topic/newResults`;\r\nconst EXERCISE_PARTICIPATION_TOPIC = (exerciseId: number) => `/topic/exercise/${exerciseId}/newResults`;\r\n\r\nexport interface IParticipationWebsocketService {\r\n    addParticipation: (participation: Participation, exercise?: Exercise) => void;\r\n    getParticipationsForExercise: (exerciseId: number) => StudentParticipation[] | undefined;\r\n    subscribeForParticipationChanges: () => BehaviorSubject<Participation | undefined>;\r\n    subscribeForLatestResultOfParticipation: (participationId: number, personal: boolean, exerciseId?: number) => BehaviorSubject<Result | undefined>;\r\n    unsubscribeForLatestResultOfParticipation: (participationId: number, exercise: Exercise) => void;\r\n    notifyAllResultSubscribers: (result: Result) => void;\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ParticipationWebsocketService implements IParticipationWebsocketService {\r\n    private websocketService = inject(WebsocketService);\r\n    private participationService = inject(ParticipationService);\r\n\r\n    cachedParticipations: Map<number /* ID of participation */, StudentParticipation> = new Map<number, StudentParticipation>();\r\n    openResultWebsocketSubscriptions: Map<number /*ID of participation */, string /* url of websocket connection */> = new Map<number, string>();\r\n    openPersonalWebsocketSubscription?: string; /* url of websocket connection */\r\n    resultObservables: Map<number /* ID of participation */, BehaviorSubject<Result | undefined>> = new Map<number, BehaviorSubject<Result>>();\r\n    participationObservable?: BehaviorSubject<Participation | undefined>;\r\n    subscribedExercises: Map<number /* ID of exercise */, Set<number> /* IDs of the participations of this exercise */> = new Map<number, Set<number>>();\r\n    participationSubscriptionTypes: Map<number /* ID of participation */, boolean /* Whether the participation was subscribed in personal mode */> = new Map<number, boolean>();\r\n\r\n    private getNotifyAllSubscribersPipe = () => {\r\n        return pipe(tap(this.notifyResultSubscribers), switchMap(this.addResultToParticipation), tap(this.notifyParticipationSubscribers));\r\n    };\r\n\r\n    /**\r\n     * remove all local participations\r\n     */\r\n    public resetLocalCache() {\r\n        const participations = this.getAllParticipations();\r\n        participations.forEach((participation) => {\r\n            this.cachedParticipations.delete(participation.id!);\r\n            this.removeParticipation(participation.id!, participation.exercise?.id);\r\n        });\r\n        this.cachedParticipations = new Map<number, StudentParticipation>();\r\n        this.resultObservables = new Map<number, BehaviorSubject<Result>>();\r\n        this.participationObservable = undefined;\r\n        this.subscribedExercises = new Map<number, Set<number>>();\r\n        this.participationSubscriptionTypes = new Map<number, boolean>();\r\n    }\r\n\r\n    /**\r\n     * Notify all participation subscribers with the newest participation value (e.g. if the result has changed).\r\n     * @param participation\r\n     */\r\n    private notifyParticipationSubscribers = (participation: Participation) => {\r\n        if (!this.participationObservable) {\r\n            this.participationObservable = new BehaviorSubject(participation);\r\n        } else {\r\n            this.participationObservable.next(participation);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Notify all result subscribers with the newest result provided.\r\n     * @param result\r\n     */\r\n    private notifyResultSubscribers = (result: Result) => {\r\n        const resultObservable = this.resultObservables.get(result.participation!.id!);\r\n        // TODO: We never convert the date strings of the result (e.g. completionDate) to a Dayjs object\r\n        //  this could be an issue in some parts of app when a formatted date is needed.\r\n        if (!resultObservable) {\r\n            this.resultObservables.set(result.participation!.id!, new BehaviorSubject(result));\r\n        } else {\r\n            resultObservable.next(result);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Update a cachedParticipation with the given result, meaning that the new result will be added to it.\r\n     * @param result\r\n     */\r\n    private addResultToParticipation = (result: Result) => {\r\n        const cachedParticipation = this.cachedParticipations.get(result.participation!.id!);\r\n        if (cachedParticipation) {\r\n            // update the results with the new received one by filtering the old result\r\n            const updatedResults = [...(cachedParticipation.results || [])].filter((r) => r.id !== result.id);\r\n            updatedResults.push(result);\r\n            // create a clone\r\n            this.cachedParticipations.set(result.participation!.id!, { ...cachedParticipation, results: updatedResults } as StudentParticipation);\r\n            return of(this.cachedParticipations.get(result.participation!.id!));\r\n        }\r\n        return of();\r\n    };\r\n\r\n    /**\r\n     * This adds a participation to the cached data maps. The exercise information is required to find the correct\r\n     * participations for a given exercise. Please note: we explicitly do not want to use websockets here!\r\n     *\r\n     * @param newParticipation The new participation for the cached data maps\r\n     * @param exercise (optional) The exercise that the participation belongs to. Only needed if exercise is missing in participation.\r\n     */\r\n    public addParticipation = (newParticipation: StudentParticipation, exercise?: Exercise) => {\r\n        // The participation needs to be cloned so that the original object is not modified\r\n        const participation = cloneDeep(newParticipation);\r\n        if (!participation.exercise && !exercise) {\r\n            throw new Error('a link from the participation to the exercise is required. Please attach it manually or add exercise as function input');\r\n        }\r\n        participation.exercise = participation.exercise || exercise;\r\n        this.cachedParticipations.set(participation.id!, participation);\r\n        this.notifyParticipationSubscribers(participation);\r\n    };\r\n\r\n    /**\r\n     * Returns all participations for all exercises. The participation objects include the exercise data and all results.\r\n     * @return array of Participations\r\n     */\r\n    private getAllParticipations(): StudentParticipation[] {\r\n        return [...this.cachedParticipations.values()];\r\n    }\r\n\r\n    /**\r\n     * Returns the student participation for the given exercise. The participation objects include the exercise data and all results.\r\n     *\r\n     * @param exerciseId ID of the exercise that the participations belong to.\r\n     * @return the cached student participations separated between testRun and normal participation for the exercise or an empty array\r\n     */\r\n    public getParticipationsForExercise(exerciseId: number): StudentParticipation[] {\r\n        const participationsForExercise = [...this.cachedParticipations.values()].filter((participation) => {\r\n            return participation.exercise?.id === exerciseId;\r\n        });\r\n        if (participationsForExercise?.length) {\r\n            return this.participationService.mergeStudentParticipations(participationsForExercise);\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes from the topics used by the participationId, if possible\r\n     *\r\n     * @param participationId ID of the participation that should not be tracked anymore\r\n     * @param exerciseId optional the participationId an exercise that should not be tracked anymore\r\n     */\r\n    private removeParticipation(participationId: number, exerciseId?: number) {\r\n        const subscriptionTypePersonal = this.participationSubscriptionTypes.get(participationId);\r\n        this.participationSubscriptionTypes.delete(participationId);\r\n\r\n        // We are only interested if there is a value\r\n        if (subscriptionTypePersonal != undefined) {\r\n            if (subscriptionTypePersonal) {\r\n                // The subscription was a personal subscription, so it should only be removed if it was the last of it kind\r\n                const openPersonalSubscriptions = [...this.participationSubscriptionTypes.values()].filter((personal: boolean) => personal).length;\r\n                if (openPersonalSubscriptions === 0) {\r\n                    this.websocketService.unsubscribe(PERSONAL_PARTICIPATION_TOPIC);\r\n                    this.openPersonalWebsocketSubscription = undefined;\r\n                }\r\n            } else {\r\n                // The subscriptions are non-personal subscriptions, so it should only be removed if it was the last for this exercise\r\n                const openSubscriptionsForExercise = this.subscribedExercises.get(exerciseId!);\r\n                if (openSubscriptionsForExercise) {\r\n                    openSubscriptionsForExercise.delete(participationId);\r\n                    if (openSubscriptionsForExercise.size === 0) {\r\n                        this.subscribedExercises.delete(exerciseId!);\r\n                        const subscribedTopic = this.openResultWebsocketSubscriptions.get(exerciseId!);\r\n                        if (subscribedTopic) {\r\n                            this.websocketService.unsubscribe(subscribedTopic);\r\n                            this.openResultWebsocketSubscriptions.delete(exerciseId!);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if a websocket connection for new results to the server already exists.\r\n     * If not a new one will be opened.\r\n     *\r\n     * @param participationId the id of the participation for which the subscription should be opened\r\n     * @param personal whether the current user is a participant in the participation.\r\n     * @param exerciseId optional exerciseId of the exercise where the participation is part of, only needed if personal == false\r\n     */\r\n    private openResultWebsocketSubscriptionIfNotExisting(participationId: number, personal: boolean, exerciseId?: number) {\r\n        if ((personal && !this.openPersonalWebsocketSubscription) || (!personal && !this.openResultWebsocketSubscriptions.has(exerciseId!))) {\r\n            let participationResultTopic: string;\r\n            if (personal) {\r\n                participationResultTopic = PERSONAL_PARTICIPATION_TOPIC;\r\n                this.openPersonalWebsocketSubscription = participationResultTopic;\r\n            } else {\r\n                participationResultTopic = EXERCISE_PARTICIPATION_TOPIC(exerciseId!);\r\n                this.openResultWebsocketSubscriptions.set(exerciseId!, participationResultTopic);\r\n            }\r\n            this.participationSubscriptionTypes.set(participationId, personal);\r\n            if (!this.subscribedExercises.has(exerciseId!)) {\r\n                this.subscribedExercises.set(exerciseId!, new Set<number>());\r\n            }\r\n            const subscribedParticipations = this.subscribedExercises.get(exerciseId!);\r\n            subscribedParticipations!.add(participationId);\r\n\r\n            this.websocketService.subscribe(participationResultTopic);\r\n            this.websocketService.receive(participationResultTopic).pipe(this.getNotifyAllSubscribersPipe()).subscribe();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notifies the result and participation subscribers with the newest result.\r\n     * Note: the result must contain the participation id\r\n     *\r\n     * @param result The result with which the subscribers get notified\r\n     */\r\n    public notifyAllResultSubscribers = (result: Result) => {\r\n        of(result).pipe(this.getNotifyAllSubscribersPipe()).subscribe();\r\n    };\r\n\r\n    /**\r\n     * Subscribing for general changes in a participation object. This will triggered if a new result is received by the service.\r\n     * A received object will be the full participation object including all results and the exercise.\r\n     *\r\n     * If no observable exists a new one will be created.\r\n     */\r\n    public subscribeForParticipationChanges(): BehaviorSubject<Participation | undefined> {\r\n        if (!this.participationObservable) {\r\n            this.participationObservable = new BehaviorSubject<Participation | undefined>(undefined);\r\n        }\r\n        return this.participationObservable;\r\n    }\r\n\r\n    /**\r\n     * Subscribing to new results of a certain participation. This will be triggered if a new result is received by the service.\r\n     * A received Object will be a result object.\r\n     *\r\n     * If there is no observable for the participation a new one will be created.\r\n     *\r\n     * @param participationId Id of Participation of which result to subscribe to\r\n     * @param personal whether the current user is a participant in the participation.\r\n     * @param exerciseId optional exerciseId of the exercise where the participation is part of, only needed if personal == false\r\n     */\r\n    public subscribeForLatestResultOfParticipation(participationId: number, personal: boolean, exerciseId?: number): BehaviorSubject<Result | undefined> {\r\n        this.openResultWebsocketSubscriptionIfNotExisting(participationId, personal, exerciseId);\r\n        let resultObservable = this.resultObservables.get(participationId)!;\r\n        if (!resultObservable) {\r\n            resultObservable = new BehaviorSubject<Result | undefined>(undefined);\r\n            this.resultObservables.set(participationId, resultObservable);\r\n        }\r\n        return resultObservable;\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from the result\r\n     * @param participationId\r\n     * @param exercise The exercise to which the participationId belongs to. Needed for deciding whether to unsubscribe from the websocket\r\n     */\r\n    public unsubscribeForLatestResultOfParticipation(participationId: number, exercise: Exercise): void {\r\n        // Only unsubscribe from websocket, if the exercise is not active any more\r\n        let isInactiveProgrammingExercise = false;\r\n        if (exercise.type === ExerciseType.PROGRAMMING) {\r\n            const programmingExercise = exercise as ProgrammingExercise;\r\n            isInactiveProgrammingExercise =\r\n                !!programmingExercise.buildAndTestStudentSubmissionsAfterDueDate && dayjs(programmingExercise.buildAndTestStudentSubmissionsAfterDueDate).isBefore(dayjs());\r\n        }\r\n        if (isInactiveProgrammingExercise || (exercise.dueDate && dayjs(exercise.dueDate).isBefore(dayjs()))) {\r\n            this.removeParticipation(participationId, exercise.id);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["PERSONAL_PARTICIPATION_TOPIC", "EXERCISE_PARTICIPATION_TOPIC", "exerciseId", "ParticipationWebsocketService", "websocketService", "inject", "WebsocketService", "participationService", "ParticipationService", "cachedParticipations", "Map", "openResultWebsocketSubscriptions", "openPersonalWebsocketSubscription", "resultObservables", "participationObservable", "subscribedExercises", "participationSubscriptionTypes", "getNotifyAllSubscribersPipe", "pipe", "tap", "notifyResultSubscribers", "switchMap", "addResultToParticipation", "notifyParticipationSubscribers", "resetLocalCache", "getAllParticipations", "forEach", "participation", "delete", "id", "removeParticipation", "exercise", "undefined", "next", "BehaviorSubject", "result", "resultObservable", "get", "set", "cachedParticipation", "updatedResults", "results", "filter", "r", "push", "__spreadProps", "__spreadValues", "of", "addParticipation", "newParticipation", "cloneDeep", "Error", "values", "getParticipationsForExercise", "participationsForExercise", "length", "mergeStudentParticipations", "participationId", "subscriptionTypePersonal", "personal", "unsubscribe", "openSubscriptionsForExercise", "size", "subscribedTopic", "openResultWebsocketSubscriptionIfNotExisting", "has", "participationResultTopic", "Set", "add", "subscribe", "receive", "notifyAllResultSubscribers", "subscribeForParticipationChanges", "subscribeForLatestResultOfParticipation", "unsubscribeForLatestResultOfParticipation", "isInactiveProgrammingExercise", "type", "ExerciseType", "PROGRAMMING", "programmingExercise", "buildAndTestStudentSubmissionsAfterDueDate", "dayjs", "isBefore", "dueDate", "factory", "\u0275fac", "providedIn"]
}
