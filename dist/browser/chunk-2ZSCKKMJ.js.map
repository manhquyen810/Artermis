{
  "version": 3,
  "sources": ["src/main/webapp/app/shared/chart/chart-filter.ts", "src/main/webapp/app/shared/chart/chart-category-filter.ts", "src/main/webapp/app/shared/chart/chart-exercise-type-filter.ts"],
  "sourcesContent": ["export abstract class ChartFilter {\r\n    filterMap: Map<string, boolean> = new Map<string, boolean>();\r\n    numberOfActiveFilters = 0;\r\n\r\n    getCurrentFilterState(category: string) {\r\n        return this.filterMap.get(category);\r\n    }\r\n}\r\n", "import { ChartFilter } from 'app/shared/chart/chart-filter';\r\nimport { Injectable } from '@angular/core';\r\nimport { ExerciseCategory } from 'app/entities/exercise-category.model';\r\nimport { CourseManagementStatisticsModel } from 'app/entities/quiz/course-management-statistics-model';\r\nimport { Exercise } from 'app/entities/exercise.model';\r\n\r\ntype CategoryFilterOperatingType = CourseManagementStatisticsModel | Exercise;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ChartCategoryFilter extends ChartFilter {\r\n    exerciseCategories: Set<string>;\r\n    allCategoriesSelected = true;\r\n    includeExercisesWithNoCategory = true;\r\n    exercisesWithoutCategoriesPresent: boolean;\r\n\r\n    /**\r\n     * Collects all categories from the provided exercises\r\n     */\r\n    private determineDisplayableCategories(courseExercises: CategoryFilterOperatingType[]): Set<string> {\r\n        const exerciseCategories = courseExercises\r\n            .filter((exercise) => exercise.categories)\r\n            .flatMap((exercise) => exercise.categories!)\r\n            .map((category) => category.category!);\r\n        return new Set(exerciseCategories);\r\n    }\r\n\r\n    /**\r\n     * Creates an initial filter setting by including all categories\r\n     * @param exercisesScores the score objects the categories are derived from\r\n     */\r\n    setupCategoryFilter(exercisesScores: CategoryFilterOperatingType[]): void {\r\n        this.exerciseCategories = this.determineDisplayableCategories(exercisesScores);\r\n        this.exercisesWithoutCategoriesPresent = exercisesScores.some((exercises) => !exercises.categories);\r\n        this.exerciseCategories.forEach((category) => this.filterMap.set(category, true));\r\n        this.allCategoriesSelected = true;\r\n        this.includeExercisesWithNoCategory = this.exercisesWithoutCategoriesPresent;\r\n        this.calculateNumberOfAppliedFilters();\r\n    }\r\n\r\n    /**\r\n     * Calculates the current amount of active category filter options\r\n     */\r\n    private calculateNumberOfAppliedFilters(): void {\r\n        this.numberOfActiveFilters = this.exerciseCategories.size + (this.includeExercisesWithNoCategory ? 1 : 0);\r\n    }\r\n\r\n    /**\r\n     * Handles the selection or deselection of a specific category and configures the filter accordingly\r\n     * @param exercisesScores the scores the updated filter should apply to\r\n     * @param category the category that is selected or deselected\r\n     * @returns scores filtered against the updated filter setting\r\n     */\r\n    toggleCategory<E extends CategoryFilterOperatingType>(exercisesScores: CategoryFilterOperatingType[], category: string): Array<E> {\r\n        const isIncluded = this.filterMap.get(category)!;\r\n        this.filterMap.set(category, !isIncluded);\r\n        this.numberOfActiveFilters += !isIncluded ? 1 : -1;\r\n        this.areAllCategoriesSelected(!isIncluded);\r\n        return this.applyCurrentFilter<E>(exercisesScores);\r\n    }\r\n    /**\r\n     * Handles the selection and deselection of \"exercises with no categories\" filter option\r\n     * @param exerciseScores the scores the updated filter should apply to\r\n     * @returns scores filtered against the updated filter setting\r\n     */\r\n    toggleExercisesWithNoCategory<E extends CategoryFilterOperatingType>(exerciseScores: CategoryFilterOperatingType[]): Array<E> {\r\n        this.numberOfActiveFilters += this.includeExercisesWithNoCategory ? -1 : 1;\r\n        this.includeExercisesWithNoCategory = !this.includeExercisesWithNoCategory;\r\n        this.areAllCategoriesSelected(this.includeExercisesWithNoCategory);\r\n        return this.applyCurrentFilter<E>(exerciseScores);\r\n    }\r\n\r\n    /**\r\n     * Handles the use case when the user selects or deselects the option \"select all categories\"\r\n     * @param exerciseScores the scores the updated filter should apply to\r\n     * @returns scores filtered against the updated filter setting\r\n     */\r\n    toggleAllCategories<E extends CategoryFilterOperatingType>(exerciseScores: CategoryFilterOperatingType[]): Array<E> {\r\n        if (!this.allCategoriesSelected) {\r\n            this.setupCategoryFilter(exerciseScores);\r\n            this.includeExercisesWithNoCategory = true;\r\n            this.calculateNumberOfAppliedFilters();\r\n        } else {\r\n            this.exerciseCategories.forEach((category) => this.filterMap.set(category, false));\r\n            this.numberOfActiveFilters -= this.exerciseCategories.size + 1;\r\n            this.allCategoriesSelected = false;\r\n            this.includeExercisesWithNoCategory = false;\r\n        }\r\n        return this.applyCurrentFilter<E>(exerciseScores);\r\n    }\r\n\r\n    /**\r\n     * Auxiliary method in order to reduce code duplication\r\n     * Takes the currently configured exerciseCategoryFilters and applies it to the exerciseScores\r\n     *\r\n     * Important note: As exercises can have no or multiple categories, the filter is designed to be non-exclusive. This means\r\n     * as long as an exercise has at least one of the selected categories, it is displayed.\r\n     * @param exerciseScores the exercise scores the current filter setting should be applied to\r\n     * @returns scores filtered against the updated filter setting\r\n     */\r\n    applyCurrentFilter<E extends CategoryFilterOperatingType>(exerciseScores: CategoryFilterOperatingType[]): Array<E> {\r\n        return exerciseScores.filter((exercise) => {\r\n            if (!exercise.categories) {\r\n                return this.includeExercisesWithNoCategory;\r\n            }\r\n            return exercise\r\n                .categories!.flatMap((category: ExerciseCategory) => this.filterMap.get(category.category!)!)\r\n                .reduce((value1: boolean, value2: boolean) => value1 || value2);\r\n        }) as Array<E>;\r\n    }\r\n\r\n    /**\r\n     * Auxiliary method that checks whether all possible categories are selected and updates the allCategoriesSelected flag accordingly\r\n     * @param newFilterStatement indicates whether the updated filter option got selected or deselected and updates the flag accordingly\r\n     */\r\n    private areAllCategoriesSelected(newFilterStatement: boolean): void {\r\n        if (newFilterStatement) {\r\n            if (this.exercisesWithoutCategoriesPresent && !this.includeExercisesWithNoCategory) {\r\n                this.allCategoriesSelected = false;\r\n            } else {\r\n                this.allCategoriesSelected = true;\r\n                this.filterMap.forEach((value) => (this.allCategoriesSelected = value && this.allCategoriesSelected));\r\n            }\r\n        } else {\r\n            this.allCategoriesSelected = false;\r\n        }\r\n    }\r\n}\r\n", "import { Injectable } from '@angular/core';\r\nimport { ExerciseType } from 'app/entities/exercise.model';\r\nimport { ChartFilter } from 'app/shared/chart/chart-filter';\r\nimport { CourseManagementStatisticsModel } from 'app/entities/quiz/course-management-statistics-model';\r\nimport { ExerciseScoresDTO } from 'app/overview/visualizations/exercise-scores-chart.service';\r\n\r\ntype TypeFilterOperatingType = ExerciseScoresDTO | CourseManagementStatisticsModel;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ChartExerciseTypeFilter extends ChartFilter {\r\n    typeSet: Set<ExerciseType> = new Set();\r\n\r\n    /**\r\n     * Set up initial filter for the chart\r\n     * @param exerciseScores the score objects containing an exercise type a filter should\r\n     * be provided for\r\n     */\r\n    initializeFilterOptions(exerciseScores: TypeFilterOperatingType[]): void {\r\n        this.typeSet = new Set(exerciseScores.map((score) => score.exerciseType));\r\n        this.typeSet.forEach((type) => {\r\n            this.filterMap.set(ChartExerciseTypeFilter.convertToMapKey(type), true);\r\n        });\r\n        this.numberOfActiveFilters = this.typeSet.size;\r\n    }\r\n\r\n    /**\r\n     * Handles selection or deselection of specific exercise type\r\n     * @param type the ExerciseType the user changed the filter for\r\n     * @param exerciseScores the score objects the updated filter should be applied against\r\n     * @returns the exerciseScores filtered against the current state of the chart filter\r\n     */\r\n    toggleExerciseType<E extends TypeFilterOperatingType>(type: ExerciseType, exerciseScores: TypeFilterOperatingType[]): Array<E> {\r\n        const convertedType = ChartExerciseTypeFilter.convertToMapKey(type);\r\n        const isIncluded = this.filterMap.get(convertedType);\r\n        this.filterMap.set(convertedType, !isIncluded);\r\n        this.numberOfActiveFilters += !isIncluded ? 1 : -1;\r\n        return this.applyCurrentFilter<E>(exerciseScores);\r\n    }\r\n\r\n    /**\r\n     * Applies the current filter setting to the provided exercise scores\r\n     * @param exerciseScores the exercise scores that should be filtered against the current filter setting\r\n     * @returns exerciseScores filtered against the current filter setting\r\n     */\r\n    applyCurrentFilter<E extends TypeFilterOperatingType>(exerciseScores: TypeFilterOperatingType[]): Array<E> {\r\n        return exerciseScores.filter((score) => this.filterMap.get(ChartExerciseTypeFilter.convertToMapKey(score.exerciseType))) as Array<E>;\r\n    }\r\n\r\n    /**\r\n     * Converts a given exercise type to a map key and returns it\r\n     * @param type the exercise type\r\n     * @returns string representation of the exercise type as it is stored in the Map\r\n     */\r\n    static convertToMapKey(type: ExerciseType) {\r\n        return type.toLowerCase().replace('_', '-');\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ChartFilter", "filterMap", "Map", "numberOfActiveFilters", "getCurrentFilterState", "category", "get", "ChartCategoryFilter", "ChartFilter", "exerciseCategories", "allCategoriesSelected", "includeExercisesWithNoCategory", "exercisesWithoutCategoriesPresent", "determineDisplayableCategories", "courseExercises", "filter", "exercise", "categories", "flatMap", "map", "category", "Set", "setupCategoryFilter", "exercisesScores", "some", "exercises", "forEach", "filterMap", "set", "calculateNumberOfAppliedFilters", "numberOfActiveFilters", "size", "toggleCategory", "isIncluded", "get", "areAllCategoriesSelected", "applyCurrentFilter", "toggleExercisesWithNoCategory", "exerciseScores", "toggleAllCategories", "reduce", "value1", "value2", "newFilterStatement", "value", "__ngFactoryType__", "factory", "\u0275fac", "providedIn", "ChartExerciseTypeFilter", "ChartFilter", "typeSet", "Set", "initializeFilterOptions", "exerciseScores", "map", "score", "exerciseType", "forEach", "type", "filterMap", "set", "convertToMapKey", "numberOfActiveFilters", "size", "toggleExerciseType", "convertedType", "isIncluded", "get", "applyCurrentFilter", "filter", "toLowerCase", "replace", "__ngFactoryType__", "factory", "\u0275fac", "providedIn"]
}
