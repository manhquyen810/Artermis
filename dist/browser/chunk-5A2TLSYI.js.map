{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/programming/shared/actions/programming-exercise-trigger-build-button.component.ts"],
  "sourcesContent": ["import { Component, Input, OnChanges, OnDestroy, SimpleChanges, inject } from '@angular/core';\r\nimport { filter, tap } from 'rxjs/operators';\r\nimport { Subscription } from 'rxjs';\r\nimport { head, orderBy } from 'lodash-es';\r\nimport { ProgrammingSubmissionService, ProgrammingSubmissionState } from 'app/exercises/programming/participate/programming-submission.service';\r\nimport { InitializationState, Participation } from 'app/entities/participation/participation.model';\r\nimport { ButtonSize, ButtonType } from 'app/shared/components/button.component';\r\nimport { ParticipationWebsocketService } from 'app/overview/participation-websocket.service';\r\nimport { hasDueDatePassed } from 'app/exercises/programming/shared/utils/programming-exercise.utils';\r\nimport { Result } from 'app/entities/result.model';\r\nimport { FeatureToggle } from 'app/shared/feature-toggle/feature-toggle.service';\r\nimport { SubmissionType } from 'app/entities/submission.model';\r\nimport { ProgrammingExercise } from 'app/entities/programming/programming-exercise.model';\r\nimport { hasParticipationChanged } from 'app/exercises/shared/participation/participation.utils';\r\nimport { isManualResult } from 'app/exercises/shared/result/result.utils';\r\n\r\n/**\r\n * Component for triggering a build for the CURRENT submission of the student (does not create a new commit!).\r\n * The participation given as input needs to have the results attached as this component checks if there is at least one result.\r\n * If there is no result, the button is disabled because this would mean that the student has not made a commit yet.\r\n */\r\n@Component({\r\n    template: '',\r\n})\r\nexport abstract class ProgrammingExerciseTriggerBuildButtonComponent implements OnChanges, OnDestroy {\r\n    FeatureToggle = FeatureToggle;\r\n    ButtonType = ButtonType;\r\n\r\n    private submissionService = inject(ProgrammingSubmissionService);\r\n    private participationWebsocketService = inject(ParticipationWebsocketService);\r\n\r\n    @Input() exercise: ProgrammingExercise;\r\n    @Input() participation: Participation;\r\n    @Input() btnSize = ButtonSize.SMALL;\r\n\r\n    participationBuildCanBeTriggered: boolean;\r\n    // This only works correctly when the provided participation includes its latest result.\r\n    lastResultIsManual: boolean;\r\n    participationHasLatestSubmissionWithoutResult: boolean;\r\n    isRetrievingBuildStatus: boolean;\r\n    isBuilding: boolean;\r\n    // If true, the trigger button is also displayed for successful submissions.\r\n    showForSuccessfulSubmissions = false;\r\n\r\n    private submissionSubscription: Subscription;\r\n    private resultSubscription: Subscription;\r\n\r\n    // True if the student triggers. false if an instructor triggers it\r\n    protected personalParticipation: boolean;\r\n\r\n    /**\r\n     * Check if the participation has changed, if so set up the websocket connections.\r\n     *\r\n     * @param changes\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void {\r\n        if (hasParticipationChanged(changes)) {\r\n            // The identification of manual results is only relevant when the due date was passed, otherwise they could be overridden anyway.\r\n            if (hasDueDatePassed(this.exercise)) {\r\n                // If the last result was manual, the instructor might not want to override it with a new automatic result.\r\n                const newestResult = !!this.participation.results && head(orderBy(this.participation.results, ['id'], ['desc']));\r\n                this.lastResultIsManual = !!newestResult && isManualResult(newestResult);\r\n            }\r\n            // We can trigger the build only if the participation is active (has build plan), if the build plan was archived (new build plan will be created)\r\n            // or the due date is over.\r\n            this.participationBuildCanBeTriggered =\r\n                !!this.participation.initializationState &&\r\n                [InitializationState.INITIALIZED, InitializationState.INACTIVE, InitializationState.FINISHED].includes(this.participation.initializationState);\r\n            if (this.participationBuildCanBeTriggered) {\r\n                this.setupSubmissionSubscription();\r\n                this.setupResultSubscription();\r\n            }\r\n        }\r\n    }\r\n\r\n    ngOnDestroy(): void {\r\n        if (this.submissionSubscription) {\r\n            this.submissionSubscription.unsubscribe();\r\n        }\r\n        if (this.resultSubscription) {\r\n            this.resultSubscription.unsubscribe();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set up a websocket subscription to pending submissions to set the isBuilding flag.\r\n     * If there is a pending submission, isBuilding is set to true, otherwise to false.\r\n     */\r\n    setupSubmissionSubscription() {\r\n        if (this.submissionSubscription) {\r\n            this.submissionSubscription.unsubscribe();\r\n        }\r\n        this.submissionSubscription = this.submissionService\r\n            .getLatestPendingSubmissionByParticipationId(this.participation.id!, this.exercise.id!, this.personalParticipation)\r\n            .pipe(\r\n                tap(({ submissionState }) => {\r\n                    switch (submissionState) {\r\n                        case ProgrammingSubmissionState.HAS_NO_PENDING_SUBMISSION:\r\n                            this.isBuilding = false;\r\n                            this.participationHasLatestSubmissionWithoutResult = false;\r\n                            break;\r\n                        case ProgrammingSubmissionState.IS_BUILDING_PENDING_SUBMISSION:\r\n                            this.isBuilding = true;\r\n                            break;\r\n                        case ProgrammingSubmissionState.HAS_FAILED_SUBMISSION:\r\n                            this.participationHasLatestSubmissionWithoutResult = true;\r\n                            this.isBuilding = false;\r\n                            break;\r\n                    }\r\n                }),\r\n            )\r\n            .subscribe();\r\n    }\r\n\r\n    /**\r\n     * Set up a websocket subscription to incoming results.\r\n     * The subscription is used to determine the type of the latest result.\r\n     */\r\n    setupResultSubscription() {\r\n        if (this.resultSubscription) {\r\n            this.resultSubscription.unsubscribe();\r\n        }\r\n        this.resultSubscription = this.participationWebsocketService\r\n            .subscribeForLatestResultOfParticipation(this.participation.id!, this.personalParticipation, this.exercise.id)\r\n            .pipe(\r\n                filter((result) => !!result),\r\n                tap((result: Result) => {\r\n                    this.lastResultIsManual = !!result && isManualResult(result);\r\n                }),\r\n            )\r\n            .subscribe();\r\n    }\r\n\r\n    abstract triggerBuild(submissionType: SubmissionType): void;\r\n\r\n    triggerWithType(submissionType: SubmissionType) {\r\n        this.isRetrievingBuildStatus = true;\r\n        return this.submissionService.triggerBuild(this.participation.id!, submissionType).pipe(tap(() => (this.isRetrievingBuildStatus = false)));\r\n    }\r\n\r\n    triggerFailed(lastGraded = false) {\r\n        this.isRetrievingBuildStatus = true;\r\n        return this.submissionService.triggerFailedBuild(this.participation.id!, lastGraded).pipe(tap(() => (this.isRetrievingBuildStatus = false)));\r\n    }\r\n}\r\n"],
  "mappings": "mYAwBA,IAAsBA,GAA8C,IAAA,CAA9D,MAAgBA,CAA8C,CAChEC,cAAgBA,EAChBC,WAAaA,EAELC,kBAAoBC,EAAOC,CAA4B,EACvDC,8BAAgCF,EAAOG,CAA6B,EAEnEC,SACAC,cACAC,QAAUC,EAAWC,MAE9BC,iCAEAC,mBACAC,8CACAC,wBACAC,WAEAC,6BAA+B,GAEvBC,uBACAC,mBAGEC,sBAOVC,YAAYC,EAAsB,CAC9B,GAAIC,EAAwBD,CAAO,EAAG,CAElC,GAAIE,EAAiB,KAAKjB,QAAQ,EAAG,CAEjC,IAAMkB,EAAe,CAAC,CAAC,KAAKjB,cAAckB,SAAWC,EAAKC,EAAQ,KAAKpB,cAAckB,QAAS,CAAC,IAAI,EAAG,CAAC,MAAM,CAAC,CAAC,EAC/G,KAAKb,mBAAqB,CAAC,CAACY,GAAgBI,EAAeJ,CAAY,CAC3E,CAGA,KAAKb,iCACD,CAAC,CAAC,KAAKJ,cAAcsB,qBACrB,CAACC,EAAoBC,YAAaD,EAAoBE,SAAUF,EAAoBG,QAAQ,EAAEC,SAAS,KAAK3B,cAAcsB,mBAAmB,EAC7I,KAAKlB,mCACL,KAAKwB,4BAA2B,EAChC,KAAKC,wBAAuB,EAEpC,CACJ,CAEAC,aAAW,CACH,KAAKpB,wBACL,KAAKA,uBAAuBqB,YAAW,EAEvC,KAAKpB,oBACL,KAAKA,mBAAmBoB,YAAW,CAE3C,CAMAH,6BAA2B,CACnB,KAAKlB,wBACL,KAAKA,uBAAuBqB,YAAW,EAE3C,KAAKrB,uBAAyB,KAAKhB,kBAC9BsC,4CAA4C,KAAKhC,cAAciC,GAAK,KAAKlC,SAASkC,GAAK,KAAKrB,qBAAqB,EACjHsB,KACGC,EAAI,CAAC,CAAEC,gBAAAA,CAAe,IAAM,CACxB,OAAQA,EAAe,CACnB,KAAKC,EAA2BC,0BAC5B,KAAK9B,WAAa,GAClB,KAAKF,8CAAgD,GACrD,MACJ,KAAK+B,EAA2BE,+BAC5B,KAAK/B,WAAa,GAClB,MACJ,KAAK6B,EAA2BG,sBAC5B,KAAKlC,8CAAgD,GACrD,KAAKE,WAAa,GAClB,KACR,CACJ,CAAC,CAAC,EAELiC,UAAS,CAClB,CAMAZ,yBAAuB,CACf,KAAKlB,oBACL,KAAKA,mBAAmBoB,YAAW,EAEvC,KAAKpB,mBAAqB,KAAKd,8BAC1B6C,wCAAwC,KAAK1C,cAAciC,GAAK,KAAKrB,sBAAuB,KAAKb,SAASkC,EAAE,EAC5GC,KACGS,EAAQC,GAAW,CAAC,CAACA,CAAM,EAC3BT,EAAKS,GAAkB,CACnB,KAAKvC,mBAAqB,CAAC,CAACuC,GAAUvB,EAAeuB,CAAM,CAC/D,CAAC,CAAC,EAELH,UAAS,CAClB,CAIAI,gBAAgBC,EAA8B,CAC1C,YAAKvC,wBAA0B,GACxB,KAAKb,kBAAkBqD,aAAa,KAAK/C,cAAciC,GAAKa,CAAc,EAAEZ,KAAKC,EAAI,IAAO,KAAK5B,wBAA0B,EAAM,CAAC,CAC7I,CAEAyC,cAAcC,EAAa,GAAK,CAC5B,YAAK1C,wBAA0B,GACxB,KAAKb,kBAAkBwD,mBAAmB,KAAKlD,cAAciC,GAAKgB,CAAU,EAAEf,KAAKC,EAAI,IAAO,KAAK5B,wBAA0B,EAAM,CAAC,CAC/I,4CAvHkBhB,EAA8C,2BAA9CA,EAA8C4D,UAAA,CAAA,CAAA,cAAA,CAAA,EAAAC,OAAA,CAAArD,SAAA,WAAAC,cAAA,gBAAAC,QAAA,SAAA,EAAAoD,SAAA,CAAAC,CAAA,EAAAC,MAAA,EAAAC,KAAA,EAAAC,SAAA,SAAAC,EAAAC,EAAA,CAAA,EAAAC,cAAA,CAAA,CAAA,SAA9CrE,CAA8C,GAAA",
  "names": ["ProgrammingExerciseTriggerBuildButtonComponent", "FeatureToggle", "ButtonType", "submissionService", "inject", "ProgrammingSubmissionService", "participationWebsocketService", "ParticipationWebsocketService", "exercise", "participation", "btnSize", "ButtonSize", "SMALL", "participationBuildCanBeTriggered", "lastResultIsManual", "participationHasLatestSubmissionWithoutResult", "isRetrievingBuildStatus", "isBuilding", "showForSuccessfulSubmissions", "submissionSubscription", "resultSubscription", "personalParticipation", "ngOnChanges", "changes", "hasParticipationChanged", "hasDueDatePassed", "newestResult", "results", "head", "orderBy", "isManualResult", "initializationState", "InitializationState", "INITIALIZED", "INACTIVE", "FINISHED", "includes", "setupSubmissionSubscription", "setupResultSubscription", "ngOnDestroy", "unsubscribe", "getLatestPendingSubmissionByParticipationId", "id", "pipe", "tap", "submissionState", "ProgrammingSubmissionState", "HAS_NO_PENDING_SUBMISSION", "IS_BUILDING_PENDING_SUBMISSION", "HAS_FAILED_SUBMISSION", "subscribe", "subscribeForLatestResultOfParticipation", "filter", "result", "triggerWithType", "submissionType", "triggerBuild", "triggerFailed", "lastGraded", "triggerFailedBuild", "selectors", "inputs", "features", "\u0275\u0275NgOnChangesFeature", "decls", "vars", "template", "rf", "ctx", "encapsulation"]
}
