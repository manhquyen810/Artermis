{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/shared/exercise/exercise.utils.ts"],
  "sourcesContent": ["import { SimpleChanges } from '@angular/core';\r\nimport { Exercise, ExerciseType } from 'app/entities/exercise.model';\r\nimport dayjs from 'dayjs/esm';\r\nimport { InitializationState, Participation } from 'app/entities/participation/participation.model';\r\nimport { ProgrammingExercise } from 'app/entities/programming/programming-exercise.model';\r\nimport { AssessmentType } from 'app/entities/assessment-type.model';\r\nimport { QuizExercise } from 'app/entities/quiz/quiz-exercise.model';\r\nimport { Observable, from, of } from 'rxjs';\r\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap';\r\nimport { ExerciseUpdateWarningService } from 'app/exercises/shared/exercise-update-warning/exercise-update-warning.service';\r\nimport { ExerciseServicable } from 'app/exercises/shared/exercise/exercise.service';\r\nimport { map, mergeMap, mergeWith, takeUntil } from 'rxjs/operators';\r\nimport { ExerciseUpdateWarningComponent } from 'app/exercises/shared/exercise-update-warning/exercise-update-warning.component';\r\nimport { AlertService, AlertType } from 'app/core/util/alert.service';\r\nimport { StudentParticipation, isPracticeMode } from 'app/entities/participation/student-participation.model';\r\n\r\nexport enum EditType {\r\n    IMPORT,\r\n    CREATE,\r\n    UPDATE,\r\n}\r\n\r\nexport class SaveExerciseCommand<T extends Exercise> {\r\n    constructor(\r\n        private modalService: NgbModal,\r\n        private popupService: ExerciseUpdateWarningService,\r\n        private exerciseService: ExerciseServicable<T>,\r\n        private backupExercise: T,\r\n        private editType: EditType,\r\n        private alertService: AlertService,\r\n    ) {}\r\n\r\n    save(exercise: T, isExamMode: boolean, notificationText?: string): Observable<T> {\r\n        const prepareRequestOptions = (): any => {\r\n            switch (this.editType) {\r\n                case EditType.UPDATE:\r\n                    return notificationText ? { notificationText } : {};\r\n                default:\r\n                    return {};\r\n            }\r\n        };\r\n\r\n        if (exercise.exampleSolutionPublicationDateWarning) {\r\n            this.alertService.addAlert({\r\n                type: AlertType.WARNING,\r\n                message: 'artemisApp.exercise.exampleSolutionPublicationDateWarning',\r\n            });\r\n        }\r\n\r\n        const callServer = ([shouldReevaluate, requestOptions]: [boolean, any?]) => {\r\n            const ex = Exercise.sanitize(exercise);\r\n            switch (this.editType) {\r\n                case EditType.IMPORT:\r\n                    return this.exerciseService.import!(ex);\r\n                case EditType.CREATE:\r\n                    return this.exerciseService.create(ex);\r\n                case EditType.UPDATE:\r\n                    if (shouldReevaluate) {\r\n                        return this.exerciseService.reevaluateAndUpdate(ex, requestOptions);\r\n                    } else {\r\n                        return this.exerciseService.update(ex, requestOptions);\r\n                    }\r\n            }\r\n        };\r\n\r\n        let saveObservable = of([false, prepareRequestOptions()]);\r\n\r\n        const popupRefObs = from(this.popupService.checkExerciseBeforeUpdate(exercise, this.backupExercise, isExamMode));\r\n\r\n        if (this.modalService.hasOpenModals()) {\r\n            const confirmedCase = popupRefObs.pipe(\r\n                mergeMap((ref) => (ref.componentInstance as ExerciseUpdateWarningComponent).confirmed.pipe(map(() => [false, prepareRequestOptions()]))),\r\n            );\r\n            const reEvaluatedCase = popupRefObs.pipe(\r\n                mergeMap((ref) =>\r\n                    (ref.componentInstance as ExerciseUpdateWarningComponent).reEvaluated.pipe(map(() => [true, { deleteFeedback: ref.componentInstance.deleteFeedback }])),\r\n                ),\r\n            );\r\n            const canceledCase = popupRefObs.pipe(mergeMap((ref) => (ref.componentInstance as ExerciseUpdateWarningComponent).canceled));\r\n\r\n            saveObservable = confirmedCase.pipe(mergeWith(reEvaluatedCase), takeUntil(canceledCase));\r\n        }\r\n\r\n        return saveObservable.pipe(\r\n            mergeMap(callServer),\r\n            map((res) => res.body! as T),\r\n        );\r\n    }\r\n}\r\n\r\nexport const hasExerciseChanged = (changes: SimpleChanges) => {\r\n    return changes.exercise && changes.exercise.currentValue && (!changes.exercise.previousValue || changes.exercise.previousValue.id !== changes.exercise.currentValue.id);\r\n};\r\n\r\nexport const problemStatementHasChanged = (changes: SimpleChanges) => {\r\n    return (\r\n        changes.exercise &&\r\n        changes.exercise.currentValue &&\r\n        (!changes.exercise.previousValue || changes.exercise.previousValue.problemStatement !== changes.exercise.currentValue.problemStatement)\r\n    );\r\n};\r\n\r\n/**\r\n * Checks if the due date of a given exercise lies in the past. If there is no due date it evaluates to false.\r\n *\r\n * @param exercise the participation belongs to.\r\n * @param participation needed to check for an individual due date.\r\n * @return {boolean} true, if the (individual) due date is in the past.\r\n */\r\nexport const hasExerciseDueDatePassed = (exercise: Exercise, participation?: Participation): boolean => {\r\n    if (exercise.dueDate === undefined) {\r\n        return false;\r\n    }\r\n\r\n    const referenceDate = getExerciseDueDate(exercise, participation)!;\r\n    return dayjs(referenceDate).isBefore(dayjs());\r\n};\r\n\r\n/**\r\n * Returns the due date for an exercise.\r\n *\r\n * This might either be an individual due date for a participation, the\r\n * exercise due date itself, or no due date if the exercise has none.\r\n * @param exercise the participation belongs to.\r\n * @param participation for which the due date should be found.\r\n */\r\nexport function getExerciseDueDate(exercise: Exercise, participation?: Participation): dayjs.Dayjs | undefined {\r\n    if (exercise.dueDate === undefined) {\r\n        return undefined;\r\n    } else {\r\n        return participation?.individualDueDate ?? exercise.dueDate;\r\n    }\r\n}\r\n\r\n/**\r\n * Determines if the exercise can be started, this is the case if:\r\n * - In case of a programming exercise it is not before the due date\r\n * - There is no participation or in case of a programming exercise the setup is not yet finished\r\n * @param exercise the exercise that should be started\r\n * @param participation the potentially existing participation\r\n */\r\nexport const isStartExerciseAvailable = (exercise: Exercise, participation?: StudentParticipation): boolean => {\r\n    const isProgrammingExercise = exercise.type === ExerciseType.PROGRAMMING;\r\n    const validDueDate = !isProgrammingExercise || !exercise.dueDate || dayjs().isBefore(exercise.dueDate);\r\n\r\n    return validDueDate && (!participation || (isProgrammingExercise && programmingSetupNotFinished(participation)));\r\n};\r\n\r\n/**\r\n * Determines if the student can resume a participation\r\n * @param exercise the exercise that should be started\r\n * @param participation the optional student participation with possibly an individual due date\r\n */\r\nexport const isResumeExerciseAvailable = (exercise: Exercise, participation?: StudentParticipation): boolean => {\r\n    const dueDate = participation?.individualDueDate ?? exercise.dueDate;\r\n    // A normal participation may only be resumed before the due date, a testrun only afterwards\r\n    return (!dueDate || dayjs().isBefore(dueDate)) === !isPracticeMode(participation);\r\n};\r\n\r\n/**\r\n * The start practice button should be available for programming and quiz exercises\r\n * - For quizzes when they are open for practice and the regular work period is over\r\n * - For programming exercises when it's after the due date\r\n * @param exercise the exercise that the student wants to practice\r\n * @param participation the potentially existing participation\r\n */\r\nexport const isStartPracticeAvailable = (exercise: Exercise, participation?: StudentParticipation): boolean => {\r\n    switch (exercise.type) {\r\n        case ExerciseType.QUIZ:\r\n            const quizExercise = exercise as QuizExercise;\r\n            return !!(quizExercise.isOpenForPractice && quizExercise.quizEnded);\r\n        case ExerciseType.PROGRAMMING:\r\n            return exercise.dueDate != undefined && dayjs().isAfter(exercise.dueDate) && !exercise.teamMode && (!participation || programmingSetupNotFinished(participation));\r\n        default:\r\n            return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Checks whether the given exercise is eligible for receiving manual results.\r\n * If it is a programming exercise, the due date also has to be in the past.\r\n *\r\n * @param exercise\r\n */\r\nexport const areManualResultsAllowed = (exercise: Exercise): boolean => {\r\n    if (exercise.type === ExerciseType.QUIZ) {\r\n        return false;\r\n    } else if (exercise.type !== ExerciseType.PROGRAMMING) {\r\n        return !exercise.dueDate || dayjs().isAfter(exercise.dueDate);\r\n    } else {\r\n        const relevantDueDate = (exercise as ProgrammingExercise).buildAndTestStudentSubmissionsAfterDueDate ?? exercise.dueDate;\r\n        return exercise.assessmentType !== AssessmentType.AUTOMATIC && (!relevantDueDate || dayjs().isAfter(relevantDueDate));\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the positive and capped to maximum points which is fixed at two decimal numbers\r\n *\r\n * @param totalScore the calculated score of a student\r\n * @param maxPoints the maximal points (including bonus points) of an exercise\r\n */\r\nexport const getPositiveAndCappedTotalScore = (totalScore: number, maxPoints: number): number => {\r\n    // Do not allow negative score\r\n    if (totalScore < 0) {\r\n        totalScore = 0;\r\n    }\r\n    // Cap totalScore to maxPoints\r\n    if (totalScore > maxPoints) {\r\n        totalScore = maxPoints;\r\n    }\r\n\r\n    return +totalScore.toFixed(2);\r\n};\r\n\r\nexport const getTotalMaxPoints = (exercise?: Exercise): number => {\r\n    return (exercise?.maxPoints ?? 0) + (exercise?.bonusPoints ?? 0);\r\n};\r\n\r\nconst programmingSetupNotFinished = (participation: StudentParticipation): boolean => {\r\n    return (\r\n        !!participation.initializationState &&\r\n        [InitializationState.UNINITIALIZED, InitializationState.BUILD_PLAN_CONFIGURED, InitializationState.REPO_CONFIGURED, InitializationState.REPO_COPIED].includes(\r\n            participation.initializationState,\r\n        )\r\n    );\r\n};\r\n"],
  "mappings": "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",
  "names": ["EditType", "SaveExerciseCommand", "modalService", "popupService", "exerciseService", "backupExercise", "editType", "alertService", "constructor", "save", "exercise", "isExamMode", "notificationText", "prepareRequestOptions", "UPDATE", "exampleSolutionPublicationDateWarning", "addAlert", "type", "AlertType", "WARNING", "message", "callServer", "shouldReevaluate", "requestOptions", "ex", "Exercise", "sanitize", "IMPORT", "import", "CREATE", "create", "reevaluateAndUpdate", "update", "saveObservable", "of", "popupRefObs", "from", "checkExerciseBeforeUpdate", "hasOpenModals", "confirmedCase", "pipe", "mergeMap", "ref", "componentInstance", "confirmed", "map", "reEvaluatedCase", "reEvaluated", "deleteFeedback", "canceledCase", "canceled", "mergeWith", "takeUntil", "res", "body", "hasExerciseChanged", "changes", "currentValue", "previousValue", "id", "problemStatementHasChanged", "problemStatement", "hasExerciseDueDatePassed", "participation", "dueDate", "undefined", "referenceDate", "getExerciseDueDate", "dayjs", "isBefore", "individualDueDate", "isStartExerciseAvailable", "isProgrammingExercise", "ExerciseType", "PROGRAMMING", "programmingSetupNotFinished", "isResumeExerciseAvailable", "isPracticeMode", "isStartPracticeAvailable", "QUIZ", "quizExercise", "isOpenForPractice", "quizEnded", "isAfter", "teamMode", "areManualResultsAllowed", "relevantDueDate", "buildAndTestStudentSubmissionsAfterDueDate", "assessmentType", "AssessmentType", "AUTOMATIC", "getPositiveAndCappedTotalScore", "totalScore", "maxPoints", "toFixed", "getTotalMaxPoints", "bonusPoints", "initializationState", "InitializationState", "UNINITIALIZED", "BUILD_PLAN_CONFIGURED", "REPO_CONFIGURED", "REPO_COPIED", "includes"]
}
