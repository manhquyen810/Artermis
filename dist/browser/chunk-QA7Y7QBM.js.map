{
  "version": 3,
  "sources": ["src/main/webapp/app/shared/server-date.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport dayjs from 'dayjs/esm';\r\nimport { HttpClient } from '@angular/common/http';\r\n\r\nexport interface ServerDateService {\r\n    readonly http: HttpClient;\r\n    readonly resourceUrl: string;\r\n    // offsets of the last synchronizations in ms (max. 5)\r\n    readonly recentOffsets: Array<number>;\r\n    // client (!) dates of the last synchronizations (max. 5)\r\n    readonly recentClientDates: Array<dayjs.Dayjs>;\r\n    updateTime: () => void;\r\n    setServerDate: (date: string) => void;\r\n    now: () => dayjs.Dayjs;\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ArtemisServerDateService implements ServerDateService {\r\n    resourceUrl: string;\r\n    recentOffsets: number[];\r\n    recentClientDates: dayjs.Dayjs[];\r\n    http: HttpClient;\r\n\r\n    constructor() {\r\n        const http = inject(HttpClient);\r\n\r\n        this.http = http;\r\n        this.resourceUrl = 'api/core/public/time';\r\n        this.recentOffsets = new Array<number>();\r\n        this.recentClientDates = new Array<dayjs.Dayjs>();\r\n    }\r\n\r\n    /**\r\n     * get a new server date if necessary\r\n     */\r\n    updateTime(): void {\r\n        let shouldSync: boolean;\r\n        const now = dayjs(new Date());\r\n        if (this.recentClientDates.length > 4) {\r\n            // only if some recent client dates (i.e. recent syncs) are older than 60s\r\n            shouldSync = this.recentClientDates.some((recentClientDate) => Math.abs(now.diff(recentClientDate, 's')) > 60);\r\n        } else {\r\n            // definitely sync if we do not have 5 elements yet\r\n            shouldSync = true;\r\n        }\r\n        // TODO: one additional optimization could be to take the duration for request -> response into account here\r\n        if (shouldSync) {\r\n            // get new server date\r\n            this.http.get<string>(this.resourceUrl).subscribe((serverDate) => {\r\n                this.setServerDate(serverDate);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * adds the latest offset\r\n     *\r\n     * @param {string} date\r\n     */\r\n    setServerDate(date: string): void {\r\n        const serverDate = dayjs(date);\r\n        const clientDate = dayjs();\r\n        // save the most recent client date\r\n        this.recentClientDates.push(clientDate);\r\n        // calculate offset\r\n        const offset = serverDate.diff(clientDate, 'ms');\r\n        // save the most recent offset\r\n        this.recentOffsets.push(offset);\r\n        // remove oldest offset and client date if more than 5\r\n        if (this.recentOffsets.length > 5) {\r\n            this.recentOffsets.shift();\r\n            this.recentClientDates.shift();\r\n        }\r\n        // This would be faster and more reliable than using an interceptor with arbitrary REST calls\r\n    }\r\n\r\n    /**\r\n     * returns the calculated current server date as dayjs\r\n     */\r\n    now(): dayjs.Dayjs {\r\n        const clientDate = dayjs();\r\n        // return the client date if there are no offsets (e.g. when offline or before any api call was made)\r\n        if (this.recentOffsets.length === 0) {\r\n            return clientDate;\r\n        }\r\n        // take first offset if there are less than 5\r\n        let offset = this.recentOffsets[0];\r\n        // remove noise from offset if there are 5\r\n        if (this.recentOffsets.length === 5) {\r\n            // work on copy of array\r\n            const offsetsCopy = [...this.recentOffsets];\r\n            const offsetsSorted = offsetsCopy.sort((a, b) => b - a);\r\n            // remove lowest\r\n            offsetsSorted.shift();\r\n            // remove highest\r\n            offsetsSorted.pop();\r\n            // calculate avg\r\n            offset = offsetsSorted.reduce((a, b) => a + b) / offsetsSorted.length;\r\n        }\r\n        // adjust with previously calculated offset\r\n        return clientDate.add(offset, 'ms');\r\n    }\r\n}\r\n"],
  "mappings": "iIAiBA,IAAaA,GAAwB,IAAA,CAA/B,MAAOA,CAAwB,CACjCC,YACAC,cACAC,kBACAC,KAEAC,aAAA,CACI,IAAMD,EAAOE,EAAOC,CAAU,EAE9B,KAAKH,KAAOA,EACZ,KAAKH,YAAc,uBACnB,KAAKC,cAAgB,IAAIM,MACzB,KAAKL,kBAAoB,IAAIK,KACjC,CAKAC,YAAU,CACN,IAAIC,EACEC,EAAMC,EAAM,IAAIC,IAAM,EACxB,KAAKV,kBAAkBW,OAAS,EAEhCJ,EAAa,KAAKP,kBAAkBY,KAAMC,GAAqBC,KAAKC,IAAIP,EAAIQ,KAAKH,EAAkB,GAAG,CAAC,EAAI,EAAE,EAG7GN,EAAa,GAGbA,GAEA,KAAKN,KAAKgB,IAAY,KAAKnB,WAAW,EAAEoB,UAAWC,GAAc,CAC7D,KAAKC,cAAcD,CAAU,CACjC,CAAC,CAET,CAOAC,cAAcC,EAAY,CACtB,IAAMF,EAAaV,EAAMY,CAAI,EACvBC,EAAab,EAAK,EAExB,KAAKT,kBAAkBuB,KAAKD,CAAU,EAEtC,IAAME,EAASL,EAAWH,KAAKM,EAAY,IAAI,EAE/C,KAAKvB,cAAcwB,KAAKC,CAAM,EAE1B,KAAKzB,cAAcY,OAAS,IAC5B,KAAKZ,cAAc0B,MAAK,EACxB,KAAKzB,kBAAkByB,MAAK,EAGpC,CAKAjB,KAAG,CACC,IAAMc,EAAab,EAAK,EAExB,GAAI,KAAKV,cAAcY,SAAW,EAC9B,OAAOW,EAGX,IAAIE,EAAS,KAAKzB,cAAc,CAAC,EAEjC,GAAI,KAAKA,cAAcY,SAAW,EAAG,CAGjC,IAAMe,EADc,CAAC,GAAG,KAAK3B,aAAa,EACR4B,KAAK,CAACC,EAAGC,IAAMA,EAAID,CAAC,EAEtDF,EAAcD,MAAK,EAEnBC,EAAcI,IAAG,EAEjBN,EAASE,EAAcK,OAAO,CAACH,EAAGC,IAAMD,EAAIC,CAAC,EAAIH,EAAcf,MACnE,CAEA,OAAOW,EAAWU,IAAIR,EAAQ,IAAI,CACtC,4CApFS3B,EAAwB,6BAAxBA,EAAwBoC,QAAxBpC,EAAwBqC,UAAAC,WADX,MAAM,CAAA,SACnBtC,CAAwB,GAAA",
  "names": ["ArtemisServerDateService", "resourceUrl", "recentOffsets", "recentClientDates", "http", "constructor", "inject", "HttpClient", "Array", "updateTime", "shouldSync", "now", "dayjs", "Date", "length", "some", "recentClientDate", "Math", "abs", "diff", "get", "subscribe", "serverDate", "setServerDate", "date", "clientDate", "push", "offset", "shift", "offsetsSorted", "sort", "a", "b", "pop", "reduce", "add", "factory", "\u0275fac", "providedIn"]
}
