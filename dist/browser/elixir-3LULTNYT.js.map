{"version":3,"sources":["node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js"],"sourcesContent":["/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\n// src/basic-languages/elixir/elixir.ts\nvar conf = {\n  comments: {\n    lineComment: \"#\"\n  },\n  brackets: [[\"{\", \"}\"], [\"[\", \"]\"], [\"(\", \")\"]],\n  surroundingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }],\n  autoClosingPairs: [{\n    open: \"'\",\n    close: \"'\",\n    notIn: [\"string\", \"comment\"]\n  }, {\n    open: '\"',\n    close: '\"',\n    notIn: [\"comment\"]\n  }, {\n    open: '\"\"\"',\n    close: '\"\"\"'\n  }, {\n    open: \"`\",\n    close: \"`\",\n    notIn: [\"string\", \"comment\"]\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"<<\",\n    close: \">>\"\n  }],\n  indentationRules: {\n    increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n    decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n  }\n};\nvar language = {\n  defaultToken: \"source\",\n  tokenPostfix: \".elixir\",\n  brackets: [{\n    open: \"[\",\n    close: \"]\",\n    token: \"delimiter.square\"\n  }, {\n    open: \"(\",\n    close: \")\",\n    token: \"delimiter.parenthesis\"\n  }, {\n    open: \"{\",\n    close: \"}\",\n    token: \"delimiter.curly\"\n  }, {\n    open: \"<<\",\n    close: \">>\",\n    token: \"delimiter.angle.special\"\n  }],\n  // Below are lists/regexps to which we reference later.\n  declarationKeywords: [\"def\", \"defp\", \"defn\", \"defnp\", \"defguard\", \"defguardp\", \"defmacro\", \"defmacrop\", \"defdelegate\", \"defcallback\", \"defmacrocallback\", \"defmodule\", \"defprotocol\", \"defexception\", \"defimpl\", \"defstruct\"],\n  operatorKeywords: [\"and\", \"in\", \"not\", \"or\", \"when\"],\n  namespaceKeywords: [\"alias\", \"import\", \"require\", \"use\"],\n  otherKeywords: [\"after\", \"case\", \"catch\", \"cond\", \"do\", \"else\", \"end\", \"fn\", \"for\", \"if\", \"quote\", \"raise\", \"receive\", \"rescue\", \"super\", \"throw\", \"try\", \"unless\", \"unquote_splicing\", \"unquote\", \"with\"],\n  constants: [\"true\", \"false\", \"nil\"],\n  nameBuiltin: [\"__MODULE__\", \"__DIR__\", \"__ENV__\", \"__CALLER__\", \"__STACKTRACE__\"],\n  // Matches any of the operator names:\n  // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n  operator: /-[->]?|!={0,2}|\\*{1,2}|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n  variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n  atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n  specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n  aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n  moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n  // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n  sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n  sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n  sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n  sigilModifiers: /[a-zA-Z0-9]*/,\n  decimal: /\\d(?:_?\\d)*/,\n  hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n  octal: /[0-7](_?[0-7])*/,\n  binary: /[01](_?[01])*/,\n  // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n  escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n  // The keys below correspond to tokenizer states.\n  // We start from the root state and match against its rules\n  // until we explicitly transition into another state.\n  // The `include` simply brings in all operations from the given state\n  // and is useful for improving readability.\n  tokenizer: {\n    root: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@comments\"\n    },\n    // Keywords start as either an identifier or a string,\n    // but end with a : so it's important to match this first.\n    {\n      include: \"@keywordsShorthand\"\n    }, {\n      include: \"@numbers\"\n    }, {\n      include: \"@identifiers\"\n    }, {\n      include: \"@strings\"\n    }, {\n      include: \"@atoms\"\n    }, {\n      include: \"@sigils\"\n    }, {\n      include: \"@attributes\"\n    }, {\n      include: \"@symbols\"\n    }],\n    // Whitespace\n    whitespace: [[/\\s+/, \"white\"]],\n    // Comments\n    comments: [[/(#)(.*)/, [\"comment.punctuation\", \"comment\"]]],\n    // Keyword list shorthand\n    keywordsShorthand: [[/(@atomName)(:)(\\s+)/, [\"constant\", \"constant.punctuation\", \"white\"]],\n    // Use positive look-ahead to ensure the string is followed by :\n    // and should be considered a keyword.\n    [/\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/, {\n      token: \"constant.delimiter\",\n      next: \"@doubleQuotedStringKeyword\"\n    }], [/'(?=([^']|#\\{.*?\\}|\\\\')*':)/, {\n      token: \"constant.delimiter\",\n      next: \"@singleQuotedStringKeyword\"\n    }]],\n    doubleQuotedStringKeyword: [[/\":/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    singleQuotedStringKeyword: [[/':/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    // Numbers\n    numbers: [[/0b@binary/, \"number.binary\"], [/0o@octal/, \"number.octal\"], [/0x@hex/, \"number.hex\"], [/@decimal\\.@decimal([eE]-?@decimal)?/, \"number.float\"], [/@decimal/, \"number\"]],\n    // Identifiers\n    identifiers: [\n    // Tokenize identifier name in function-like definitions.\n    // Note: given `def a + b, do: nil`, `a` is not a function name,\n    // so we use negative look-ahead to ensure there's no operator.\n    [/\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/, [\"keyword.declaration\", \"white\", {\n      cases: {\n        unquote: \"keyword\",\n        \"@default\": \"function\"\n      }\n    }]],\n    // Tokenize function calls\n    [\n    // In-scope call - an identifier followed by ( or .(\n    /(@variableName)(?=\\s*\\.?\\s*\\()/, {\n      cases: {\n        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n        \"@declarationKeywords\": \"keyword.declaration\",\n        \"@namespaceKeywords\": \"keyword\",\n        \"@otherKeywords\": \"keyword\",\n        \"@default\": \"function.call\"\n      }\n    }], [\n    // Referencing function in a module\n    /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/, [\"type.identifier\", \"white\", \"operator\", \"white\", \"function.call\"]], [\n    // Referencing function in an Erlang module\n    /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/, [\"constant.punctuation\", \"constant\", \"white\", \"operator\", \"white\", \"function.call\"]], [\n    // Piping into a function (tokenized separately as it may not have parentheses)\n    /(\\|>)(\\s*)(@variableName)/, [\"operator\", \"white\", {\n      cases: {\n        \"@otherKeywords\": \"keyword\",\n        \"@default\": \"function.call\"\n      }\n    }]], [\n    // Function reference passed to another function\n    /(&)(\\s*)(@variableName)/, [\"operator\", \"white\", \"function.call\"]],\n    // Language keywords, builtins, constants and variables\n    [/@variableName/, {\n      cases: {\n        \"@declarationKeywords\": \"keyword.declaration\",\n        \"@operatorKeywords\": \"keyword.operator\",\n        \"@namespaceKeywords\": \"keyword\",\n        \"@otherKeywords\": \"keyword\",\n        \"@constants\": \"constant.language\",\n        \"@nameBuiltin\": \"variable.language\",\n        \"_.*\": \"comment.unused\",\n        \"@default\": \"identifier\"\n      }\n    }],\n    // Module names\n    [/@moduleName/, \"type.identifier\"]],\n    // Strings\n    strings: [[/\"\"\"/, {\n      token: \"string.delimiter\",\n      next: \"@doubleQuotedHeredoc\"\n    }], [/'''/, {\n      token: \"string.delimiter\",\n      next: \"@singleQuotedHeredoc\"\n    }], [/\"/, {\n      token: \"string.delimiter\",\n      next: \"@doubleQuotedString\"\n    }], [/'/, {\n      token: \"string.delimiter\",\n      next: \"@singleQuotedString\"\n    }]],\n    doubleQuotedHeredoc: [[/\"\"\"/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    singleQuotedHeredoc: [[/'''/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    doubleQuotedString: [[/\"/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    singleQuotedString: [[/'/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    // Atoms\n    atoms: [[/(:)(@atomName)/, [\"constant.punctuation\", \"constant\"]], [/:\"/, {\n      token: \"constant.delimiter\",\n      next: \"@doubleQuotedStringAtom\"\n    }], [/:'/, {\n      token: \"constant.delimiter\",\n      next: \"@singleQuotedStringAtom\"\n    }]],\n    doubleQuotedStringAtom: [[/\"/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    singleQuotedStringAtom: [[/'/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    // Sigils\n    // See https://elixir-lang.org/getting-started/sigils.html\n    // Sigils allow for typing values using their textual representation.\n    // All sigils start with ~ followed by a letter or\n    // multi-letter uppercase starting at Elixir v1.15.0, indicating sigil type\n    // and then a delimiter pair enclosing the textual representation.\n    // Optional modifiers are allowed after the closing delimiter.\n    // For instance a regular expressions can be written as:\n    // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n    //\n    // In general lowercase sigils allow for interpolation\n    // and escaped characters, whereas uppercase sigils don't\n    //\n    // During tokenization we want to distinguish some\n    // specific sigil types, namely string and regexp,\n    // so that they cen be themed separately.\n    //\n    // To reasonably handle all those combinations we leverage\n    // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n    // then \"sigilStart.interpol.s\" state will match and also all\n    // the individual dot-separated parameters can be accessed.\n    sigils: [[/~[a-z]@sigilStartDelimiter/, {\n      token: \"@rematch\",\n      next: \"@sigil.interpol\"\n    }], [/~([A-Z]+)@sigilStartDelimiter/, {\n      token: \"@rematch\",\n      next: \"@sigil.noInterpol\"\n    }]],\n    sigil: [[/~([a-z]|[A-Z]+)\\{/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.{.}\"\n    }], [/~([a-z]|[A-Z]+)\\[/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.[.]\"\n    }], [/~([a-z]|[A-Z]+)\\(/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.(.)\"\n    }], [/~([a-z]|[A-Z]+)\\</, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.<.>\"\n    }], [/~([a-z]|[A-Z]+)(@sigilSymmetricDelimiter)/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.$2.$2\"\n    }]],\n    // The definitions below expect states to be of the form:\n    //\n    // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    //\n    // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n    // and immediately switches to the sigilContinue sate, which handles the actual content\n    // and waits for the corresponding end delimiter.\n    \"sigilStart.interpol.s\": [[/~s@sigilStartDelimiter/, {\n      token: \"string.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.interpol.s\": [[/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"string.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"string\"\n      }\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    \"sigilStart.noInterpol.S\": [[/~S@sigilStartDelimiter/, {\n      token: \"string.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.noInterpol.S\": [\n    // Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"string\"], [/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"string.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"string\"\n      }\n    }], {\n      include: \"@stringContent\"\n    }],\n    \"sigilStart.interpol.r\": [[/~r@sigilStartDelimiter/, {\n      token: \"regexp.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.interpol.r\": [[/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"regexp.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"regexp\"\n      }\n    }], {\n      include: \"@regexpContentInterpol\"\n    }],\n    \"sigilStart.noInterpol.R\": [[/~R@sigilStartDelimiter/, {\n      token: \"regexp.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.noInterpol.R\": [\n    // Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"regexp\"], [/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"regexp.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"regexp\"\n      }\n    }], {\n      include: \"@regexpContent\"\n    }],\n    // Fallback to the generic sigil by default\n    \"sigilStart.interpol\": [[/~([a-z]|[A-Z]+)@sigilStartDelimiter/, {\n      token: \"sigil.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.interpol\": [[/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"sigil.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"sigil\"\n      }\n    }], {\n      include: \"@sigilContentInterpol\"\n    }],\n    \"sigilStart.noInterpol\": [[/~([a-z]|[A-Z]+)@sigilStartDelimiter/, {\n      token: \"sigil.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.noInterpol\": [\n    // Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"sigil\"], [/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"sigil.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"sigil\"\n      }\n    }], {\n      include: \"@sigilContent\"\n    }],\n    // Attributes\n    attributes: [\n    // Module @doc* attributes - tokenized as comments\n    [/\\@(module|type)?doc (~[sS])?\"\"\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@doubleQuotedHeredocDocstring\"\n    }], [/\\@(module|type)?doc (~[sS])?'''/, {\n      token: \"comment.block.documentation\",\n      next: \"@singleQuotedHeredocDocstring\"\n    }], [/\\@(module|type)?doc (~[sS])?\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@doubleQuotedStringDocstring\"\n    }], [/\\@(module|type)?doc (~[sS])?'/, {\n      token: \"comment.block.documentation\",\n      next: \"@singleQuotedStringDocstring\"\n    }], [/\\@(module|type)?doc false/, \"comment.block.documentation\"],\n    // Module attributes\n    [/\\@(@variableName)/, \"variable\"]],\n    doubleQuotedHeredocDocstring: [[/\"\"\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    singleQuotedHeredocDocstring: [[/'''/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    doubleQuotedStringDocstring: [[/\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    singleQuotedStringDocstring: [[/'/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    // Operators, punctuation, brackets\n    symbols: [\n    // Code point operator (either with regular character ?a or an escaped one ?\\n)\n    [/\\?(\\\\.|[^\\\\\\s])/, \"number.constant\"],\n    // Anonymous function arguments\n    [/&\\d+/, \"operator\"],\n    // Bitshift operators (must go before delimiters, so that << >> don't match first)\n    [/<<<|>>>/, \"operator\"],\n    // Delimiter pairs\n    [/[()\\[\\]\\{\\}]|<<|>>/, \"@brackets\"],\n    // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n    [/\\.\\.\\./, \"identifier\"],\n    // Punctuation => (must go before operators, so it's not tokenized as = then >)\n    [/=>/, \"punctuation\"],\n    // Operators\n    [/@operator/, \"operator\"],\n    // Punctuation\n    [/[:;,.%]/, \"punctuation\"]],\n    // Generic helpers\n    stringContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@stringContent\"\n    }],\n    stringContent: [[/./, \"string\"]],\n    stringConstantContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@stringConstantContent\"\n    }],\n    stringConstantContent: [[/./, \"constant\"]],\n    regexpContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@regexpContent\"\n    }],\n    regexpContent: [\n    // # may be a regular regexp char, so we use a heuristic\n    // assuming a # surrounded by whitespace is actually a comment.\n    [/(\\s)(#)(\\s.*)$/, [\"white\", \"comment.punctuation\", \"comment\"]], [/./, \"regexp\"]],\n    sigilContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@sigilContent\"\n    }],\n    sigilContent: [[/./, \"sigil\"]],\n    docstringContent: [[/./, \"comment.block.documentation\"]],\n    escapeChar: [[/@escape/, \"constant.character.escape\"]],\n    interpolation: [[/#{/, {\n      token: \"delimiter.bracket.embed\",\n      next: \"@interpolationContinue\"\n    }]],\n    interpolationContinue: [[/}/, {\n      token: \"delimiter.bracket.embed\",\n      next: \"@pop\"\n    }],\n    // Interpolation brackets may contain arbitrary code,\n    // so we simply match against all the root rules,\n    // until we reach interpolation end (the above matches).\n    {\n      include: \"@root\"\n    }]\n  }\n};\nexport { conf, language };"],"mappings":"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","names":["conf","language"],"x_google_ignoreList":[0]}