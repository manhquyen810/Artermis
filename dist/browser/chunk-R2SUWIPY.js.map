{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/shared/dashboards/tutor/tutor-participation.service.ts", "src/main/webapp/app/guided-tour/guided-tour.constants.ts", "src/main/webapp/app/guided-tour/guided-tour-setting.model.ts", "src/main/webapp/app/guided-tour/guided-tour-step.model.ts", "src/main/webapp/app/guided-tour/guided-tour.utils.ts", "src/main/webapp/app/guided-tour/tours/general-tour.ts", "src/main/webapp/app/guided-tour/guided-tour-task.model.ts", "src/main/webapp/app/guided-tour/guided-tour.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport { HttpClient, HttpResponse } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { ExampleSubmission } from 'app/entities/example-submission.model';\r\nimport { AccountService } from 'app/core/auth/account.service';\r\nimport { Exercise } from 'app/entities/exercise.model';\r\nimport { Course } from 'app/entities/course.model';\r\nimport { TutorParticipation } from 'app/entities/participation/tutor-participation.model';\r\n\r\nexport type EntityResponseType = HttpResponse<TutorParticipation>;\r\nexport type EntityArrayResponseType = HttpResponse<TutorParticipation[]>;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class TutorParticipationService {\r\n    private http = inject(HttpClient);\r\n    private accountService = inject(AccountService);\r\n\r\n    public resourceUrl = 'api/assessment/exercises';\r\n\r\n    /**\r\n     * Starts the exercise with the given ID for the current tutor. A tutor participation will be created and returned\r\n     * for the exercise given by the exercise id. The tutor participation status will be assigned based on which\r\n     * features are available for the exercise (e.g. grading instructions) The method is valid only for tutors,\r\n     * since it inits the tutor participation to the exercise, which is different from a standard participation\r\n     *\r\n     * @param tutorParticipation The to be created tutor participation\r\n     * @param exerciseId The ID of the exercise for which to init a participation\r\n     * @return The new tutor participation\r\n     */\r\n    create(tutorParticipation: TutorParticipation, exerciseId: number): Observable<HttpResponse<TutorParticipation>> {\r\n        return this.http.post<TutorParticipation>(`${this.resourceUrl}/${exerciseId}/tutor-participations`, tutorParticipation, {\r\n            observe: 'response',\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add an example submission to the tutor participation of the given exercise. If it is just for review (not used for tutorial),\r\n     * the method just records that the tutor has read it. If it is a tutorial, the method checks if the assessment given by the tutor is close enough to the instructor one. If\r\n     * yes, then it returns the participation, if not, it returns an error\r\n     *\r\n     * @param exampleSubmission The to be added example submission\r\n     * @param exerciseId The ID of the exercise of the tutor participation\r\n     */\r\n    assessExampleSubmission(exampleSubmission: ExampleSubmission, exerciseId: number): Observable<HttpResponse<TutorParticipation>> {\r\n        return this.http.post<TutorParticipation>(`${this.resourceUrl}/${exerciseId}/assess-example-submission`, exampleSubmission, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Deletes the tutor participation of the current user for the guided tour\r\n     * @param course the course of the exercise\r\n     * @param exercise  exercise with tutor participation\r\n     */\r\n    deleteTutorParticipationForGuidedTour(course: Course, exercise: Exercise): Observable<void> {\r\n        if (course && this.accountService.isAtLeastTutorInCourse(course)) {\r\n            return this.http.delete<void>(`api/exercise/guided-tour/exercises/${exercise.id}/example-submission`);\r\n        }\r\n        return new Observable();\r\n    }\r\n}\r\n", "export interface OrientationConfiguration {\r\n    /** Where the tour step will appear next to the selected element */\r\n    orientationDirection: Orientation;\r\n    /** When this orientation configuration starts in pixels */\r\n    maximumSize?: number;\r\n}\r\n\r\n/* Orientation of the tour step position next to the highlighted element */\r\nexport enum Orientation {\r\n    BOTTOM = 'bottom',\r\n    BOTTOMLEFT = 'bottom-left',\r\n    BOTTOMRIGHT = 'bottom-right',\r\n    LEFT = 'left',\r\n    RIGHT = 'right',\r\n    TOP = 'top',\r\n    TOPLEFT = 'top-left',\r\n    TOPRIGHT = 'top-right',\r\n}\r\n\r\nexport enum GuidedTourState {\r\n    STARTED,\r\n    FINISHED,\r\n}\r\n\r\nexport enum OverlayPosition {\r\n    TOP = 'top',\r\n    LEFT = 'left',\r\n    RIGHT = 'right',\r\n    BOTTOM = 'bottom',\r\n    ELEMENT = 'element',\r\n}\r\n\r\nexport enum UserInteractionEvent {\r\n    /** Listen for click events */\r\n    CLICK = 'click',\r\n    /** Observe added or removed lines in the code editor */\r\n    MONACO_EDITOR = 'monaco-editor',\r\n    /** Wait for the highlight element of the next tour step to be shown in the DOM */\r\n    WAIT_FOR_SELECTOR = 'wait-for-selector',\r\n    /** Observe and assess the given modeling task in the Apollon editor */\r\n    MODELING = 'modeling',\r\n    ASSESS_SUBMISSION = 'assess-submission',\r\n}\r\n\r\nexport enum Direction {\r\n    VERTICAL = 'vertical',\r\n    HORIZONTAL = 'horizontal',\r\n}\r\n\r\nexport enum ResetParticipation {\r\n    EXERCISE_PARTICIPATION = 'exercise-participation',\r\n    TUTOR_ASSESSMENT = 'tutor-assessment',\r\n    NONE = 'none',\r\n}\r\n", "import { GuidedTourState } from 'app/guided-tour/guided-tour.constants';\r\n\r\n/**\r\n * Guided tour settings model which can dynamically handle the existing guided tours\r\n */\r\nexport class GuidedTourSetting {\r\n    guidedTourKey: string;\r\n    guidedTourStep: number;\r\n    guidedTourState: GuidedTourState;\r\n\r\n    constructor(guidedTourKey: string, guidedTourStep: number, guidedTourState?: GuidedTourState) {\r\n        this.guidedTourKey = guidedTourKey;\r\n        this.guidedTourStep = guidedTourStep;\r\n        this.guidedTourState = guidedTourState ? guidedTourState : GuidedTourState.STARTED;\r\n    }\r\n}\r\n\r\n/**\r\n * Guided tour mapping model which handles the mapping of tutorial to course and exercise\r\n */\r\nexport class GuidedTourMapping {\r\n    courseShortName: string;\r\n    tours: {\r\n        [key: string]: string;\r\n    };\r\n}\r\n", "import { Orientation, OrientationConfiguration, UserInteractionEvent } from 'app/guided-tour/guided-tour.constants';\r\nimport { GuidedTourAssessmentTask, GuidedTourModelingTask } from 'app/guided-tour/guided-tour-task.model';\r\n\r\nexport abstract class TourStep {\r\n    /** Selector for element that will be highlighted */\r\n    highlightSelector?: string;\r\n    /** The position where the tour step will appear next to the selected element */\r\n    orientation?: Orientation | OrientationConfiguration[] | undefined;\r\n    /** Action that happens when the step is opened */\r\n    action?: () => void;\r\n    /** Action that is performed when the step is closed */\r\n    closeAction?: () => void;\r\n    /** Disables this step for the tour so that it won't be shown */\r\n    disableStep?: boolean;\r\n    /** Adds padding around tour highlighting in pixels, this overwrites the default for this step. Is not dependent on useHighlightPadding being true */\r\n    highlightPadding?: number;\r\n    /** Permission to view step, if no permission is set then the tour step is visible to ROLE_USER\r\n     * Possible inputs: Authority.ADMIN, Authority.INSTRUCTOR, Authority.EDITOR, Authority.TA */\r\n    permission?: string[];\r\n    /** Skips this step if the selector is not found, else the setStepAlreadyFinishedHint will be called by the guided tour service */\r\n    skipStepIfNoSelector?: boolean;\r\n    /** Should be added to the first step of each page in multi-page tours.\r\n     *  numbers in the page url should be replaced with the regex (\\d+)+\r\n     */\r\n    pageUrl?: string;\r\n}\r\n\r\nexport class TextTourStep extends TourStep {\r\n    /** Translation key for the title **/\r\n    headlineTranslateKey: string;\r\n    /** Translation key for the title **/\r\n    subHeadlineTranslateKey?: string;\r\n    /** Translation key for the content **/\r\n    contentTranslateKey: string;\r\n    /** Translation key for the hint content **/\r\n    hintTranslateKey?: string;\r\n    /** Translation key for the already executed hint content **/\r\n    alreadyExecutedTranslateKey?: string;\r\n\r\n    constructor(tourStep: TextTourStep) {\r\n        super();\r\n        Object.assign(this, tourStep);\r\n    }\r\n}\r\n\r\nexport class ImageTourStep extends TextTourStep {\r\n    /** Image url **/\r\n    imageUrl: string;\r\n\r\n    constructor(tourStep: ImageTourStep) {\r\n        super(tourStep);\r\n        Object.assign(this, tourStep);\r\n    }\r\n}\r\n\r\nexport class VideoTourStep extends TextTourStep {\r\n    /** Embed video url **/\r\n    videoUrl: string;\r\n\r\n    constructor(tourStep: VideoTourStep) {\r\n        super(tourStep);\r\n        Object.assign(this, tourStep);\r\n    }\r\n}\r\n\r\nexport class UserInterActionTourStep extends TextTourStep {\r\n    /** The user can interact with the elements that are within the rectangle that highlights the selected element\r\n     *  The user interaction will be observed and once accomplished, the next step navigation will be enabled\r\n     */\r\n    userInteractionEvent: UserInteractionEvent;\r\n    /** Enables the automatic display of the next step after a user interaction */\r\n    triggerNextStep?: boolean;\r\n\r\n    constructor(tourStep: UserInterActionTourStep) {\r\n        super(tourStep);\r\n        Object.assign(this, tourStep);\r\n    }\r\n}\r\n\r\nexport class ModelingTaskTourStep extends UserInterActionTourStep {\r\n    /** Modeling task that has to be completed during this step */\r\n    modelingTask: GuidedTourModelingTask;\r\n\r\n    constructor(tourStep: ModelingTaskTourStep) {\r\n        super(tourStep);\r\n        Object.assign(this, tourStep);\r\n    }\r\n}\r\n\r\nexport class AssessmentTaskTourStep extends UserInterActionTourStep {\r\n    /** Assessment task that has to be completed during this step */\r\n    assessmentTask: GuidedTourAssessmentTask;\r\n\r\n    constructor(tourStep: AssessmentTaskTourStep) {\r\n        super(tourStep);\r\n        Object.assign(this, tourStep);\r\n    }\r\n}\r\n", "import { Orientation } from 'app/guided-tour/guided-tour.constants';\r\n\r\n/**\r\n * Helper function that triggers a click event on the defined element\r\n * @param selector: css selector to query the required element\r\n */\r\nexport function clickOnElement(selector: string): void {\r\n    const htmlElement = document.querySelector(selector) as HTMLElement;\r\n    if (htmlElement) {\r\n        htmlElement.click();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function that calculates the top position of the given element\r\n * @param element\r\n */\r\nexport function calculateTopOffset(element: HTMLElement): number {\r\n    let topOffset = element.offsetTop;\r\n    while (element.offsetParent) {\r\n        element = element.offsetParent as HTMLElement;\r\n        topOffset += element.offsetTop;\r\n    }\r\n    return topOffset;\r\n}\r\n\r\n/**\r\n * Helper function that calculates the left position of the given element\r\n * @param element\r\n */\r\nexport function calculateLeftOffset(element: HTMLElement): number {\r\n    let leftOffset = element.offsetLeft;\r\n    while (element.offsetParent) {\r\n        element = element.offsetParent as HTMLElement;\r\n        leftOffset += element.offsetLeft;\r\n    }\r\n    return leftOffset;\r\n}\r\n\r\n/**\r\n * Helper function that determines whether the given tour step element is in the view port horizontally\r\n * @param orientation   orientation of the current tour step\r\n * @param left          left position of the given element\r\n * @param width         width of the given element\r\n * @param tourStepWidth width of the tour step\r\n */\r\nexport function isElementInViewPortHorizontally(orientation: Orientation, left: number, width: number, tourStepWidth: number): boolean {\r\n    let elementInViewPort = true;\r\n    switch (orientation) {\r\n        case Orientation.TOPLEFT: {\r\n            elementInViewPort = left + width + tourStepWidth < window.innerWidth;\r\n            break;\r\n        }\r\n        case Orientation.BOTTOMLEFT: {\r\n            elementInViewPort = left + width + tourStepWidth < window.innerWidth;\r\n            break;\r\n        }\r\n        case Orientation.LEFT: {\r\n            elementInViewPort = left - tourStepWidth > 0;\r\n            break;\r\n        }\r\n        case Orientation.TOPRIGHT: {\r\n            elementInViewPort = left + width - tourStepWidth > 0;\r\n            break;\r\n        }\r\n        case Orientation.BOTTOMRIGHT: {\r\n            elementInViewPort = left + width - tourStepWidth > 0;\r\n            break;\r\n        }\r\n        case Orientation.RIGHT: {\r\n            elementInViewPort = left + width + tourStepWidth < window.innerWidth;\r\n            break;\r\n        }\r\n    }\r\n    return elementInViewPort;\r\n}\r\n\r\n/**\r\n * Determines if the given tour step url matches with the current router url\r\n * @param pageUrl   current page url\r\n * @param tourStepUrl   tour step url as string\r\n */\r\nexport function determineUrlMatching(pageUrl: string, tourStepUrl: string) {\r\n    if (tourStepUrl.indexOf('?') !== -1) {\r\n        return pageUrl.match(tourStepUrl.slice(0, tourStepUrl.indexOf('?')));\r\n    } else {\r\n        return pageUrl.match(tourStepUrl);\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to retrieve the parameters of a URL string\r\n * @param url   url as string\r\n */\r\nexport function getUrlParams(url: string): string {\r\n    if (url.indexOf('?') !== -1) {\r\n        return url.slice(url.indexOf('?'), url.length);\r\n    } else {\r\n        return '';\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the page url matches with the matching url result\r\n * @param pageUrl\r\n * @param matchingUrl\r\n */\r\nexport function checkPageUrlEnding(pageUrl: string, matchingUrl: string): boolean {\r\n    let tempPageUrl = pageUrl;\r\n    if (pageUrl.indexOf('?') !== -1) {\r\n        tempPageUrl = pageUrl.slice(0, pageUrl.indexOf('?'));\r\n    }\r\n    return tempPageUrl.endsWith(matchingUrl);\r\n}\r\n", "import { GuidedTour } from 'app/guided-tour/guided-tour.model';\r\nimport { TextTourStep } from 'app/guided-tour/guided-tour-step.model';\r\nimport { Orientation, ResetParticipation } from 'app/guided-tour/guided-tour.constants';\r\nimport { clickOnElement } from 'app/guided-tour/guided-tour.utils';\r\n\r\nexport const cancelTour: GuidedTour = {\r\n    settingsKey: 'cancel_tour',\r\n    resetParticipation: ResetParticipation.NONE,\r\n    steps: [\r\n        new TextTourStep({\r\n            highlightSelector: '.guided-tour.dropdown-item',\r\n            headlineTranslateKey: 'tour.cancel.headline',\r\n            contentTranslateKey: 'tour.cancel.content',\r\n            highlightPadding: 10,\r\n            orientation: Orientation.LEFT,\r\n            closeAction: () => {\r\n                clickOnElement('#account-menu[aria-expanded=\"true\"]');\r\n            },\r\n        }),\r\n    ],\r\n};\r\n\r\nexport const completedTour: GuidedTour = {\r\n    settingsKey: 'completed_tour',\r\n    resetParticipation: ResetParticipation.NONE,\r\n    steps: [\r\n        new TextTourStep({\r\n            headlineTranslateKey: 'tour.completed.headline',\r\n            contentTranslateKey: 'tour.completed.content',\r\n            hintTranslateKey: 'tour.completed.hint',\r\n        }),\r\n    ],\r\n};\r\n", "/**\r\n * This class is used to define modeling tasks for the guided tutorial and assess the created UML model in the editor\r\n */\r\nexport class GuidedTourModelingTask {\r\n    /** Name of the UML element that has to be created */\r\n    umlName: string;\r\n    /** Translate key of the task description */\r\n    taskTranslateKey: string;\r\n\r\n    constructor(umlName: string, taskTranslateKey: string) {\r\n        this.umlName = umlName;\r\n        this.taskTranslateKey = taskTranslateKey;\r\n    }\r\n}\r\n\r\n/** Person class with attribute */\r\nexport const personUML = {\r\n    name: 'Person',\r\n    attribute: 'name: String',\r\n};\r\n\r\n/** Student class with attribute and method */\r\nexport const studentUML = {\r\n    name: 'Student',\r\n    attribute: 'major: String',\r\n    method: 'visitLecture()',\r\n};\r\n\r\n/** Association */\r\nexport const associationUML = {\r\n    name: 'Association',\r\n};\r\n\r\n/**\r\n * This class is used to define assessment tasks for the guided tutorial and assess the input for the example submission assessment\r\n * of the tutor\r\n */\r\nexport class GuidedTourAssessmentTask {\r\n    /** Translate key of the task description */\r\n    taskTranslateKey: string;\r\n    assessmentObject: AssessmentObject;\r\n\r\n    constructor(taskTranslateKey: string, assessmentsObject: AssessmentObject) {\r\n        this.taskTranslateKey = taskTranslateKey;\r\n        this.assessmentObject = assessmentsObject;\r\n    }\r\n}\r\n\r\n/**\r\n * This class defines the expected assessment in terms of number of assessments and total score of the assessment\r\n */\r\nexport class AssessmentObject {\r\n    /** Number of assessments */\r\n    assessments: number;\r\n    /** Total score of the assessment */\r\n    totalScore: number;\r\n\r\n    constructor(assessments: number, totalScore: number) {\r\n        this.assessments = assessments;\r\n        this.totalScore = totalScore;\r\n    }\r\n}\r\n", "import { Injectable, inject } from '@angular/core';\r\nimport isMobile from 'ismobilejs-es5';\r\nimport { HttpClient, HttpResponse } from '@angular/common/http';\r\nimport { NavigationEnd, NavigationStart, Router } from '@angular/router';\r\nimport { cloneDeep } from 'lodash-es';\r\nimport { BehaviorSubject, Observable, Subject, fromEvent } from 'rxjs';\r\nimport { debounceTime, distinctUntilChanged, filter, map, mergeMap, switchMap } from 'rxjs/operators';\r\nimport { GuidedTourMapping, GuidedTourSetting } from 'app/guided-tour/guided-tour-setting.model';\r\nimport { GuidedTourState, Orientation, OrientationConfiguration, ResetParticipation, UserInteractionEvent } from './guided-tour.constants';\r\nimport { User } from 'app/core/user/user.model';\r\nimport { TextTourStep, TourStep, UserInterActionTourStep, VideoTourStep } from 'app/guided-tour/guided-tour-step.model';\r\nimport { GuidedTour } from 'app/guided-tour/guided-tour.model';\r\nimport { Exercise, ExerciseType } from 'app/entities/exercise.model';\r\nimport { Course } from 'app/entities/course.model';\r\nimport { checkPageUrlEnding, clickOnElement, determineUrlMatching, getUrlParams } from 'app/guided-tour/guided-tour.utils';\r\nimport { cancelTour, completedTour } from 'app/guided-tour/tours/general-tour';\r\nimport { AccountService } from 'app/core/auth/account.service';\r\nimport { ProfileService } from 'app/shared/layouts/profiles/profile.service';\r\nimport { StudentParticipation } from 'app/entities/participation/student-participation.model';\r\nimport { ParticipationService } from 'app/exercises/shared/participation/participation.service';\r\nimport { AssessmentObject } from './guided-tour-task.model';\r\nimport { TutorParticipationService } from 'app/exercises/shared/dashboards/tutor/tutor-participation.service';\r\nimport { CourseManagementService } from '../course/manage/course-management.service';\r\n\r\nexport type EntityResponseType = HttpResponse<GuidedTourSetting[]>;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class GuidedTourService {\r\n    private http = inject(HttpClient);\r\n    private accountService = inject(AccountService);\r\n    private router = inject(Router);\r\n    private profileService = inject(ProfileService);\r\n    private participationService = inject(ParticipationService);\r\n    private tutorParticipationService = inject(TutorParticipationService);\r\n    private courseService = inject(CourseManagementService);\r\n\r\n    public resourceUrl = 'api/core/guided-tour-settings';\r\n    public guidedTourSettings: GuidedTourSetting[];\r\n    public currentTour?: GuidedTour;\r\n\r\n    /** Helper variables */\r\n    public restartIsLoading = false;\r\n    public currentTourStepIndex = 0;\r\n    private availableTourForComponent?: GuidedTour;\r\n    private onResizeMessage = false;\r\n    private modelingResultCorrect = false;\r\n    private assessmentObject = new AssessmentObject(0, 0);\r\n\r\n    /** Guided tour course and exercise mapping */\r\n    public guidedTourMapping?: GuidedTourMapping;\r\n\r\n    /** Helper variables for multi-page tours */\r\n    public currentDotSubject = new Subject<number>();\r\n    public nextDotSubject = new Subject<number>();\r\n    private pageUrls = new Map<string, string>();\r\n\r\n    /** Current course and exercise */\r\n    private currentCourse?: Course;\r\n    private currentExercise?: Exercise;\r\n\r\n    /** Guided tour service subjects */\r\n    private guidedTourCurrentStepSubject = new Subject<TourStep | undefined>();\r\n    private guidedTourAvailabilitySubject = new Subject<boolean>();\r\n    private isUserInteractionFinishedSubject = new Subject<boolean>();\r\n    private checkModelingComponentSubject = new Subject<string | undefined>();\r\n    public isBackPageNavigation = new BehaviorSubject<boolean>(false);\r\n    private isComponentPageLoaded = new Subject<boolean>();\r\n\r\n    private isMobile = false;\r\n\r\n    /**\r\n     * Init method for guided tour settings to retrieve the guided tour settings and subscribe to window resize events\r\n     */\r\n    public init() {\r\n        this.isMobile = isMobile(window.navigator.userAgent).any;\r\n        // Retrieve the guided tour setting from the account service after the user is logged in\r\n        this.accountService.getAuthenticationState().subscribe((user: User | undefined) => {\r\n            if (user) {\r\n                this.guidedTourSettings = user.guidedTourSettings ? user.guidedTourSettings : [];\r\n            }\r\n        });\r\n\r\n        this.isComponentPageLoaded.subscribe((isLoaded) => {\r\n            setTimeout(() => {\r\n                if (isLoaded) {\r\n                    this.resetUserInteractionFinishedState(this.currentStep);\r\n                    this.setPreparedTourStep();\r\n                }\r\n            }, 1200);\r\n        });\r\n\r\n        // Retrieve the guided tour mapping from the profile service\r\n        this.profileService.getProfileInfo().subscribe((profileInfo) => {\r\n            if (profileInfo && profileInfo.guidedTourMapping) {\r\n                this.guidedTourMapping = profileInfo.guidedTourMapping;\r\n            }\r\n        });\r\n\r\n        // Reset guided tour availability on router navigation\r\n        this.router.events.subscribe((event) => {\r\n            // Reset currentExercise and currentCourse for every page\r\n            if (event instanceof NavigationStart) {\r\n                this.currentExercise = undefined;\r\n                this.currentCourse = undefined;\r\n            }\r\n\r\n            // Checks the guided tour availability on router navigation during an active tutorial\r\n            if (event instanceof NavigationEnd) {\r\n                if (this.availableTourForComponent && this.currentTour) {\r\n                    this.guidedTourCurrentStepSubject.next(undefined);\r\n                    this.assessmentObject = new AssessmentObject(0, 0);\r\n                    this.checkNextTourStepOnNavigation();\r\n                } else {\r\n                    this.skipTour();\r\n                    this.guidedTourAvailabilitySubject.next(false);\r\n                }\r\n            }\r\n        });\r\n\r\n        /**\r\n         * Subscribe to window resize events\r\n         */\r\n        fromEvent(window, 'resize')\r\n            .pipe(debounceTime(200))\r\n            .subscribe(() => {\r\n                // TODO: we should use responsive design here instead of checking for mobile/desktop\r\n                if (this.currentTour && !this.isMobile) {\r\n                    // Show resize tour step if the window size falls below the defined minimum tour size, except for VideoTourSteps\r\n                    if (this.tourMinimumScreenSize >= window.innerWidth && !(this.currentTour.steps[this.currentTourStepIndex] instanceof VideoTourStep)) {\r\n                        this.onResizeMessage = true;\r\n                        this.guidedTourCurrentStepSubject.next(new TextTourStep({ headlineTranslateKey: 'tour.resize.headline', contentTranslateKey: 'tour.resize.content' }));\r\n                    } else {\r\n                        if (this.onResizeMessage) {\r\n                            this.onResizeMessage = false;\r\n                            this.setPreparedTourStep();\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Checks and prepares the next tour step on navigation for multi-page tours\r\n     */\r\n    private checkNextTourStepOnNavigation() {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n        const currentStep = this.currentTour.steps[this.currentTourStepIndex] as UserInterActionTourStep;\r\n        const nextStep = this.currentTour.steps[this.currentTourStepIndex + 1];\r\n\r\n        // Prepares previous tour step for backward navigation\r\n        if (this.isBackPageNavigation.value) {\r\n            this.resetUserInteractionFinishedState(currentStep);\r\n        } else {\r\n            // Prepares next tour step\r\n            if (currentStep && currentStep.userInteractionEvent && currentStep.userInteractionEvent === UserInteractionEvent.CLICK && nextStep && nextStep.pageUrl) {\r\n                if (determineUrlMatching(this.router.url, nextStep.pageUrl)) {\r\n                    this.currentDotSubject.next(this.currentTourStepIndex);\r\n                    this.nextDotSubject.next(this.currentTourStepIndex + 1);\r\n                    this.currentTourStepIndex += 1;\r\n                    this.pageUrls.set(nextStep.pageUrl, this.router.url);\r\n                } else if (this.currentTour) {\r\n                    // Ends guided tour if the navigation is done through a multi-page tutorial\r\n                    this.guidedTourAvailabilitySubject.next(false);\r\n                    this.skipTour();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return defined minimum screen size number\r\n     */\r\n    private get tourMinimumScreenSize(): number {\r\n        return this.currentTour && this.currentTour.minimumScreenSize ? this.currentTour.minimumScreenSize : 1000;\r\n    }\r\n\r\n    /**\r\n     * @return current tour step as Observable\r\n     */\r\n    public getGuidedTourCurrentStepStream(): Observable<TourStep | undefined> {\r\n        return this.guidedTourCurrentStepSubject.asObservable();\r\n    }\r\n\r\n    /**\r\n     * @return Observable(true) if the guided tour is available for the current component, otherwise Observable(false)\r\n     */\r\n    public getGuidedTourAvailabilityStream(): Observable<boolean> {\r\n        // The guided tour is currently disabled for mobile devices and tablets\r\n        // TODO optimize guided tour layout for mobile devices and tablets\r\n        // TODO: we should use responsive design here instead of checking for mobile/desktop\r\n        return this.guidedTourAvailabilitySubject.pipe(map((isTourAvailable) => isTourAvailable && !this.isMobile));\r\n    }\r\n\r\n    /**\r\n     * @return Observable(true) if the required user interaction for the guided tour step has been executed, otherwise Observable(false)\r\n     */\r\n    public userInteractionFinishedState(): Observable<boolean> {\r\n        return this.isUserInteractionFinishedSubject.asObservable();\r\n    }\r\n\r\n    /**\r\n     * @return Observable of the current modeling task UML name\r\n     */\r\n    public checkModelingComponent(): Observable<string | undefined> {\r\n        return this.checkModelingComponentSubject.asObservable();\r\n    }\r\n\r\n    /**\r\n     * Updates the modelingResultCorrect variable on whether the implemented UML model is correct and enables\r\n     * the next step button\r\n     * @param umlName   name of the UML element for the modeling task\r\n     * @param result    true if the UML element has been modeled correctly, otherwise false\r\n     */\r\n    public updateModelingResult(umlName: string, result: boolean) {\r\n        if (!this.currentStep || !this.currentStep.modelingTask) {\r\n            return;\r\n        }\r\n        if (result && this.currentStep.modelingTask.umlName === umlName) {\r\n            this.modelingResultCorrect = result;\r\n            setTimeout(() => {\r\n                this.enableNextStepClick();\r\n                this.checkModelingComponentSubject.next(undefined);\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method for multi-page tutorials that notifies the guided-tour service when the current component has\r\n     * been fully loaded\r\n     */\r\n    public componentPageLoaded() {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n        this.isComponentPageLoaded.next(true);\r\n    }\r\n\r\n    /**\r\n     * Check if the provided tour step is the currently active one\r\n     * @param tourStep current tour step of the guided tour\r\n     */\r\n    public isCurrentStep(tourStep: TourStep): boolean {\r\n        if (this.currentTour && this.currentTour.steps) {\r\n            return this.currentTourStepDisplay === this.currentTour.steps.indexOf(tourStep) + 1;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determines if the given tour is the current tour\r\n     * @param guidedTour that is checked\r\n     */\r\n    public isCurrentTour(guidedTour: GuidedTour) {\r\n        if (this.currentTour && this.currentTour.steps) {\r\n            return this.currentTour.settingsKey === guidedTour.settingsKey;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check if the provided tour step is the currently active one\r\n     */\r\n    private get currentStep(): any | undefined {\r\n        if (!this.currentTour || !this.currentTour.steps) {\r\n            return undefined;\r\n        }\r\n        return this.currentTour.steps[this.currentTourStepIndex];\r\n    }\r\n\r\n    /**\r\n     * Get the current step string for the headline, that shows which step is currently displayed, `currentStep / totalStep`\r\n     */\r\n    public getCurrentStepString() {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n        const currentStep = this.currentTourStepIndex + 1;\r\n        const totalSteps = this.currentTour.steps.length;\r\n        return `${currentStep} / ${totalSteps}`;\r\n    }\r\n\r\n    /**\r\n     * Navigate to previous tour step\r\n     */\r\n    public backStep(): void {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n\r\n        const currentStep = this.currentTour.steps[this.currentTourStepIndex];\r\n        const previousStep = this.currentTour.steps[this.currentTourStepIndex - 1];\r\n        this.currentDotSubject.next(this.currentTourStepIndex);\r\n        this.nextDotSubject.next(this.currentTourStepIndex - 1);\r\n\r\n        if (currentStep?.closeAction) {\r\n            currentStep.closeAction();\r\n        }\r\n\r\n        const previousStepLocation = this.determinePreviousStepLocation();\r\n        if (currentStep.pageUrl && previousStepLocation !== this.router.url) {\r\n            this.isBackPageNavigation.next(true);\r\n            this.router.navigateByUrl(this.determinePreviousStepLocation()).then();\r\n        }\r\n\r\n        if (previousStep) {\r\n            this.currentTourStepIndex--;\r\n            if (previousStep.action) {\r\n                previousStep.action();\r\n            }\r\n            // Usually an action is opening something so we need to give it time to render.\r\n            setTimeout(() => {\r\n                if (!this.isBackPageNavigation.value) {\r\n                    this.resetUserInteractionFinishedState(previousStep);\r\n                    this.setPreparedTourStep();\r\n                }\r\n            });\r\n        } else {\r\n            this.resetTour();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Navigate to next tour step\r\n     */\r\n    public nextStep(): void {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n\r\n        const currentStep = this.currentTour.steps[this.currentTourStepIndex];\r\n        const nextStep = this.currentTour.steps[this.currentTourStepIndex + 1];\r\n        const timeout = currentStep instanceof UserInterActionTourStep && currentStep.userInteractionEvent === UserInteractionEvent.CLICK && this.checkSelectorValidity() ? 600 : 0;\r\n        this.currentDotSubject.next(this.currentTourStepIndex);\r\n        this.nextDotSubject.next(this.currentTourStepIndex + 1);\r\n        this.isBackPageNavigation.next(false);\r\n\r\n        if (currentStep?.closeAction) {\r\n            currentStep.closeAction();\r\n        }\r\n        if (nextStep) {\r\n            this.currentTourStepIndex++;\r\n            if (nextStep.action) {\r\n                nextStep.action();\r\n            }\r\n            // Usually an action is opening something so we need to give it time to render.\r\n            setTimeout(() => {\r\n                this.resetUserInteractionFinishedState(nextStep);\r\n                this.setPreparedTourStep();\r\n            }, timeout);\r\n        } else {\r\n            this.finishGuidedTour();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the user interaction finished state for given tour step\r\n     * @param tourStep  if the tour step is an instance of UserInterActionTourStep, the user interaction finished state\r\n     * will be set to false\r\n     */\r\n    private resetUserInteractionFinishedState(tourStep: TourStep) {\r\n        if (tourStep instanceof UserInterActionTourStep) {\r\n            this.isUserInteractionFinishedSubject.next(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback method if there is one and finish the current guided tour by updating the guided tour settings in the database\r\n     * and calling the reset tour method to remove current tour elements\r\n     */\r\n    public finishGuidedTour() {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n\r\n        if (this.currentTour.completeCallback) {\r\n            this.currentTour.completeCallback();\r\n        }\r\n\r\n        if (this.isCurrentTour(completedTour)) {\r\n            this.resetTour();\r\n            return;\r\n        }\r\n\r\n        const nextStep = this.currentTour.steps[this.currentTourStepIndex + 1];\r\n        if (!nextStep) {\r\n            this.subscribeToAndUpdateGuidedTourSettings(GuidedTourState.FINISHED);\r\n            this.showCompletedTourStep();\r\n        } else {\r\n            this.subscribeToAndUpdateGuidedTourSettings(GuidedTourState.STARTED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skip current guided tour after updating the guided tour settings in the database and calling the reset tour method to remove current tour elements.\r\n     */\r\n    public skipTour(): void {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n\r\n        if (this.currentTour.skipCallback) {\r\n            this.currentTour.skipCallback(this.currentTourStepIndex);\r\n        }\r\n\r\n        if (this.currentTour === cancelTour || this.currentTour === completedTour) {\r\n            this.resetTour();\r\n            return;\r\n        }\r\n\r\n        if (this.currentTourStepIndex + 1 === this.getFilteredTourSteps().length) {\r\n            this.finishGuidedTour();\r\n        } else {\r\n            this.subscribeToAndUpdateGuidedTourSettings(GuidedTourState.STARTED);\r\n            this.showCancelHint();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show the cancel hint the first time a user skips a tour\r\n     */\r\n    private showCancelHint(): void {\r\n        /** Do not show hint if the user has seen it already */\r\n        const hasStartedOrFinishedTour = this.checkTourState(cancelTour);\r\n        if (hasStartedOrFinishedTour) {\r\n            return;\r\n        }\r\n\r\n        clickOnElement('#account-menu[aria-expanded=\"false\"]');\r\n        setTimeout(() => {\r\n            this.currentTour = cloneDeep(cancelTour);\r\n            /** Proceed with tour if the tour has tour steps and the tour display is allowed for current window size */\r\n            if (this.currentTour.steps.length > 0 && this.tourAllowedForWindowSize()) {\r\n                const currentStep = this.currentTour.steps[this.currentTourStepIndex];\r\n                if (currentStep.action) {\r\n                    currentStep.action();\r\n                }\r\n                this.setPreparedTourStep();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Show the completed tour step every time a user completes a tour\r\n     */\r\n    private showCompletedTourStep(): void {\r\n        setTimeout(() => {\r\n            this.currentTour = cloneDeep(completedTour);\r\n            /** Proceed with tour if the tour has tour steps and the tour display is allowed for current window size */\r\n            if (this.currentTour.steps.length > 0 && this.tourAllowedForWindowSize()) {\r\n                this.setPreparedTourStep();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Subscribe to the update method call\r\n     * @param guidedTourState GuidedTourState.FINISHED if the tour is closed on the last step, otherwise GuidedTourState.STARTED\r\n     */\r\n    public subscribeToAndUpdateGuidedTourSettings(guidedTourState: GuidedTourState) {\r\n        if (!this.currentTour || this.isCurrentTour(completedTour)) {\r\n            this.resetTour();\r\n            return;\r\n        }\r\n        // If the tour was already finished, then keep the state\r\n        const updatedTourState = this.checkTourState(this.currentTour, GuidedTourState.FINISHED) ? GuidedTourState.FINISHED : guidedTourState;\r\n        this.updateGuidedTourSettings(this.currentTour.settingsKey, this.currentTourStepDisplay, updatedTourState)\r\n            .pipe(filter((guidedTourSettings) => !!guidedTourSettings.body))\r\n            .subscribe((guidedTourSettings) => {\r\n                this.guidedTourSettings = guidedTourSettings.body!;\r\n            });\r\n        this.resetTour();\r\n    }\r\n\r\n    /**\r\n     * Check if the current user has already finished a given guided tour by filtering the user's guided tour settings and comp\r\n     * @param guidedTour that should be checked for the state\r\n     * @param state that should be checked, if no state is given, then true is returned if the tour has been started or finished\r\n     */\r\n    private checkTourState(guidedTour: GuidedTour, state?: GuidedTourState): boolean {\r\n        const tourSetting = this.guidedTourSettings.filter((setting) => setting.guidedTourKey === guidedTour.settingsKey);\r\n        if (state) {\r\n            return tourSetting.length === 1 && tourSetting[0].guidedTourState.toString() === GuidedTourState[state];\r\n        }\r\n        return tourSetting.length >= 1;\r\n    }\r\n\r\n    /**\r\n     * Get the last step that the user visited during the given tour\r\n     */\r\n    public getLastSeenTourStepIndex(): number {\r\n        if (!this.availableTourForComponent || !this.guidedTourSettings) {\r\n            return 0;\r\n        }\r\n        const tourSettings = this.guidedTourSettings.filter((setting) => setting.guidedTourKey === this.availableTourForComponent!.settingsKey);\r\n\r\n        if (tourSettings.length !== 0 && this.hasValidTourStepNumber(tourSettings)) {\r\n            return tourSettings[0].guidedTourStep;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Get the last seen tour step when initiating a guided tour\r\n     * This method takes multi page guided tours into account and retrieves the right tour step for the respective component page\r\n     */\r\n    public getLastSeenTourStepForInit(): number {\r\n        if (!this.availableTourForComponent) {\r\n            return 0;\r\n        }\r\n\r\n        let lastSeenTourStep = this.isMultiPageTour() ? this.determineTourStepForComponent() : this.getLastSeenTourStepIndex();\r\n\r\n        /** If the user has seen the tour already, then set the last seen tour step to -1\r\n         *  to enable the restart of the tour instead of just starting it\r\n         */\r\n        // We need the !== undefined check because in case lastSeenTourStep is 0, the condition will be seen as false\r\n        if (lastSeenTourStep !== undefined) {\r\n            lastSeenTourStep = this.availableTourForComponent.steps[lastSeenTourStep] ? lastSeenTourStep : 0;\r\n            return lastSeenTourStep === 0 ? -1 : lastSeenTourStep;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private isMultiPageTour() {\r\n        if (!this.availableTourForComponent) {\r\n            return false;\r\n        }\r\n        return this.availableTourForComponent.steps.filter((tourStep) => tourStep.pageUrl).length > 0;\r\n    }\r\n\r\n    /**\r\n     * Determines if the tour step stored in the database is valid for the current tour\r\n     * It might be that tour steps have been removed in the meantime\r\n     * @param tourSettings  the tour setting that is stored for the current tour\r\n     */\r\n    private hasValidTourStepNumber(tourSettings: GuidedTourSetting[]): boolean {\r\n        return tourSettings[0].guidedTourStep <= this.getFilteredTourSteps().length;\r\n    }\r\n\r\n    /**\r\n     * This method determines the right starting tour step for multi-page guided tours\r\n     */\r\n    private determineTourStepForComponent(): number | undefined {\r\n        // Find steps with a pageUrl attribute that matches the current router url\r\n        const stepsForComponent = this.availableTourForComponent!.steps.filter((tourStep) => {\r\n            const match = tourStep.pageUrl ? determineUrlMatching(this.router.url, tourStep.pageUrl) : [];\r\n            if (match && tourStep.pageUrl && checkPageUrlEnding(this.router.url, match[0])) {\r\n                return match;\r\n            }\r\n        });\r\n\r\n        if (stepsForComponent) {\r\n            const stepForComponent = stepsForComponent.find((step) => {\r\n                if (step.pageUrl) {\r\n                    // Since we could not include the params in the URL matching we have to do a final check here\r\n                    return getUrlParams(step.pageUrl) === getUrlParams(this.router.url);\r\n                }\r\n            });\r\n            return stepForComponent ? this.availableTourForComponent!.steps.indexOf(stepForComponent) : undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * This is a helper method to determine the previous step location for backward navigation in a multi-page tour\r\n     */\r\n    private determinePreviousStepLocation(): string {\r\n        if (!this.availableTourForComponent) {\r\n            return this.router.url;\r\n        }\r\n\r\n        let previousStepLocation = this.router.url;\r\n        const tourStepsWithUrl = this.availableTourForComponent.steps.filter((tourStep, index) => {\r\n            return tourStep.pageUrl && index < this.currentTourStepIndex;\r\n        });\r\n\r\n        if (tourStepsWithUrl) {\r\n            const lastTourStepWithUrl = tourStepsWithUrl.last();\r\n            const previousStepLocationKey = lastTourStepWithUrl && lastTourStepWithUrl.pageUrl ? lastTourStepWithUrl.pageUrl : this.router.url;\r\n            if (this.pageUrls.has(previousStepLocationKey)) {\r\n                previousStepLocation = <string>this.pageUrls.get(previousStepLocationKey);\r\n            }\r\n        }\r\n        return previousStepLocation;\r\n    }\r\n\r\n    /**\r\n     * Close tour by resetting `currentTour`, `currentTourStepIndex` and `guidedTourCurrentStepSubject`\r\n     * and remove overlay\r\n     */\r\n    public resetTour(): void {\r\n        if (this.isCurrentTour(cancelTour)) {\r\n            this.updateGuidedTourSettings(cancelTour.settingsKey, 1, GuidedTourState.FINISHED);\r\n        }\r\n\r\n        document.body.classList.remove('tour-open');\r\n        this.currentTour = undefined;\r\n        this.currentTourStepIndex = 0;\r\n        this.guidedTourCurrentStepSubject.next(undefined);\r\n        this.assessmentObject = new AssessmentObject(0, 0);\r\n    }\r\n\r\n    /**\r\n     * Enable a smooth user interaction\r\n     * @param targetNode an HTMLElement of which DOM changes should be observed\r\n     * @param userInteraction the user interaction to complete the tour step\r\n     * @param modelingTask the modeling task identifier\r\n     */\r\n    public enableUserInteraction(targetNode: HTMLElement, userInteraction: UserInteractionEvent, modelingTask?: string): void {\r\n        if (!this.currentTour) {\r\n            return;\r\n        }\r\n\r\n        const currentStep = this.currentTour.steps[this.currentTourStepIndex] as UserInterActionTourStep;\r\n\r\n        if (userInteraction === UserInteractionEvent.WAIT_FOR_SELECTOR) {\r\n            const nextStep = this.currentTour.steps[this.currentTourStepIndex + 1];\r\n            const afterNextStep = this.currentTour.steps[this.currentTourStepIndex + 2];\r\n            this.handleWaitForSelectorEvent(currentStep, nextStep, afterNextStep);\r\n        } else {\r\n            /** At a minimum one of childList, attributes, and characterData must be true, otherwise, a TypeError exception will be thrown. */\r\n            let options: MutationObserverInit = { attributes: true, childList: true, characterData: true };\r\n\r\n            if (userInteraction === UserInteractionEvent.CLICK) {\r\n                targetNode.addEventListener(\r\n                    'click',\r\n                    () => {\r\n                        if (currentStep.triggerNextStep) {\r\n                            this.nextStep();\r\n                        } else {\r\n                            this.enableNextStepClick();\r\n                        }\r\n                    },\r\n                    false,\r\n                );\r\n            } else if (userInteraction === UserInteractionEvent.MONACO_EDITOR) {\r\n                /** We observe any added or removed lines in the Monaco editor's .view-lines node and trigger enableNextStepClick() */\r\n                targetNode = document.querySelector('.monaco-editor .view-lines') as HTMLElement;\r\n                this.observeMutations(targetNode, options)\r\n                    .pipe(\r\n                        filter(\r\n                            (mutation: MutationRecord) =>\r\n                                mutation.addedNodes.length !== mutation.removedNodes.length && (mutation.addedNodes.length >= 1 || mutation.removedNodes.length >= 1),\r\n                        ),\r\n                    )\r\n                    .subscribe(() => {\r\n                        this.enableNextStepClick();\r\n                    });\r\n            } else if (userInteraction === UserInteractionEvent.MODELING) {\r\n                /** We observe any DOM mutation in the .apollon-editor node and its children\r\n                 *  If the UML model is correct then enableNextStepClick() will be called\r\n                 */\r\n                options = { childList: true, subtree: true };\r\n                targetNode = document.querySelector('.modeling-editor .apollon-container .apollon-editor svg') as HTMLElement;\r\n\r\n                this.modelingResultCorrect = false;\r\n                this.checkModelingComponentSubject.next(modelingTask);\r\n\r\n                this.observeMutations(targetNode, options)\r\n                    .pipe(debounceTime(100), distinctUntilChanged())\r\n                    .subscribe(() => {\r\n                        this.checkModelingComponentSubject.next(modelingTask);\r\n                        if (this.modelingResultCorrect) {\r\n                            this.enableNextStepClick();\r\n                        }\r\n                    });\r\n            } else if (userInteraction === UserInteractionEvent.ASSESS_SUBMISSION) {\r\n                if (this.isAssessmentCorrect()) {\r\n                    this.enableNextStepClick();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the next step click if the highlightSelector of the next step or\r\n     * the highlightSelector of the after next step are visible\r\n     * @param currentStep  current tour step\r\n     * @param nextStep  next tour step\r\n     * @param afterNextStep the tour step after the next tour step\r\n     */\r\n    private handleWaitForSelectorEvent(currentStep: UserInterActionTourStep, nextStep: TourStep | undefined, afterNextStep: TourStep | undefined) {\r\n        if (nextStep && nextStep.highlightSelector) {\r\n            this.waitForElement(nextStep.highlightSelector, afterNextStep?.highlightSelector, currentStep.triggerNextStep);\r\n        } else {\r\n            this.enableNextStepClick();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles the mutation observer for the user interactions\r\n     * @param target    target node of an HTMLElement of which DOM changes should be observed\r\n     * @param options   the configuration options for the mutation observer\r\n     */\r\n    public observeMutations = (target: any, options: MutationObserverInit) =>\r\n        new Observable<MutationRecord>((subscribe) => {\r\n            const observer = new MutationObserver((mutations) => {\r\n                mutations.forEach((mutation) => {\r\n                    subscribe.next(mutation);\r\n                });\r\n            });\r\n            observer.observe(target, options);\r\n            return () => observer.disconnect();\r\n        });\r\n\r\n    /**\r\n     * Wait for the next step selector to appear in the DOM and continue with the next step\r\n     * @param nextStepSelector the selector string of the next element that should appear in the DOM\r\n     * @param afterNextStepSelector if the nextSelector does not show up in the DOM then wait for the step afterwards as well\r\n     * @param triggerNextStep if the next step should be called as soon as the element is found\r\n     */\r\n    private waitForElement(nextStepSelector: string, afterNextStepSelector?: string, triggerNextStep?: boolean) {\r\n        const interval = setInterval(() => {\r\n            const nextElement = document.querySelector(nextStepSelector);\r\n            const afterNextElement = afterNextStepSelector ? document.querySelector(afterNextStepSelector) : undefined;\r\n            if (nextElement || afterNextElement) {\r\n                clearInterval(interval);\r\n                if (triggerNextStep) {\r\n                    this.nextStep();\r\n                } else {\r\n                    this.enableNextStepClick();\r\n                }\r\n            }\r\n        }, 1000);\r\n    }\r\n\r\n    /**\r\n     * Remove the disabled attribute so that the next button is clickable again\r\n     */\r\n    private enableNextStepClick() {\r\n        this.isUserInteractionFinishedSubject.next(true);\r\n    }\r\n\r\n    /**\r\n     * Start or restart the guided tour based on the last seen tour step\r\n     */\r\n    public initGuidedTour(): void {\r\n        switch (this.getLastSeenTourStepForInit()) {\r\n            case -1: {\r\n                this.restartTour();\r\n                break;\r\n            }\r\n            default: {\r\n                this.startTour();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start guided tour for given guided tour\r\n     */\r\n    private startTour(): void {\r\n        if (!this.availableTourForComponent) {\r\n            return;\r\n        }\r\n        // Keep current tour undefined until start tour is triggered, else it could be somehow accessed through nextStep() calls\r\n        this.currentTour = this.availableTourForComponent;\r\n\r\n        // Filter tour steps according to permissions\r\n        this.currentTour.steps = this.getFilteredTourSteps();\r\n        this.currentTourStepIndex = this.isMultiPageTour() ? this.getLastSeenTourStepForInit() : this.getLastSeenTourStepForInit() - 1;\r\n\r\n        // Proceed with tour if it has tour steps and the tour display is allowed for current window size\r\n        if (this.currentTour.steps.length > 0 && this.tourAllowedForWindowSize()) {\r\n            if (!this.currentTour.steps[this.currentTourStepIndex]) {\r\n                // Set current tour step index to 0 if the current tour step cannot be found\r\n                this.currentTourStepIndex = 0;\r\n            }\r\n            const currentStep = this.currentTour.steps[this.currentTourStepIndex];\r\n            if (currentStep.action) {\r\n                currentStep.action();\r\n            }\r\n            if (currentStep.pageUrl) {\r\n                this.pageUrls.set(currentStep.pageUrl, this.router.url);\r\n            }\r\n            this.resetUserInteractionFinishedState(currentStep);\r\n            this.setPreparedTourStep();\r\n        }\r\n    }\r\n\r\n    /** Resets participation and enables the restart of the current tour */\r\n    public restartTour() {\r\n        if (this.currentCourse && this.currentExercise && this.availableTourForComponent) {\r\n            switch (this.availableTourForComponent.resetParticipation) {\r\n                // Reset exercise participation\r\n                case ResetParticipation.EXERCISE_PARTICIPATION:\r\n                    this.restartIsLoading = true;\r\n                    const isProgrammingExercise = this.currentExercise.type === ExerciseType.PROGRAMMING;\r\n                    this.participationService\r\n                        .findParticipationForCurrentUser(this.currentExercise.id!)\r\n                        .pipe(\r\n                            map((response: HttpResponse<StudentParticipation>) => response.body!),\r\n                            mergeMap((participation) =>\r\n                                this.participationService.deleteForGuidedTour(participation.id!, {\r\n                                    deleteBuildPlan: isProgrammingExercise,\r\n                                    deleteRepository: isProgrammingExercise,\r\n                                }),\r\n                            ),\r\n                            switchMap(() => this.deleteGuidedTourSetting(this.availableTourForComponent!.settingsKey)),\r\n                        )\r\n                        .subscribe({\r\n                            next: () => {\r\n                                this.navigateToUrlAfterRestart(`/courses/${this.currentCourse!.id}/exercises`);\r\n                            },\r\n                            error: () => {\r\n                                // start tour in case the participation was deleted otherwise\r\n                                this.restartIsLoading = false;\r\n                                this.startTour();\r\n                            },\r\n                        });\r\n                    break;\r\n                // Reset tutor assessment participation\r\n                case ResetParticipation.TUTOR_ASSESSMENT:\r\n                    this.restartIsLoading = true;\r\n                    this.tutorParticipationService.deleteTutorParticipationForGuidedTour(this.currentCourse, this.currentExercise).subscribe({\r\n                        next: () => {\r\n                            this.deleteGuidedTourSetting(this.availableTourForComponent!.settingsKey).subscribe(() => {\r\n                                this.navigateToUrlAfterRestart('/course-management');\r\n                            });\r\n                        },\r\n                        error: () => {\r\n                            this.restartIsLoading = false;\r\n                            this.startTour();\r\n                        },\r\n                    });\r\n                    break;\r\n                case ResetParticipation.NONE:\r\n                    this.startTour();\r\n                    break;\r\n            }\r\n        } else {\r\n            this.startTour();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Navigate to page after resetting a guided tour participation\r\n     */\r\n    private navigateToUrlAfterRestart(url: string) {\r\n        this.router.navigateByUrl(url).then(() => {\r\n            location.reload();\r\n        });\r\n\r\n        // Keep loading icon until the page is being refreshed\r\n        window.onload = () => {\r\n            this['restartIsLoading'] = false;\r\n        };\r\n    }\r\n\r\n    public getFilteredTourSteps(): TourStep[] {\r\n        if (!this.availableTourForComponent) {\r\n            return [];\r\n        }\r\n        return this.availableTourForComponent.steps.filter((step) => !step.disableStep && (!step.permission || this.accountService.hasAnyAuthorityDirect(step.permission)));\r\n    }\r\n\r\n    /**\r\n     * Checks if the current window size is supposed display the guided tour\r\n     * @return true if the minimum screen size is not defined or greater than the current window.innerWidth, otherwise false\r\n     */\r\n    private tourAllowedForWindowSize(): boolean {\r\n        if (this.currentTour) {\r\n            return !this.currentTour.minimumScreenSize || window.innerWidth >= this.currentTour!.minimumScreenSize;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *  @return true if highlighted element is available, otherwise false\r\n     */\r\n    private checkSelectorValidity(): boolean {\r\n        if (!this.currentTour) {\r\n            return false;\r\n        }\r\n        const currentTourStep = this.currentTour.steps[this.currentTourStepIndex];\r\n        if (!currentTourStep) {\r\n            this.resetTour();\r\n            return false;\r\n        }\r\n\r\n        return !currentTourStep.highlightSelector || !!document.querySelector(currentTourStep.highlightSelector);\r\n    }\r\n\r\n    /**\r\n     * @return true if the current step is the last tour step, otherwise false\r\n     */\r\n    public get isOnLastStep(): boolean {\r\n        if (!this.currentTour) {\r\n            return false;\r\n        }\r\n        return this.currentTour.steps.length - 1 === this.currentTourStepIndex;\r\n    }\r\n\r\n    /**\r\n     * @return true if the current step is the first tour step, otherwise false\r\n     */\r\n    public get isOnFirstStep(): boolean {\r\n        return this.currentTourStepIndex === 0;\r\n    }\r\n\r\n    /**\r\n     * @return true if the `show resize` message should be displayed, otherwise false\r\n     */\r\n    public get isOnResizeMessage(): boolean {\r\n        return this.onResizeMessage;\r\n    }\r\n\r\n    /**\r\n     * @return current tour step number\r\n     */\r\n    public get currentTourStepDisplay(): number {\r\n        return this.currentTourStepIndex + 1;\r\n    }\r\n\r\n    /**\r\n     *  @return total count of tour steps of the current tour\r\n     */\r\n    public get currentTourStepCount(): any {\r\n        return this.currentTour && this.currentTour.steps ? this.currentTour.steps.length : 0;\r\n    }\r\n\r\n    /**\r\n     *  Prevents the tour from advancing by clicking the backdrop\r\n     *  @return the `preventBackdropFromAdvancing` configuration if tour should advance when clicking on the backdrop\r\n     *  or false if this configuration is not set\r\n     */\r\n    public get preventBackdropFromAdvancing(): boolean {\r\n        if (this.currentTour) {\r\n            return this.currentTour && (this.currentTour.preventBackdropFromAdvancing ? this.currentTour.preventBackdropFromAdvancing : true);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the tour step with defined orientation\r\n     * @return prepared current tour step or undefined\r\n     */\r\n    private getPreparedTourStep(): TourStep | undefined {\r\n        if (!this.currentTour) {\r\n            return undefined;\r\n        }\r\n        return this.checkSelectorValidity()\r\n            ? this.setTourOrientation(this.currentTour.steps[this.currentTourStepIndex])\r\n            : GuidedTourService.setStepAlreadyFinishedHint(this.currentTour.steps[this.currentTourStepIndex]);\r\n    }\r\n\r\n    /**\r\n     * Set the next prepared tour step\r\n     */\r\n    private setPreparedTourStep(): void {\r\n        const preparedTourStep = this.getPreparedTourStep();\r\n        if (preparedTourStep) {\r\n            this.guidedTourCurrentStepSubject.next(preparedTourStep);\r\n        } else {\r\n            this.nextStep();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set orientation of the passed on tour step\r\n     * @param step passed on tour step of a guided tour\r\n     * @return guided tour step with defined orientation\r\n     */\r\n    private setTourOrientation(step: TourStep): TourStep | undefined {\r\n        if (!step) {\r\n            return undefined;\r\n        }\r\n        const convertedStep = cloneDeep(step);\r\n        if (convertedStep.orientation && !(typeof convertedStep.orientation === 'string') && (convertedStep.orientation as OrientationConfiguration[]).length) {\r\n            (convertedStep.orientation as OrientationConfiguration[]).sort((a: OrientationConfiguration, b: OrientationConfiguration) => {\r\n                if (!b.maximumSize) {\r\n                    return 1;\r\n                }\r\n                if (!a.maximumSize) {\r\n                    return -1;\r\n                }\r\n                return b.maximumSize - a.maximumSize;\r\n            });\r\n\r\n            let currentOrientation: Orientation = Orientation.TOP;\r\n            (convertedStep.orientation as OrientationConfiguration[]).forEach((orientationConfig: OrientationConfiguration) => {\r\n                if (!orientationConfig.maximumSize || window.innerWidth <= orientationConfig.maximumSize) {\r\n                    currentOrientation = orientationConfig.orientationDirection;\r\n                }\r\n            });\r\n\r\n            convertedStep.orientation = currentOrientation;\r\n        }\r\n        return convertedStep;\r\n    }\r\n\r\n    /** If the current tour step cannot be displayed because it has already been successfully completed, then this\r\n     * extra TourStep should be displayed instead\r\n     */\r\n    private static setStepAlreadyFinishedHint(step: any): TourStep | undefined {\r\n        if (step.skipStepIfNoSelector) {\r\n            return undefined;\r\n        }\r\n        return new TextTourStep({\r\n            headlineTranslateKey: step.headlineTranslateKey,\r\n            contentTranslateKey: step.contentTranslateKey,\r\n            alreadyExecutedTranslateKey: 'tour.stepAlreadyExecutedHint.text',\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Send a PUT request to update the guided tour settings of the current user\r\n     * @param guidedTourKey the guided_tour_key that will be stored in the database\r\n     * @param guidedTourStep the last tour step the user visited before finishing / skipping the tour\r\n     * @param guidedTourState displays whether the user has finished (FINISHED) the current tour or only STARTED it and cancelled it in the middle\r\n     * @return Observable<EntityResponseType>: updated guided tour settings\r\n     */\r\n    private updateGuidedTourSettings(guidedTourKey: string, guidedTourStep: number, guidedTourState: GuidedTourState): Observable<EntityResponseType> {\r\n        if (!this.guidedTourSettings) {\r\n            this.resetTour();\r\n            throw new Error('Cannot update non-existing guided tour settings');\r\n        }\r\n        const existingSettingIndex = this.guidedTourSettings.findIndex((setting) => setting.guidedTourKey === guidedTourKey);\r\n        if (existingSettingIndex !== -1) {\r\n            this.guidedTourSettings[existingSettingIndex].guidedTourStep = guidedTourStep;\r\n            this.guidedTourSettings[existingSettingIndex].guidedTourState = guidedTourState;\r\n        } else {\r\n            this.guidedTourSettings.push(new GuidedTourSetting(guidedTourKey, guidedTourStep, guidedTourState));\r\n        }\r\n        return this.http.put<GuidedTourSetting[]>(this.resourceUrl, this.guidedTourSettings, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Send a DELETE request to delete the guided tour settings of the current user\r\n     * @param guidedTourKey the guided_tour_key of the tour setting that should be deleted\r\n     * @return Observable<EntityResponseType>: updated guided tour settings\r\n     */\r\n    private deleteGuidedTourSetting(guidedTourKey: string): Observable<EntityResponseType> {\r\n        if (!this.guidedTourSettings) {\r\n            this.resetTour();\r\n            throw new Error('Cannot update non-existing guided tour settings');\r\n        }\r\n\r\n        const index = this.guidedTourSettings.findIndex((setting) => setting.guidedTourKey === guidedTourKey);\r\n        this.guidedTourSettings.splice(index, 1);\r\n\r\n        return this.http.delete<GuidedTourSetting[]>(`${this.resourceUrl}/${guidedTourKey}`, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Enable a given tour for the component that calls this method and make the start tour button in the navigation bar availability\r\n     * by setting the guidedTourAvailability to true\r\n     *\r\n     * @param guidedTour that should be enabled for the current component\r\n     * @param init - if true - enables the display of the guided tour on the first visit, this parameter is used for guided tours which navigate through multiple component pages\r\n     */\r\n    private enableTour(guidedTour: GuidedTour, init: boolean) {\r\n        /**\r\n         * Set timeout so that the reset of the previous guided tour on the navigation end can be processed first\r\n         * to prevent ExpressionChangedAfterItHasBeenCheckedError\r\n         */\r\n        setTimeout(() => {\r\n            this.availableTourForComponent = cloneDeep(guidedTour);\r\n            this.guidedTourAvailabilitySubject.next(true);\r\n            const hasStartedOrFinishedTour = this.checkTourState(guidedTour);\r\n            // Only start tour automatically if the user has never seen it before\r\n            if (!hasStartedOrFinishedTour && init) {\r\n                this.startTour();\r\n            }\r\n        }, 500);\r\n    }\r\n\r\n    /**\r\n     * Check if the course and exercise for the tour are available on the course-exercise component\r\n     * @param course for which the guided tour availability should be checked\r\n     * @param guidedTour that should be enabled\r\n     * @param init - if true - enables the display of the guided tour on the first visit, this parameter is used for guided tours which navigate through multiple component pages\r\n     */\r\n    public enableTourForCourseExerciseComponent(course: Course | undefined, guidedTour: GuidedTour, init: boolean): Exercise | undefined {\r\n        if (!course || !course.exercises || !this.isGuidedTourAvailableForCourse(course)) {\r\n            return undefined;\r\n        }\r\n\r\n        const exerciseForGuidedTour = course.exercises.find((exercise) => this.isGuidedTourAvailableForExercise(exercise, guidedTour));\r\n        if (exerciseForGuidedTour) {\r\n            this.enableTour(guidedTour, init);\r\n            this.currentCourse = course;\r\n            this.currentExercise = exerciseForGuidedTour;\r\n            return exerciseForGuidedTour;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Check if the course list contains the course for which the tour is available\r\n     * @param courses which can contain the needed course for the tour\r\n     * @param guidedTour that should be enabled\r\n     * @param init - if true - enables the display of the guided tour on the first visit, this parameter is used for guided tours which navigate through multiple component pages\r\n     */\r\n    public enableTourForCourseOverview(courses: Course[], guidedTour: GuidedTour, init: boolean): Course | undefined {\r\n        const courseForTour = courses.find((course) => this.isGuidedTourAvailableForCourse(course));\r\n        if (!courseForTour) {\r\n            return undefined;\r\n        }\r\n\r\n        if (this.guidedTourMapping!.tours[guidedTour.settingsKey] === '') {\r\n            this.currentCourse = courseForTour;\r\n            this.enableTour(guidedTour, init);\r\n        } else {\r\n            this.courseService.findWithExercises(courseForTour.id!).subscribe((response) => {\r\n                if (response.body?.exercises) {\r\n                    const exercises = response.body.exercises;\r\n                    const exerciseForTour = exercises.find((exercise) => this.isGuidedTourAvailableForExercise(exercise, guidedTour));\r\n\r\n                    this.currentCourse = courseForTour;\r\n                    this.currentExercise = exerciseForTour ? exerciseForTour : undefined;\r\n                }\r\n                this.enableTour(guidedTour, init);\r\n            });\r\n        }\r\n\r\n        return courseForTour;\r\n    }\r\n\r\n    /**\r\n     * Check if the exercise list contains the exercise for which the tour is available\r\n     * @param exercise which can contain the needed exercise for the tour\r\n     * @param guidedTour that should be enabled\r\n     * @param init - if true - enables the display of the guided tour on the first visit, this parameter is used for guided tours which navigate through multiple component pages\r\n     */\r\n    public enableTourForExercise(exercise: Exercise, guidedTour: GuidedTour, init: boolean): Exercise | undefined {\r\n        if (!exercise.course || !this.isGuidedTourAvailableForExercise(exercise, guidedTour)) {\r\n            return undefined;\r\n        }\r\n\r\n        this.enableTour(guidedTour, init);\r\n        this.currentExercise = exercise;\r\n        this.currentCourse = exercise.course;\r\n\r\n        return exercise;\r\n    }\r\n\r\n    /**\r\n     * Determine if the current course is a course for a guided tour\r\n     * @param course    current course\r\n     * @return true if the current course is a course for a guided tour, otherwise false\r\n     */\r\n    private isGuidedTourAvailableForCourse(course: Course): boolean {\r\n        if (!course || !this.guidedTourMapping) {\r\n            return false;\r\n        }\r\n        return course.shortName === this.guidedTourMapping.courseShortName;\r\n    }\r\n\r\n    /**\r\n     * Determine if the current exercise is an exercise for a guided tour\r\n     * @param exercise  current exercise\r\n     * @param guidedTour of which the availability should be checked\r\n     * @return true if the current exercise is an exercise for a guided tour, otherwise false\r\n     */\r\n    private isGuidedTourAvailableForExercise(exercise: Exercise, guidedTour?: GuidedTour): boolean {\r\n        if (!exercise || !this.guidedTourMapping) {\r\n            return false;\r\n        }\r\n\r\n        let exerciseMatches: boolean;\r\n        let settingsKey: string;\r\n\r\n        if (guidedTour) {\r\n            settingsKey = guidedTour.settingsKey;\r\n        } else {\r\n            settingsKey = this.currentTour ? this.currentTour.settingsKey : '';\r\n        }\r\n\r\n        if (exercise.type === ExerciseType.PROGRAMMING) {\r\n            exerciseMatches = this.guidedTourMapping.tours[settingsKey] === exercise.shortName;\r\n        } else {\r\n            exerciseMatches = this.guidedTourMapping.tours[settingsKey] === exercise.title;\r\n        }\r\n        return exerciseMatches;\r\n    }\r\n\r\n    /**\r\n     * Checks the assessment result and enables the next step click if correct\r\n     * @param assessments   current number of assessments\r\n     * @param totalScore    current total score of the assessment\r\n     */\r\n    public updateAssessmentResult(assessments: number, totalScore: number) {\r\n        this.assessmentObject.assessments = assessments;\r\n        this.assessmentObject.totalScore = totalScore;\r\n\r\n        if (this.isAssessmentCorrect()) {\r\n            this.enableNextStepClick();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the number of assessments and its total score match with the given assessment task object\r\n     */\r\n    private isAssessmentCorrect(): boolean {\r\n        if (this.currentStep.assessmentTask) {\r\n            const numberOfAssessmentsCorrect = this.assessmentObject.assessments === this.currentStep.assessmentTask.assessmentObject.assessments;\r\n            const totalScoreCorrect = this.assessmentObject.totalScore === this.currentStep.assessmentTask.assessmentObject.totalScore;\r\n\r\n            if (this.currentStep.assessmentTask.assessmentObject.totalScore === 0) {\r\n                return numberOfAssessmentsCorrect;\r\n            }\r\n            return numberOfAssessmentsCorrect && totalScoreCorrect;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["TutorParticipationService", "http", "inject", "HttpClient", "accountService", "AccountService", "resourceUrl", "create", "tutorParticipation", "exerciseId", "post", "observe", "assessExampleSubmission", "exampleSubmission", "deleteTutorParticipationForGuidedTour", "course", "exercise", "isAtLeastTutorInCourse", "delete", "id", "Observable", "factory", "\u0275fac", "providedIn", "Orientation", "GuidedTourState", "OverlayPosition", "UserInteractionEvent", "Direction", "ResetParticipation", "GuidedTourSetting", "guidedTourKey", "guidedTourStep", "guidedTourState", "constructor", "GuidedTourState", "STARTED", "TourStep", "highlightSelector", "orientation", "action", "closeAction", "disableStep", "highlightPadding", "permission", "skipStepIfNoSelector", "pageUrl", "TextTourStep", "headlineTranslateKey", "subHeadlineTranslateKey", "contentTranslateKey", "hintTranslateKey", "alreadyExecutedTranslateKey", "constructor", "tourStep", "Object", "assign", "ImageTourStep", "imageUrl", "VideoTourStep", "videoUrl", "UserInterActionTourStep", "userInteractionEvent", "triggerNextStep", "ModelingTaskTourStep", "modelingTask", "AssessmentTaskTourStep", "assessmentTask", "clickOnElement", "selector", "htmlElement", "document", "querySelector", "click", "calculateTopOffset", "element", "topOffset", "offsetTop", "offsetParent", "calculateLeftOffset", "leftOffset", "offsetLeft", "isElementInViewPortHorizontally", "orientation", "left", "width", "tourStepWidth", "elementInViewPort", "Orientation", "TOPLEFT", "window", "innerWidth", "BOTTOMLEFT", "LEFT", "TOPRIGHT", "BOTTOMRIGHT", "RIGHT", "determineUrlMatching", "pageUrl", "tourStepUrl", "indexOf", "match", "slice", "getUrlParams", "url", "length", "checkPageUrlEnding", "matchingUrl", "tempPageUrl", "endsWith", "cancelTour", "settingsKey", "resetParticipation", "ResetParticipation", "NONE", "steps", "TextTourStep", "highlightSelector", "headlineTranslateKey", "contentTranslateKey", "highlightPadding", "orientation", "Orientation", "LEFT", "closeAction", "clickOnElement", "completedTour", "hintTranslateKey", "GuidedTourModelingTask", "umlName", "taskTranslateKey", "constructor", "personUML", "name", "attribute", "studentUML", "method", "associationUML", "GuidedTourAssessmentTask", "assessmentObject", "assessmentsObject", "AssessmentObject", "assessments", "totalScore", "GuidedTourService", "http", "inject", "HttpClient", "accountService", "AccountService", "router", "Router", "profileService", "ProfileService", "participationService", "ParticipationService", "tutorParticipationService", "TutorParticipationService", "courseService", "CourseManagementService", "resourceUrl", "guidedTourSettings", "currentTour", "restartIsLoading", "currentTourStepIndex", "availableTourForComponent", "onResizeMessage", "modelingResultCorrect", "assessmentObject", "AssessmentObject", "guidedTourMapping", "currentDotSubject", "Subject", "nextDotSubject", "pageUrls", "Map", "currentCourse", "currentExercise", "guidedTourCurrentStepSubject", "guidedTourAvailabilitySubject", "isUserInteractionFinishedSubject", "checkModelingComponentSubject", "isBackPageNavigation", "BehaviorSubject", "isComponentPageLoaded", "isMobile", "init", "window", "navigator", "userAgent", "any", "getAuthenticationState", "subscribe", "user", "isLoaded", "setTimeout", "resetUserInteractionFinishedState", "currentStep", "setPreparedTourStep", "getProfileInfo", "profileInfo", "events", "event", "NavigationStart", "undefined", "NavigationEnd", "next", "checkNextTourStepOnNavigation", "skipTour", "fromEvent", "pipe", "debounceTime", "tourMinimumScreenSize", "innerWidth", "steps", "VideoTourStep", "TextTourStep", "headlineTranslateKey", "contentTranslateKey", "nextStep", "value", "userInteractionEvent", "UserInteractionEvent", "CLICK", "pageUrl", "determineUrlMatching", "url", "set", "minimumScreenSize", "getGuidedTourCurrentStepStream", "asObservable", "getGuidedTourAvailabilityStream", "map", "isTourAvailable", "userInteractionFinishedState", "checkModelingComponent", "updateModelingResult", "umlName", "result", "modelingTask", "enableNextStepClick", "componentPageLoaded", "isCurrentStep", "tourStep", "currentTourStepDisplay", "indexOf", "isCurrentTour", "guidedTour", "settingsKey", "getCurrentStepString", "totalSteps", "length", "backStep", "previousStep", "closeAction", "previousStepLocation", "determinePreviousStepLocation", "navigateByUrl", "then", "action", "resetTour", "timeout", "UserInterActionTourStep", "checkSelectorValidity", "finishGuidedTour", "completeCallback", "completedTour", "subscribeToAndUpdateGuidedTourSettings", "GuidedTourState", "STARTED", "FINISHED", "showCompletedTourStep", "skipCallback", "cancelTour", "getFilteredTourSteps", "showCancelHint", "checkTourState", "clickOnElement", "cloneDeep", "tourAllowedForWindowSize", "guidedTourState", "updatedTourState", "updateGuidedTourSettings", "filter", "body", "state", "tourSetting", "setting", "guidedTourKey", "toString", "getLastSeenTourStepIndex", "tourSettings", "hasValidTourStepNumber", "guidedTourStep", "getLastSeenTourStepForInit", "lastSeenTourStep", "isMultiPageTour", "determineTourStepForComponent", "stepsForComponent", "match", "checkPageUrlEnding", "stepForComponent", "find", "step", "getUrlParams", "tourStepsWithUrl", "index", "lastTourStepWithUrl", "last", "previousStepLocationKey", "has", "get", "document", "classList", "remove", "enableUserInteraction", "targetNode", "userInteraction", "WAIT_FOR_SELECTOR", "afterNextStep", "handleWaitForSelectorEvent", "options", "attributes", "childList", "characterData", "addEventListener", "triggerNextStep", "MONACO_EDITOR", "querySelector", "observeMutations", "mutation", "addedNodes", "removedNodes", "MODELING", "subtree", "distinctUntilChanged", "ASSESS_SUBMISSION", "isAssessmentCorrect", "highlightSelector", "waitForElement", "target", "Observable", "observer", "MutationObserver", "mutations", "forEach", "observe", "disconnect", "nextStepSelector", "afterNextStepSelector", "interval", "setInterval", "nextElement", "afterNextElement", "clearInterval", "initGuidedTour", "restartTour", "startTour", "resetParticipation", "ResetParticipation", "EXERCISE_PARTICIPATION", "isProgrammingExercise", "type", "ExerciseType", "PROGRAMMING", "findParticipationForCurrentUser", "id", "response", "mergeMap", "participation", "deleteForGuidedTour", "deleteBuildPlan", "deleteRepository", "switchMap", "deleteGuidedTourSetting", "navigateToUrlAfterRestart", "error", "TUTOR_ASSESSMENT", "deleteTutorParticipationForGuidedTour", "NONE", "location", "reload", "onload", "disableStep", "permission", "hasAnyAuthorityDirect", "currentTourStep", "isOnLastStep", "isOnFirstStep", "isOnResizeMessage", "currentTourStepCount", "preventBackdropFromAdvancing", "getPreparedTourStep", "setTourOrientation", "setStepAlreadyFinishedHint", "preparedTourStep", "convertedStep", "orientation", "sort", "a", "b", "maximumSize", "currentOrientation", "Orientation", "TOP", "orientationConfig", "orientationDirection", "skipStepIfNoSelector", "alreadyExecutedTranslateKey", "Error", "existingSettingIndex", "findIndex", "push", "GuidedTourSetting", "put", "splice", "delete", "enableTour", "enableTourForCourseExerciseComponent", "course", "exercises", "isGuidedTourAvailableForCourse", "exerciseForGuidedTour", "exercise", "isGuidedTourAvailableForExercise", "enableTourForCourseOverview", "courses", "courseForTour", "tours", "findWithExercises", "exerciseForTour", "enableTourForExercise", "shortName", "courseShortName", "exerciseMatches", "title", "updateAssessmentResult", "assessments", "totalScore", "assessmentTask", "numberOfAssessmentsCorrect", "totalScoreCorrect", "factory", "\u0275fac", "providedIn"]
}
