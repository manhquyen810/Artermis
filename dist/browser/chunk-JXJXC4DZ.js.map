{
  "version": 3,
  "sources": ["src/main/webapp/app/core/util/event-manager.service.ts", "src/main/webapp/app/core/util/alert.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\r\nimport { Observable, Observer, Subscription } from 'rxjs';\r\nimport { filter, share } from 'rxjs/operators';\r\n\r\nexport class EventWithContent<T> {\r\n    constructor(\r\n        public name: string,\r\n        public content: T,\r\n    ) {}\r\n}\r\n\r\n/**\r\n * A utility class to manage RX events\r\n */\r\n@Injectable({\r\n    providedIn: 'root',\r\n})\r\nexport class EventManager {\r\n    observable: Observable<EventWithContent<unknown> | string>;\r\n    observer?: Observer<EventWithContent<unknown> | string>;\r\n\r\n    constructor() {\r\n        this.observable = new Observable((observer: Observer<EventWithContent<unknown> | string>) => {\r\n            this.observer = observer;\r\n        }).pipe(share());\r\n    }\r\n\r\n    /**\r\n     * Method to broadcast the event to observer\r\n     */\r\n    broadcast(event: EventWithContent<unknown> | string): void {\r\n        if (this.observer) {\r\n            this.observer.next(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method to subscribe to an event with callback\r\n     * @param eventNames  Single event name or array of event names to what subscribe\r\n     * @param callback    Callback to run when the event occurs\r\n     */\r\n    subscribe(eventNames: string | string[], callback: (event: EventWithContent<unknown> | string) => void): Subscription {\r\n        if (typeof eventNames === 'string') {\r\n            eventNames = [eventNames];\r\n        }\r\n        return this.observable\r\n            .pipe(\r\n                filter((event: EventWithContent<unknown> | string) => {\r\n                    for (const eventName of eventNames) {\r\n                        if ((typeof event === 'string' && event === eventName) || (typeof event !== 'string' && event.name === eventName)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                }),\r\n            )\r\n            .subscribe(callback);\r\n    }\r\n\r\n    /**\r\n     * Method to unsubscribe the subscription\r\n     */\r\n    destroy(subscriber: Subscription): void {\r\n        subscriber.unsubscribe();\r\n    }\r\n}\r\n", "import { Injectable, NgZone, SecurityContext, inject } from '@angular/core';\r\nimport { DomSanitizer } from '@angular/platform-browser';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { translationNotFoundMessage } from 'app/core/config/translation.config';\r\nimport { EventManager, EventWithContent } from 'app/core/util/event-manager.service';\r\nimport { AlertError } from 'app/shared/alert/alert-error.model';\r\nimport { Subscription } from 'rxjs';\r\nimport { captureException } from '@sentry/angular';\r\nimport { IconDefinition, faCheckCircle, faExclamationCircle, faExclamationTriangle, faInfoCircle } from '@fortawesome/free-solid-svg-icons';\r\nimport { HttpErrorResponse } from '@angular/common/http';\r\nimport dayjs from 'dayjs/esm';\r\n\r\nexport class AlertType {\r\n    public static readonly SUCCESS = new AlertType(faCheckCircle, 'success', 'btn-success');\r\n    public static readonly DANGER = new AlertType(faExclamationCircle, 'danger', 'btn-danger');\r\n    public static readonly WARNING = new AlertType(faExclamationTriangle, 'warning', 'btn-warning');\r\n    public static readonly INFO = new AlertType(faInfoCircle, 'info', 'btn-info');\r\n\r\n    private constructor(icon: IconDefinition, containerClassName: string, buttonClassName: string) {\r\n        this.icon = icon;\r\n        this.containerClassName = containerClassName;\r\n        this.buttonClassName = buttonClassName;\r\n    }\r\n\r\n    public readonly icon: IconDefinition;\r\n    public readonly containerClassName: string;\r\n    public readonly buttonClassName: string;\r\n}\r\n\r\ninterface AlertBase {\r\n    type: AlertType;\r\n    message?: string;\r\n    timeout?: number;\r\n    action?: { readonly label: string; readonly callback: (alert: Alert) => void };\r\n    onClose?: (alert: Alert) => void;\r\n    dismissible?: boolean;\r\n}\r\n\r\nexport interface AlertCreationProperties extends AlertBase {\r\n    translationKey?: string;\r\n    translationParams?: { [key: string]: unknown };\r\n    disableTranslation?: boolean;\r\n}\r\n\r\ninterface AlertInternal extends AlertBase {\r\n    close: () => void;\r\n    isOpen: boolean;\r\n    openedAt?: dayjs.Dayjs;\r\n}\r\n\r\nexport type Alert = Readonly<AlertInternal>;\r\n\r\nconst DEFAULT_TIMEOUT = 15000;\r\nconst DEFAULT_DISMISSIBLE = true;\r\n\r\n@Injectable({\r\n    providedIn: 'root',\r\n})\r\nexport class AlertService {\r\n    private sanitizer = inject(DomSanitizer);\r\n    private ngZone = inject(NgZone);\r\n    private translateService = inject(TranslateService);\r\n\r\n    private alerts: AlertInternal[] = [];\r\n\r\n    errorListener: Subscription;\r\n    httpErrorListener: Subscription;\r\n\r\n    readonly conflictErrorKeysToSkip: string[] = ['cannotRegisterInstructor'];\r\n\r\n    constructor() {\r\n        const eventManager = inject(EventManager);\r\n\r\n        this.errorListener = eventManager.subscribe('artemisApp.error', (response: EventWithContent<unknown> | string) => {\r\n            const errorResponse = (response as EventWithContent<AlertError>).content;\r\n            this.addErrorAlert(errorResponse.message, errorResponse.translationKey, errorResponse.translationParams);\r\n        });\r\n\r\n        this.httpErrorListener = eventManager.subscribe('artemisApp.httpError', (response: any) => {\r\n            const httpErrorResponse: HttpErrorResponse = response.content;\r\n            if (httpErrorResponse.error?.skipAlert) {\r\n                return;\r\n            }\r\n            switch (httpErrorResponse.status) {\r\n                // connection refused, server not reachable\r\n                case 0:\r\n                    this.addErrorAlert('Server not reachable', 'error.server.not.reachable');\r\n                    break;\r\n\r\n                case 400:\r\n                    const arr = httpErrorResponse.headers.keys();\r\n                    let errorHeader = null;\r\n                    let entityKey = null;\r\n                    arr.forEach((entry: string) => {\r\n                        if (entry.toLowerCase().endsWith('app-error')) {\r\n                            errorHeader = httpErrorResponse.headers.get(entry);\r\n                        } else if (entry.toLowerCase().endsWith('app-params')) {\r\n                            entityKey = httpErrorResponse.headers.get(entry);\r\n                        }\r\n                    });\r\n                    if (errorHeader && !this.translateService.instant(errorHeader).startsWith(translationNotFoundMessage)) {\r\n                        const entityName = this.translateService.instant('global.menu.entities.' + entityKey);\r\n                        this.addErrorAlert(errorHeader, errorHeader, { entityName, ...httpErrorResponse.error?.params });\r\n                    } else if (httpErrorResponse.error && httpErrorResponse.error.fieldErrors) {\r\n                        const fieldErrors = httpErrorResponse.error.fieldErrors;\r\n                        for (const fieldError of fieldErrors) {\r\n                            // This is most likely related to server side field validations and gentrifies the error message\r\n                            // to only tell the user that the size is wrong instead of the specific field\r\n                            if (['Min', 'Max', 'DecimalMin', 'DecimalMax'].includes(fieldError.message)) {\r\n                                fieldError.message = 'size';\r\n                            }\r\n                            // convert 'something[14].other[4].id' to 'something[].other[].id' so translations can be written to it\r\n                            const convertedField = fieldError.field.replace(/\\[\\d*\\]/g, '[]');\r\n                            const fieldName = this.translateService.instant('artemisApp.' + fieldError.objectName + '.' + convertedField);\r\n                            this.addErrorAlert('Error on field \"' + fieldName + '\"', 'error.' + fieldError.message, { fieldName });\r\n                        }\r\n                    } else if (httpErrorResponse.error && httpErrorResponse.error.title) {\r\n                        this.addErrorAlert(httpErrorResponse.error.title, httpErrorResponse.error.message, httpErrorResponse.error.params);\r\n                    }\r\n                    break;\r\n\r\n                case 404:\r\n                    // Disabled\r\n                    break;\r\n\r\n                default:\r\n                    if (httpErrorResponse.error && httpErrorResponse.error.title) {\r\n                        // To avoid displaying this alerts twice, we need to filter the received errors. In this case, we filter for the cannot register instructor error.\r\n                        if (httpErrorResponse.status === 403 && this.conflictErrorKeysToSkip.includes(httpErrorResponse.error.errorKey)) {\r\n                            break;\r\n                        }\r\n                        this.addErrorAlert(httpErrorResponse.error.title, httpErrorResponse.error.message, httpErrorResponse.error.params);\r\n                    }\r\n            }\r\n        });\r\n    }\r\n\r\n    closeAll(): void {\r\n        [...this.alerts].forEach((alert) => alert.close());\r\n    }\r\n\r\n    get(): Alert[] {\r\n        return this.alerts;\r\n    }\r\n\r\n    /**\r\n     * Adds alert to alerts array and returns added alert.\r\n     * @param alert   Alert specification to add. If `timeout` or `dismissible` is missing then applying default value.\r\n     *                Set timeout to zero to disable timeout\r\n     * @returns       Added alert\r\n     */\r\n    addAlert(alert: AlertCreationProperties): Alert {\r\n        // Defensive copy to prevent overwrites\r\n        const alertInternal: AlertInternal = {\r\n            type: alert.type,\r\n            message: alert.message,\r\n            timeout: alert.timeout,\r\n            action: alert.action,\r\n            onClose: alert.onClose,\r\n            dismissible: alert.dismissible,\r\n            isOpen: false,\r\n        } as AlertInternal;\r\n\r\n        if (!alert.disableTranslation && (alert.translationKey || alert.message)) {\r\n            // in case a translation key is defined, we use it to create the message\r\n            // Note: in most cases, our code passes the translation key as message\r\n            let translationKey: string;\r\n            if (alert.translationKey) {\r\n                translationKey = alert.translationKey;\r\n            } else {\r\n                translationKey = alert.message!;\r\n            }\r\n\r\n            const translatedMessage = this.translateService.instant(translationKey, alert.translationParams);\r\n\r\n            const translationFound = !translatedMessage.startsWith(translationNotFoundMessage);\r\n            if (translationFound) {\r\n                alertInternal.message = translatedMessage;\r\n            } else {\r\n                // Sent a sentry warning with the unknown translation key\r\n                captureException(new Error('Unknown translation key: ' + translationKey));\r\n\r\n                // Fallback to displaying the translation key\r\n                // Keeping the original message if it exists in case the message field is supplied with a default english version, and\r\n                // the translationKey field is used for translations\r\n                if (!alert.message) {\r\n                    alertInternal.message = translationKey;\r\n                }\r\n            }\r\n        }\r\n\r\n        alertInternal.message = this.sanitizer.sanitize(SecurityContext.HTML, alertInternal.message ?? '') ?? '';\r\n        alertInternal.timeout = alertInternal.timeout ?? DEFAULT_TIMEOUT;\r\n        alertInternal.dismissible = alertInternal.dismissible ?? DEFAULT_DISMISSIBLE;\r\n        alertInternal.close = () => {\r\n            alertInternal.isOpen = false;\r\n            const alertIndex = this.alerts.indexOf(alertInternal);\r\n            if (alertIndex >= 0) {\r\n                this.alerts.splice(alertIndex, 1);\r\n                if (alertInternal.onClose) {\r\n                    alertInternal.onClose(alertInternal);\r\n                }\r\n            }\r\n        };\r\n        if (alertInternal.action) {\r\n            alertInternal.action = {\r\n                label: this.sanitizer.sanitize(SecurityContext.HTML, this.translateService.instant(alertInternal.action.label) ?? '') ?? '',\r\n                callback: alertInternal.action.callback,\r\n            };\r\n        }\r\n\r\n        if (alert.message) {\r\n            alertInternal.isOpen = true;\r\n            alertInternal.openedAt = dayjs();\r\n\r\n            // Due to duplicate alerts spawned by the global http error interceptor and some components,\r\n            // we prevent more than one alert with the same content to be spawned within 50 milliseconds.\r\n            // If such an alert already exists, we return the old one instead.\r\n            const olderAlertWithIdenticalContent: AlertInternal | undefined = this.alerts.find(\r\n                (otherAlert) => alertInternal.message === otherAlert.message && Math.abs(alertInternal.openedAt!.diff(otherAlert.openedAt!, 'ms')) <= 50,\r\n            );\r\n            if (olderAlertWithIdenticalContent) {\r\n                return olderAlertWithIdenticalContent;\r\n            }\r\n\r\n            this.alerts.unshift(alertInternal);\r\n\r\n            if (alertInternal.timeout > 0) {\r\n                // Workaround protractor waiting for setTimeout.\r\n                // Reference https://www.protractortest.org/#/timeouts\r\n                this.ngZone.runOutsideAngular(() => {\r\n                    setTimeout(() => {\r\n                        this.ngZone.run(() => {\r\n                            alertInternal.close();\r\n                        });\r\n                    }, alertInternal.timeout);\r\n                });\r\n            }\r\n        }\r\n\r\n        return alertInternal;\r\n    }\r\n\r\n    success(message: string, translationParams?: { [key: string]: unknown }): Alert {\r\n        return this.addAlert({\r\n            type: AlertType.SUCCESS,\r\n            message,\r\n            translationParams,\r\n        });\r\n    }\r\n\r\n    error(message: string, translationParams?: { [key: string]: unknown }): Alert {\r\n        return this.addAlert({\r\n            type: AlertType.DANGER,\r\n            message,\r\n            translationParams,\r\n        });\r\n    }\r\n\r\n    warning(message: string, translationParams?: { [key: string]: unknown }): Alert {\r\n        return this.addAlert({\r\n            type: AlertType.WARNING,\r\n            message,\r\n            translationParams,\r\n        });\r\n    }\r\n\r\n    info(message: string, translationParams?: { [key: string]: unknown }): Alert {\r\n        return this.addAlert({\r\n            type: AlertType.INFO,\r\n            message,\r\n            translationParams,\r\n        });\r\n    }\r\n\r\n    addErrorAlert(message?: any, translationKey?: string, translationParams?: { [key: string]: unknown }): void {\r\n        if (message && typeof message !== 'string') {\r\n            message = '' + message;\r\n        }\r\n        this.addAlert({ type: AlertType.DANGER, message, translationKey, translationParams });\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["EventManager", "observable", "observer", "constructor", "Observable", "pipe", "share", "broadcast", "event", "next", "subscribe", "eventNames", "callback", "filter", "eventName", "name", "destroy", "subscriber", "unsubscribe", "factory", "\u0275fac", "providedIn", "AlertType", "SUCCESS", "faCheckCircle", "DANGER", "faExclamationCircle", "WARNING", "faExclamationTriangle", "INFO", "faInfoCircle", "constructor", "icon", "containerClassName", "buttonClassName", "DEFAULT_TIMEOUT", "DEFAULT_DISMISSIBLE", "AlertService", "sanitizer", "inject", "DomSanitizer", "ngZone", "NgZone", "translateService", "TranslateService", "alerts", "errorListener", "httpErrorListener", "conflictErrorKeysToSkip", "eventManager", "EventManager", "subscribe", "response", "errorResponse", "content", "addErrorAlert", "message", "translationKey", "translationParams", "httpErrorResponse", "error", "skipAlert", "status", "arr", "headers", "keys", "errorHeader", "entityKey", "forEach", "entry", "toLowerCase", "endsWith", "get", "instant", "startsWith", "translationNotFoundMessage", "entityName", "__spreadValues", "params", "fieldErrors", "fieldError", "includes", "convertedField", "field", "replace", "fieldName", "objectName", "title", "errorKey", "closeAll", "alert", "close", "addAlert", "alertInternal", "type", "timeout", "action", "onClose", "dismissible", "isOpen", "disableTranslation", "translatedMessage", "captureException", "Error", "sanitize", "SecurityContext", "HTML", "alertIndex", "indexOf", "splice", "label", "callback", "openedAt", "dayjs", "olderAlertWithIdenticalContent", "find", "otherAlert", "Math", "abs", "diff", "unshift", "runOutsideAngular", "setTimeout", "run", "success", "warning", "info", "factory", "\u0275fac", "providedIn"]
}
