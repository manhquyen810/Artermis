{
  "version": 3,
  "sources": ["src/main/webapp/app/grading-system/bonus/bonus.service.ts"],
  "sourcesContent": ["import { Injectable, inject } from '@angular/core';\r\nimport { HttpClient, HttpParams, HttpResponse } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { GradeStep, GradeStepsDTO } from 'app/entities/grade-step.model';\r\nimport { Bonus, BonusExample, BonusStrategy } from 'app/entities/bonus.model';\r\nimport { GradingScale } from 'app/entities/grading-scale.model';\r\nimport { GradingSystemService } from 'app/grading-system/grading-system.service';\r\nimport { roundValueSpecifiedByCourseSettings } from 'app/shared/util/utils';\r\n\r\nexport type EntityResponseType = HttpResponse<Bonus>;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class BonusService {\r\n    private http = inject(HttpClient);\r\n    private gradingSystemService = inject(GradingSystemService);\r\n\r\n    public resourceUrl = 'api/assessment';\r\n\r\n    /**\r\n     * Deletes the bonus.\r\n     *\r\n     * @param courseId the course to which the exam belongs\r\n     * @param examId the exam for which the bonus will be deleted\r\n     * @param bonusId the id of the bonus which will be deleted\r\n     */\r\n    deleteBonus(courseId: number, examId: number, bonusId: number): Observable<HttpResponse<void>> {\r\n        return this.http.delete<void>(`${this.resourceUrl}/courses/${courseId}/exams/${examId}/bonus/${bonusId}`, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Store a new bonus for exam on the server\r\n     *\r\n     * @param courseId the course to which the exam belongs\r\n     * @param examId the exam for which the bonus will be created\r\n     * @param bonus the bonus to be created\r\n     */\r\n    createBonusForExam(courseId: number, examId: number, bonus: Bonus): Observable<EntityResponseType> {\r\n        return this.http.post<Bonus>(`${this.resourceUrl}/courses/${courseId}/exams/${examId}/bonus`, this.filterBonusForRequest(bonus), { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Update a bonus on the server\r\n     *\r\n     * @param courseId the course to which the exam belongs\r\n     * @param examId the exam for which the bonus will be updated\r\n     * @param bonus the bonus to be updated\r\n     */\r\n    updateBonus(courseId: number, examId: number, bonus: Bonus): Observable<EntityResponseType> {\r\n        return this.http.put<Bonus>(`${this.resourceUrl}/courses/${courseId}/exams/${examId}/bonus/${bonus.id}`, this.filterBonusForRequest(bonus), { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Retrieves the bonus for exam\r\n     *\r\n     * @param courseId the course to which the exam belongs\r\n     * @param examId the exam for which the bonus will be retrieved\r\n     * @param includeSourceGradeSteps optional, specifies whether the returned result should include the grade steps of sourceGradingScale. By default, they are excluded\r\n     */\r\n    findBonusForExam(courseId: number, examId: number, includeSourceGradeSteps?: boolean): Observable<EntityResponseType> {\r\n        const params = includeSourceGradeSteps != undefined ? new HttpParams().set('includeSourceGradeSteps', includeSourceGradeSteps.toString()) : undefined;\r\n        return this.http.get<Bonus>(`${this.resourceUrl}/courses/${courseId}/exams/${examId}/bonus`, { observe: 'response', params });\r\n    }\r\n\r\n    /**\r\n     * Generates calculation examples to give users an idea how the bonus will contribute to the final grade.\r\n     * The generated values includes max, min grades and some intermediate grade step boundaries.\r\n     *\r\n     * @param bonus bonus.sourceGradingScale.gradeSteps are assumed to be sorted\r\n     * @param bonusTo gradeSteps are assumed to be sorted\r\n     */\r\n    generateBonusExamples(bonus: Bonus, bonusTo: GradeStepsDTO): BonusExample[] {\r\n        if (!bonus.sourceGradingScale) {\r\n            throw new Error(`Bonus.sourceGradingScale is empty: ${bonus.sourceGradingScale}`);\r\n        }\r\n        const bonusExamples = this.generateExampleExamAndBonusPoints(bonusTo, bonus.sourceGradingScale);\r\n        bonusExamples.forEach((bonusExample) => this.calculateFinalGrade(bonusExample, bonus, bonusTo));\r\n        return bonusExamples;\r\n    }\r\n\r\n    /**\r\n     * Creates a filtered bonus to send in the request body to reduce payload size and make tracking the changes easier for\r\n     * diagnosis purposes by filtering out irrelevant parts.\r\n     *\r\n     * @param bonus to be sent to the server\r\n     */\r\n    private filterBonusForRequest(bonus: Bonus) {\r\n        return {\r\n            ...bonus,\r\n            sourceGradingScale: bonus.sourceGradingScale ? { id: bonus.sourceGradingScale.id } : undefined,\r\n            bonusToGradingScale: undefined,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Determines the example input values for BonusExamples (studentPointsOfBonusTo and studentPointsOfBonusSource).\r\n     * The generated values includes points corresponding to max, min grades and some intermediate grade step boundaries.\r\n     *\r\n     * @param bonusTo gradeSteps are assumed to be sorted\r\n     * @param source gradeSteps are assumed to be sorted\r\n     */\r\n    private generateExampleExamAndBonusPoints(bonusTo: GradeStepsDTO, source: GradingScale): BonusExample[] {\r\n        const examples: BonusExample[] = [];\r\n        examples.push(new BonusExample(0, undefined));\r\n\r\n        let bonusToGradeStepIndex = bonusTo.gradeSteps.findIndex((gs) => gs.isPassingGrade);\r\n        if (bonusToGradeStepIndex < 0) {\r\n            throw Error('No passing grade was found for bonusTo grading scale');\r\n        }\r\n\r\n        let sourceGradeStepIndex = source.gradeSteps.length - 1;\r\n\r\n        const sourceMaxPoints = this.gradingSystemService.getGradingScaleMaxPoints(source);\r\n\r\n        for (let i = 0; i < 3; i++) {\r\n            const bonusToGradeStep = bonusTo.gradeSteps[bonusToGradeStepIndex];\r\n            const studentPointsOfBonusTo = this.getIncludedBoundaryPoints(bonusToGradeStep, bonusTo.maxPoints!) ?? this.findMiddlePoint(bonusToGradeStep);\r\n\r\n            const sourceGradeStep = source.gradeSteps[sourceGradeStepIndex];\r\n            const studentPointsOfBonusSource = this.getIncludedBoundaryPoints(sourceGradeStep, sourceMaxPoints) ?? this.findMiddlePoint(sourceGradeStep);\r\n\r\n            examples.push(new BonusExample(studentPointsOfBonusTo!, studentPointsOfBonusSource!));\r\n\r\n            // Source grade steps descend and bonusTo grade steps ascend to provide somewhat more balanced examples\r\n            // although this is not a hard rule.\r\n\r\n            if (i === 0 && sourceGradeStep.lowerBoundPoints === sourceMaxPoints && !sourceGradeStep.lowerBoundInclusive) {\r\n                // Edge case on first iteration: The condition above causes the sourceMaxPoints to be included in the\r\n                // next source grade step so we should skip it to not have examples with duplicate bonus values.\r\n                sourceGradeStepIndex = this.modulo(sourceGradeStepIndex - 1, source.gradeSteps.length);\r\n            }\r\n\r\n            sourceGradeStepIndex = this.modulo(sourceGradeStepIndex - 1, source.gradeSteps.length);\r\n            bonusToGradeStepIndex = this.modulo(bonusToGradeStepIndex + 1, bonusTo.gradeSteps.length);\r\n        }\r\n\r\n        bonusToGradeStepIndex = bonusTo.gradeSteps.length - 1;\r\n        const lastBonusToGradeStep = bonusTo.gradeSteps[bonusToGradeStepIndex];\r\n        const lastStudentPointsOfBonusTo = this.getIncludedBoundaryPoints(lastBonusToGradeStep, bonusTo.maxPoints!) ?? this.findMiddlePoint(lastBonusToGradeStep);\r\n\r\n        let lastSourceGradeStep = source.gradeSteps[sourceGradeStepIndex];\r\n        if (this.gradingSystemService.getNumericValueForGradeName(lastSourceGradeStep.gradeName) === 0) {\r\n            // A non-zero bonus serves better as an example.\r\n            lastSourceGradeStep = source.gradeSteps[source.gradeSteps.length - 1];\r\n        }\r\n        const lastStudentPointsOfBonusSource = this.getIncludedBoundaryPoints(lastSourceGradeStep, sourceMaxPoints) ?? this.findMiddlePoint(lastSourceGradeStep);\r\n\r\n        examples.push(new BonusExample(lastStudentPointsOfBonusTo!, lastStudentPointsOfBonusSource!));\r\n\r\n        return examples;\r\n    }\r\n\r\n    private findMiddlePoint(gradeStep: GradeStep) {\r\n        return ((gradeStep.lowerBoundPoints ?? 0) + (gradeStep.upperBoundPoints ?? 0)) / 2;\r\n    }\r\n\r\n    /**\r\n     * Applies bonus from bonus.sourceGradingScale to bonusToGradingScale grade steps with student points from bonusExample.\r\n     *\r\n     * @param bonusExample Modified by this method. studentPointsOfBonusSource and studentPointsOfBonusSource fields are read, others are (over)written\r\n     * @param bonus Contains calculation instructions and source grading scale\r\n     * @param bonusTo Grading scale that will have its grades improved by bonus\r\n     */\r\n    calculateFinalGrade(bonusExample: BonusExample, bonus: Bonus, bonusTo: GradeStepsDTO) {\r\n        const examGradeStep = this.gradingSystemService.findMatchingGradeStepByPoints(bonusTo.gradeSteps, bonusExample.studentPointsOfBonusTo, bonusTo.maxPoints!);\r\n        bonusExample.examGrade = examGradeStep?.gradeName;\r\n\r\n        if (!examGradeStep?.isPassingGrade || !bonus.sourceGradingScale) {\r\n            bonusExample.bonusGrade = 0;\r\n            bonusExample.finalPoints = bonusExample.studentPointsOfBonusTo;\r\n            bonusExample.finalGrade = bonusExample.examGrade;\r\n            return;\r\n        }\r\n\r\n        const bonusGradeStep = this.gradingSystemService.findMatchingGradeStepByPoints(\r\n            bonus.sourceGradingScale.gradeSteps,\r\n            bonusExample.studentPointsOfBonusSource ?? 0,\r\n            this.gradingSystemService.getGradingScaleMaxPoints(bonus.sourceGradingScale),\r\n        );\r\n        bonusExample.bonusGrade = this.gradingSystemService.getNumericValueForGradeName(bonusGradeStep?.gradeName);\r\n\r\n        this.calculateBonusForStrategy(bonusExample, bonus, bonusTo);\r\n    }\r\n\r\n    /**\r\n     * {@see calculateFinalGrade}. This method contains the calculation logic for each bonus strategy. Does not perform passing grade check.\r\n     * @param bonusExample Modified by this method. studentPointsOfBonusSource, studentPointsOfBonusSource and bonusGrade fields are read, others are (over)written\r\n     * @param bonus Contains calculation instructions and source grading scale\r\n     * @param bonusTo Grading scale that will have its grades improved by bonus\r\n     */\r\n    private calculateBonusForStrategy(bonusExample: BonusExample, bonus: Bonus, bonusTo: GradeStepsDTO) {\r\n        const course = this.gradingSystemService.getGradingScaleCourse(bonus.bonusToGradingScale);\r\n        switch (bonus.bonusStrategy) {\r\n            case BonusStrategy.POINTS: {\r\n                bonusExample.finalPoints = roundValueSpecifiedByCourseSettings(bonusExample.studentPointsOfBonusTo + (bonus.weight ?? 1) * bonusExample.bonusGrade!, course);\r\n\r\n                bonusExample.exceedsMax = this.doesBonusExceedMax(bonusExample.finalPoints, bonusTo.maxPoints!, bonus.weight!);\r\n                if (bonusExample.exceedsMax) {\r\n                    bonusExample.finalPoints = bonusTo.maxPoints ?? 0;\r\n                }\r\n                const finalGradeStep = this.gradingSystemService.findMatchingGradeStepByPoints(bonusTo.gradeSteps, bonusExample.finalPoints, bonusTo.maxPoints!);\r\n                bonusExample.finalGrade = finalGradeStep?.gradeName;\r\n                break;\r\n            }\r\n            case BonusStrategy.GRADES_CONTINUOUS: {\r\n                const examGradeNumericValue = this.gradingSystemService.getNumericValueForGradeName(bonusExample.examGrade as string)!;\r\n                bonusExample.finalGrade = roundValueSpecifiedByCourseSettings(examGradeNumericValue + (bonus.weight ?? 1) * bonusExample.bonusGrade!, course);\r\n                const maxGrade = this.gradingSystemService.maxGrade(bonusTo.gradeSteps);\r\n                const maxGradeNumericValue = this.gradingSystemService.getNumericValueForGradeName(maxGrade)!;\r\n\r\n                bonusExample.exceedsMax = this.doesBonusExceedMax(bonusExample.finalGrade, maxGradeNumericValue, bonus.weight!);\r\n                if (bonusExample.exceedsMax) {\r\n                    bonusExample.finalGrade = maxGrade;\r\n                }\r\n                break;\r\n            }\r\n            case BonusStrategy.GRADES_DISCRETE: {\r\n                throw new Error('GRADES_DISCRETE bonus strategy not yet implemented');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if valueWithBonus exceeds the maxValue in the direction given by calculationSign.\r\n     * @param valueWithBonus achieved points or numeric grade with bonus applied\r\n     * @param maxValue max points or max grade (numeric)\r\n     * @param calculationSign a negative or positive number to indicate decreasing or increasing direction, respectively\r\n     */\r\n    doesBonusExceedMax(valueWithBonus: number, maxValue: number, calculationSign: number) {\r\n        return (valueWithBonus - maxValue) * calculationSign! > 0;\r\n    }\r\n\r\n    /**\r\n     * Get the included points\r\n     * @param gradeStep\r\n     * @param maxPoints\r\n     */\r\n    getIncludedBoundaryPoints(gradeStep: GradeStep, maxPoints: number) {\r\n        if (gradeStep.lowerBoundInclusive) {\r\n            return gradeStep.lowerBoundPoints;\r\n        }\r\n        if (gradeStep.upperBoundInclusive) {\r\n            return Math.min(gradeStep.upperBoundPoints!, maxPoints);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * As opposed to % operator, this method always returns a non-negative number.\r\n     * @param n as in n mod m\r\n     * @param m as in n mod m\r\n     */\r\n    private modulo(n: number, m: number) {\r\n        return ((n % m) + m) % m;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["BonusService", "http", "inject", "HttpClient", "gradingSystemService", "GradingSystemService", "resourceUrl", "deleteBonus", "courseId", "examId", "bonusId", "delete", "observe", "createBonusForExam", "bonus", "post", "filterBonusForRequest", "updateBonus", "put", "id", "findBonusForExam", "includeSourceGradeSteps", "params", "undefined", "HttpParams", "set", "toString", "get", "generateBonusExamples", "bonusTo", "sourceGradingScale", "Error", "bonusExamples", "generateExampleExamAndBonusPoints", "forEach", "bonusExample", "calculateFinalGrade", "__spreadProps", "__spreadValues", "bonusToGradingScale", "source", "examples", "push", "BonusExample", "bonusToGradeStepIndex", "gradeSteps", "findIndex", "gs", "isPassingGrade", "sourceGradeStepIndex", "length", "sourceMaxPoints", "getGradingScaleMaxPoints", "i", "bonusToGradeStep", "studentPointsOfBonusTo", "getIncludedBoundaryPoints", "maxPoints", "findMiddlePoint", "sourceGradeStep", "studentPointsOfBonusSource", "lowerBoundPoints", "lowerBoundInclusive", "modulo", "lastBonusToGradeStep", "lastStudentPointsOfBonusTo", "lastSourceGradeStep", "getNumericValueForGradeName", "gradeName", "lastStudentPointsOfBonusSource", "gradeStep", "upperBoundPoints", "examGradeStep", "findMatchingGradeStepByPoints", "examGrade", "bonusGrade", "finalPoints", "finalGrade", "bonusGradeStep", "calculateBonusForStrategy", "course", "getGradingScaleCourse", "bonusStrategy", "BonusStrategy", "POINTS", "roundValueSpecifiedByCourseSettings", "weight", "exceedsMax", "doesBonusExceedMax", "finalGradeStep", "GRADES_CONTINUOUS", "examGradeNumericValue", "maxGrade", "maxGradeNumericValue", "GRADES_DISCRETE", "valueWithBonus", "maxValue", "calculationSign", "upperBoundInclusive", "Math", "min", "n", "m", "factory", "\u0275fac", "providedIn"]
}
