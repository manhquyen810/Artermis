{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/shared/team/team.service.ts"],
  "sourcesContent": ["import { HttpClient, HttpResponse } from '@angular/common/http';\r\nimport { Injectable, OnDestroy, inject } from '@angular/core';\r\nimport { AccountService } from 'app/core/auth/account.service';\r\nimport { User } from 'app/core/user/user.model';\r\nimport { WebsocketService } from 'app/core/websocket/websocket.service';\r\nimport { Course } from 'app/entities/course.model';\r\nimport { Exercise } from 'app/entities/exercise.model';\r\nimport { StudentWithTeam, Team, TeamAssignmentPayload, TeamImportStrategyType } from 'app/entities/team.model';\r\nimport { TeamSearchUser } from 'app/entities/team-search-user.model';\r\nimport { downloadFile } from 'app/shared/util/download.util';\r\nimport { createRequestOption } from 'app/shared/util/request.util';\r\nimport { Observable, Subscription } from 'rxjs';\r\nimport { filter, map, shareReplay } from 'rxjs/operators';\r\nimport { EntityResponseType } from 'app/exercises/shared/exercise/exercise.service';\r\nimport { convertDateFromClient, convertDateFromServer } from 'app/utils/date.utils';\r\n\r\nexport type TeamResponse = HttpResponse<Team>;\r\nexport type TeamArrayResponse = HttpResponse<Team[]>;\r\n\r\nconst teamAssignmentUpdatesWebsocketTopic = '/user/topic/team-assignments';\r\n\r\nexport interface ITeamService {\r\n    /**\r\n     * Create a team for a given exercise\r\n     * @param {Exercise} exercise - Exercise to create the team for\r\n     * @param {Team} team - Team to create\r\n     */\r\n    create(exercise: Exercise, team: Team): Observable<TeamResponse>;\r\n\r\n    /**\r\n     * Update a team\r\n     * @param {Exercise} exercise - Exercise the team belongs to\r\n     * @param {Team} team - Team to update\r\n     */\r\n    update(exercise: Exercise, team: Team): Observable<TeamResponse>;\r\n\r\n    /**\r\n     * Get a team belonging to a given exercise\r\n     * @param {Exercise} exercise - Exercise to search through\r\n     * @param {number} teamId - Team to search for\r\n     */\r\n    find(exercise: Exercise, teamId: number): Observable<TeamResponse>;\r\n\r\n    /**\r\n     * Get all teams belonging to a given exercise\r\n     * @param {number} exerciseId - Exercise to search through\r\n     * @param {number} teamOwnerId - Optional team owner id by which to filter exercises\r\n     */\r\n    findAllByExerciseId(exerciseId: number, teamOwnerId?: number): Observable<HttpResponse<Team[]>>;\r\n\r\n    /**\r\n     * Delete a team\r\n     * @param {Exercise} exercise - Exercise the team belongs to\r\n     * @param {number} teamId - Team to delete\r\n     */\r\n    delete(exercise: Exercise, teamId: number): Observable<HttpResponse<any>>;\r\n\r\n    /**\r\n     * Check if a given team short name exists in a course\r\n     * @param {Course} course - Course in which to search\r\n     * @param {string} shortName - Short name to search for\r\n     */\r\n    existsByShortName(course: Course, shortName: string): Observable<HttpResponse<boolean>>;\r\n\r\n    /**\r\n     * Find the team of a login/name in a given exercise and course\r\n     * @param {Course} course - Course to search in\r\n     * @param {Exercise} exercise - Exercise to search in\r\n     * @param {string} loginOrName - Login/Name to search for\r\n     */\r\n    searchInCourseForExerciseTeam(course: Course, exercise: Exercise, loginOrName: string): Observable<HttpResponse<TeamSearchUser[]>>;\r\n\r\n    /**\r\n     * Import the teams of an existing source exercise\r\n     * @param {Exercise} exercise - Exercise the teams should be imported into\r\n     * @param {Exercise} sourceExercise - Exercise the teams should be imported from\r\n     * @param {TeamImportStrategyType} importStrategyType - Strategy to use for the import\r\n     */\r\n    importTeamsFromSourceExercise(exercise: Exercise, sourceExercise: Exercise, importStrategyType: TeamImportStrategyType): Observable<HttpResponse<Team[]>>;\r\n\r\n    /**\r\n     * Import the teams of an existing source exercise\r\n     * @param {Exercise} exercise - Exercise the teams should be imported into\r\n     * @param {Team[]} teams - Teams that should be imported into the exercise\r\n     * @param {TeamImportStrategyType} importStrategyType - How the teams should be imported\r\n     */\r\n    importTeams(exercise: Exercise, teams: Team[], importStrategyType: TeamImportStrategyType): Observable<HttpResponse<Team[]>>;\r\n\r\n    /**\r\n     * Finds a course with all its team exercises and participations in which the given team exists\r\n     * @param {Course} course - Course which to find\r\n     * @param {Team} team - Team for which to find exercises and participations (by team short name)\r\n     */\r\n    findCourseWithExercisesAndParticipationsForTeam(course: Course, team: Team): Observable<HttpResponse<Course>>;\r\n\r\n    /**\r\n     * Exports given teams into json file\r\n     * @param teams Teams to add to export file\r\n     */\r\n    exportTeams(teams: Team[]): void;\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class TeamService implements ITeamService, OnDestroy {\r\n    private http = inject(HttpClient);\r\n    private websocketService = inject(WebsocketService);\r\n    private accountService = inject(AccountService);\r\n\r\n    // Team Assignment Update Stream\r\n    private teamAssignmentUpdates$: Observable<TeamAssignmentPayload> | null;\r\n    private teamAssignmentUpdatesResolver: () => void;\r\n    private authenticationStateSubscriber: Subscription;\r\n    private websocketStatusSubscription?: Subscription;\r\n\r\n    ngOnDestroy(): void {\r\n        this.websocketStatusSubscription?.unsubscribe();\r\n    }\r\n\r\n    static resourceUrl(exerciseId: number) {\r\n        return `api/exercise/exercises/${exerciseId}/teams`;\r\n    }\r\n\r\n    /**\r\n     * Create a team for a given exercise\r\n     * @param {Exercise} exercise - Exercise to create the team for\r\n     * @param {Team} team - Team to create\r\n     */\r\n    create(exercise: Exercise, team: Team): Observable<TeamResponse> {\r\n        const copy = TeamService.convertTeamDatesFromClient(team);\r\n        return this.http\r\n            .post<Team>(TeamService.resourceUrl(exercise.id!), copy, { observe: 'response' })\r\n            .pipe(map((res: TeamResponse) => TeamService.convertTeamResponseDatesFromServer(res)));\r\n    }\r\n\r\n    /**\r\n     * Update a team\r\n     * @param {Exercise} exercise - Exercise the team belongs to\r\n     * @param {Team} team - Team to update\r\n     */\r\n    update(exercise: Exercise, team: Team): Observable<TeamResponse> {\r\n        const copy = TeamService.convertTeamDatesFromClient(team);\r\n        return this.http\r\n            .put<Team>(`${TeamService.resourceUrl(exercise.id!)}/${team.id}`, copy, { observe: 'response' })\r\n            .pipe(map((res: TeamResponse) => TeamService.convertTeamResponseDatesFromServer(res)));\r\n    }\r\n\r\n    /**\r\n     * Get a team belonging to a given exercise\r\n     * @param {Exercise} exercise - Exercise to search through\r\n     * @param {number} teamId - Team to search for\r\n     */\r\n    find(exercise: Exercise, teamId: number): Observable<TeamResponse> {\r\n        return this.http\r\n            .get<Team>(`${TeamService.resourceUrl(exercise.id!)}/${teamId}`, { observe: 'response' })\r\n            .pipe(map((res: TeamResponse) => TeamService.convertTeamResponseDatesFromServer(res)));\r\n    }\r\n\r\n    /**\r\n     * Get all teams belonging to a given exercise\r\n     * @param {number} exerciseId - Exercise to search through\r\n     * @param {number} teamOwnerId - Optional team owner id by which to filter exercises\r\n     */\r\n    findAllByExerciseId(exerciseId: number, teamOwnerId?: number): Observable<TeamArrayResponse> {\r\n        const options = createRequestOption(teamOwnerId ? { teamOwnerId } : {});\r\n        return this.http\r\n            .get<Team[]>(TeamService.resourceUrl(exerciseId), {\r\n                params: options,\r\n                observe: 'response',\r\n            })\r\n            .pipe(map((res: TeamArrayResponse) => TeamService.convertTeamArrayResponseDatesFromServer(res)));\r\n    }\r\n\r\n    /**\r\n     * Delete a team\r\n     * @param {Exercise} exercise - Exercise the team belongs to\r\n     * @param {number} teamId - Team to delete\r\n     */\r\n    delete(exercise: Exercise, teamId: number): Observable<HttpResponse<any>> {\r\n        return this.http.delete<any>(`${TeamService.resourceUrl(exercise.id!)}/${teamId}`, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Check if a given team short name exists in a course\r\n     * @param {Course} course - Course in which to search\r\n     * @param {string} shortName - Short name to search for\r\n     */\r\n    existsByShortName(course: Course, shortName: string): Observable<HttpResponse<boolean>> {\r\n        return this.http.get<boolean>(`api/exercise/courses/${course.id}/teams/exists?shortName=${shortName}`, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Find the team of a login/name in a given exercise and course\r\n     * @param {Course} course - Course to search in\r\n     * @param {Exercise} exercise - Exercise to search in\r\n     * @param {string} loginOrName - Login/Name to search for\r\n     */\r\n    searchInCourseForExerciseTeam(course: Course, exercise: Exercise, loginOrName: string): Observable<HttpResponse<TeamSearchUser[]>> {\r\n        const url = `api/exercise/courses/${course.id}/exercises/${exercise.id}/team-search-users?loginOrName=${loginOrName}`;\r\n        return this.http.get<TeamSearchUser[]>(url, { observe: 'response' });\r\n    }\r\n\r\n    /**\r\n     * Import the teams of an existing source exercise\r\n     * @param {Exercise} exercise - Exercise the teams should be imported into\r\n     * @param {Team[]} teams - Teams that should be imported into the exercise\r\n     */\r\n    importTeams(exercise: Exercise, teams: Team[], importStrategyType: TeamImportStrategyType) {\r\n        const copy = teams.map((team) => TeamService.convertTeamDatesFromClient(team));\r\n        return this.http.put<Team[]>(`${TeamService.resourceUrl(exercise.id!)}/import-from-list?importStrategyType=${importStrategyType}`, copy, {\r\n            observe: 'response',\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Import the teams of an existing source exercise\r\n     * @param {Exercise} exercise - Exercise the teams should be imported into\r\n     * @param {Exercise} sourceExercise - Exercise the teams should be imported from\r\n     * @param {TeamImportStrategyType} importStrategyType - Strategy to use for the import\r\n     */\r\n    importTeamsFromSourceExercise(exercise: Exercise, sourceExercise: Exercise, importStrategyType: TeamImportStrategyType) {\r\n        return this.http.put<Team[]>(\r\n            `${TeamService.resourceUrl(exercise.id!)}/import-from-exercise/${sourceExercise.id}?importStrategyType=${importStrategyType}`,\r\n            {},\r\n            { observe: 'response' },\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Finds a course with all its team exercises and participations in which the given team exists\r\n     * @param {Course} course - Course which to find\r\n     * @param {Team} team - Team for which to find exercises and participations (by team short name)\r\n     */\r\n    // TODO: Move this method to the CourseManagementService and delete the only here used duplicated setAccessRightsCourseEntityResponseType() helper method\r\n    findCourseWithExercisesAndParticipationsForTeam(course: Course, team: Team): Observable<HttpResponse<Course>> {\r\n        return this.http\r\n            .get<Course>(`api/exercise/courses/${course.id}/teams/${team.shortName}/with-exercises-and-participations`, { observe: 'response' })\r\n            .pipe(map((res: EntityResponseType) => this.setAccessRightsCourseEntityResponseType(res)));\r\n    }\r\n\r\n    /**\r\n     * Exports given teams into json file\r\n     * @param teams Teams to add to export file\r\n     */\r\n    exportTeams(teams: Team[]) {\r\n        // Make list of teams which we need to export,\r\n        const exportedTeams: StudentWithTeam[] = [];\r\n        teams!.forEach((team) => {\r\n            if (team.students) {\r\n                team.students.forEach((student) => {\r\n                    const exportStudent = {\r\n                        teamName: team.name ?? '',\r\n                        username: student.login ?? '',\r\n                    } as StudentWithTeam;\r\n                    if (student.firstName) {\r\n                        exportStudent.firstName = student.firstName;\r\n                    }\r\n                    if (student.lastName) {\r\n                        exportStudent.lastName = student.lastName;\r\n                    }\r\n                    if (student.visibleRegistrationNumber) {\r\n                        exportStudent.registrationNumber = student.visibleRegistrationNumber;\r\n                    }\r\n                    exportedTeams.push(exportStudent);\r\n                });\r\n            }\r\n        });\r\n        // Make blob from the list of teams and download the file,\r\n        const teamJson = JSON.stringify(exportedTeams);\r\n        const blob = new Blob([teamJson], { type: 'application/json' });\r\n        downloadFile(blob, 'teams.json');\r\n    }\r\n\r\n    /**\r\n     * Returns a promise of an observable that emits team assignment updates\r\n     *\r\n     * 1. If there is already an update stream, return it\r\n     * 2. If there is no update stream yet, wait for the user to log in and create a new update stream\r\n     */\r\n    get teamAssignmentUpdates(): Promise<Observable<TeamAssignmentPayload>> {\r\n        return new Promise((resolve) => {\r\n            if (this.teamAssignmentUpdates$) {\r\n                return resolve(this.teamAssignmentUpdates$);\r\n            }\r\n            this.authenticationStateSubscriber = this.accountService.getAuthenticationState().subscribe((user: User | undefined) => {\r\n                setTimeout(() => {\r\n                    if (user) {\r\n                        this.teamAssignmentUpdatesResolver = () => resolve(this.newTeamAssignmentUpdates$);\r\n                        this.websocketStatusSubscription = this.websocketService.connectionState\r\n                            .pipe(filter((status) => status.connected))\r\n                            .subscribe(() => this.teamAssignmentUpdatesResolver());\r\n                    } else {\r\n                        this.websocketService.unsubscribe(teamAssignmentUpdatesWebsocketTopic);\r\n                        this.websocketStatusSubscription?.unsubscribe();\r\n                        this.teamAssignmentUpdates$ = null;\r\n                        this.authenticationStateSubscriber.unsubscribe();\r\n                    }\r\n                }, 500);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Subscribes to the team assignment updates websocket topic and stores the stream in teamAssignmentUpdates$\r\n     */\r\n    private get newTeamAssignmentUpdates$(): Observable<TeamAssignmentPayload> {\r\n        this.websocketService.subscribe(teamAssignmentUpdatesWebsocketTopic);\r\n        this.teamAssignmentUpdates$ = this.websocketService.receive(teamAssignmentUpdatesWebsocketTopic).pipe(shareReplay(16));\r\n        return this.teamAssignmentUpdates$;\r\n    }\r\n\r\n    /**\r\n     * Helper methods for date conversion from server and client\r\n     */\r\n    private static convertTeamArrayResponseDatesFromServer(res: TeamArrayResponse): TeamArrayResponse {\r\n        if (res.body) {\r\n            res.body.map((team: Team) => this.convertTeamDatesFromServer(team));\r\n        }\r\n        return res;\r\n    }\r\n\r\n    private static convertTeamResponseDatesFromServer(res: TeamResponse): TeamResponse {\r\n        if (res.body) {\r\n            res.body.createdDate = convertDateFromServer(res.body.createdDate);\r\n            res.body.lastModifiedDate = convertDateFromServer(res.body.lastModifiedDate);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    private static convertTeamDatesFromServer(team: Team): Team {\r\n        team.createdDate = convertDateFromServer(team.createdDate);\r\n        team.lastModifiedDate = convertDateFromServer(team.lastModifiedDate);\r\n        return team;\r\n    }\r\n\r\n    private static convertTeamDatesFromClient(team: Team): Team {\r\n        return Object.assign({}, team, {\r\n            createdDate: convertDateFromClient(team.createdDate),\r\n            lastModifiedDate: convertDateFromClient(team.lastModifiedDate),\r\n        });\r\n    }\r\n\r\n    private setAccessRightsCourseEntityResponseType(res: EntityResponseType): EntityResponseType {\r\n        if (res.body) {\r\n            this.accountService.setAccessRightsForCourse(res.body);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["teamAssignmentUpdatesWebsocketTopic", "TeamService", "http", "inject", "HttpClient", "websocketService", "WebsocketService", "accountService", "AccountService", "teamAssignmentUpdates$", "teamAssignmentUpdatesResolver", "authenticationStateSubscriber", "websocketStatusSubscription", "ngOnDestroy", "unsubscribe", "resourceUrl", "exerciseId", "create", "exercise", "team", "copy", "convertTeamDatesFromClient", "post", "id", "observe", "pipe", "map", "res", "convertTeamResponseDatesFromServer", "update", "put", "find", "teamId", "get", "findAllByExerciseId", "teamOwnerId", "options", "createRequestOption", "params", "convertTeamArrayResponseDatesFromServer", "delete", "existsByShortName", "course", "shortName", "searchInCourseForExerciseTeam", "loginOrName", "url", "importTeams", "teams", "importStrategyType", "importTeamsFromSourceExercise", "sourceExercise", "findCourseWithExercisesAndParticipationsForTeam", "setAccessRightsCourseEntityResponseType", "exportTeams", "exportedTeams", "forEach", "students", "student", "exportStudent", "teamName", "name", "username", "login", "firstName", "lastName", "visibleRegistrationNumber", "registrationNumber", "push", "teamJson", "JSON", "stringify", "blob", "Blob", "type", "downloadFile", "teamAssignmentUpdates", "Promise", "resolve", "getAuthenticationState", "subscribe", "user", "setTimeout", "newTeamAssignmentUpdates$", "connectionState", "filter", "status", "connected", "receive", "shareReplay", "body", "convertTeamDatesFromServer", "createdDate", "convertDateFromServer", "lastModifiedDate", "Object", "assign", "convertDateFromClient", "setAccessRightsForCourse", "factory", "\u0275fac", "providedIn"]
}
