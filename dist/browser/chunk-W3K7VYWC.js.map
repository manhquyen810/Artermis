{
  "version": 3,
  "sources": ["src/main/webapp/app/exercises/programming/participate/programming-submission.service.ts"],
  "sourcesContent": ["import { Injectable, OnDestroy, inject } from '@angular/core';\r\nimport { HttpClient, HttpParams, HttpResponse } from '@angular/common/http';\r\nimport { BehaviorSubject, Observable, Subject, Subscription, from, merge, of, timer } from 'rxjs';\r\nimport { catchError, distinctUntilChanged, filter, map, reduce, switchMap, tap } from 'rxjs/operators';\r\nimport { ParticipationWebsocketService } from 'app/overview/participation-websocket.service';\r\nimport { Result } from 'app/entities/result.model';\r\nimport { createRequestOption } from 'app/shared/util/request.util';\r\nimport { WebsocketService } from 'app/core/websocket/websocket.service';\r\nimport { Exercise, ExerciseType } from 'app/entities/exercise.model';\r\nimport { ProgrammingSubmission } from 'app/entities/programming/programming-submission.model';\r\nimport { SubmissionType, getLatestSubmissionResult, setLatestSubmissionResult } from 'app/entities/submission.model';\r\nimport { ProgrammingExerciseStudentParticipation } from 'app/entities/participation/programming-exercise-student-participation.model';\r\nimport { findLatestResult } from 'app/shared/util/utils';\r\nimport { ProgrammingExerciseParticipationService } from 'app/exercises/programming/manage/services/programming-exercise-participation.service';\r\nimport { ParticipationService } from 'app/exercises/shared/participation/participation.service';\r\nimport { SubmissionProcessingDTO } from 'app/entities/programming/submission-processing-dto';\r\nimport dayjs from 'dayjs/esm';\r\nimport { ProfileService } from 'app/shared/layouts/profiles/profile.service';\r\nimport { PROFILE_LOCALCI } from 'app/app.constants';\r\n\r\nexport enum ProgrammingSubmissionState {\r\n    // The last submission of participation has a result.\r\n    HAS_NO_PENDING_SUBMISSION = 'HAS_NO_PENDING_SUBMISSION',\r\n    // The submission was created on the server, we assume that the build is running within an expected time frame.\r\n    IS_BUILDING_PENDING_SUBMISSION = 'IS_BUILDING_PENDING_SUBMISSION',\r\n    // A failed submission is a pending submission that has not received a result within an expected time frame.\r\n    HAS_FAILED_SUBMISSION = 'HAS_FAILED_SUBMISSION',\r\n    // The submission is queued and will be built soon.\r\n    IS_QUEUED = 'IS_QUEUED',\r\n}\r\n\r\nexport type ProgrammingSubmissionStateObj = {\r\n    participationId: number;\r\n    submissionState: ProgrammingSubmissionState;\r\n    submission?: ProgrammingSubmission;\r\n    buildTimingInfo?: BuildTimingInfo;\r\n};\r\n\r\nexport type BuildTimingInfo = {\r\n    estimatedCompletionDate?: dayjs.Dayjs;\r\n    buildStartDate?: dayjs.Dayjs;\r\n};\r\n\r\nexport type ExerciseSubmissionState = { [participationId: number]: ProgrammingSubmissionStateObj };\r\n\r\ntype ProgrammingSubmissionError = { error: string; participationId: number };\r\n\r\n/**\r\n * Type guard for checking if the submission received through the websocket is an error object.\r\n * @param toBeDetermined either a ProgrammingSubmission or a ProgrammingSubmissionError.\r\n */\r\nconst checkIfSubmissionIsError = (toBeDetermined: ProgrammingSubmission | ProgrammingSubmissionError): toBeDetermined is ProgrammingSubmissionError => {\r\n    return !!(toBeDetermined as ProgrammingSubmissionError).error;\r\n};\r\n\r\nexport interface IProgrammingSubmissionService {\r\n    getLatestPendingSubmissionByParticipationId: (participationId: number, exerciseId: number, personal: boolean) => Observable<ProgrammingSubmissionStateObj>;\r\n    getSubmissionStateOfExercise: (exerciseId: number) => Observable<ExerciseSubmissionState>;\r\n    getResultEtaInMs: () => Observable<number>;\r\n    triggerBuild: (participationId: number) => Observable<any>;\r\n    triggerInstructorBuildForAllParticipationsOfExercise: (exerciseId: number) => Observable<void>;\r\n    triggerInstructorBuildForParticipationsOfExercise: (exerciseId: number, participationIds: number[]) => Observable<void>;\r\n    unsubscribeAllWebsocketTopics: (exercise: Exercise) => void;\r\n    unsubscribeForLatestSubmissionOfParticipation: (participationId: number) => void;\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ProgrammingSubmissionService implements IProgrammingSubmissionService, OnDestroy {\r\n    private websocketService = inject(WebsocketService);\r\n    private http = inject(HttpClient);\r\n    private participationWebsocketService = inject(ParticipationWebsocketService);\r\n    private participationService = inject(ProgrammingExerciseParticipationService);\r\n    private profileService = inject(ProfileService);\r\n\r\n    public SUBMISSION_RESOURCE_URL = 'api/programming/programming-submissions/';\r\n    public PROGRAMMING_EXERCISE_RESOURCE_URL = 'api/programming/programming-exercises/';\r\n    // Default value: 2 minutes.\r\n    private DEFAULT_EXPECTED_RESULT_ETA = 2 * 60 * 1000;\r\n    // Default value: 60 seconds.\r\n    private DEFAULT_EXPECTED_QUEUE_ESTIMATE = 60 * 1000;\r\n    private SUBMISSION_TEMPLATE_TOPIC = '/topic/exercise/%exerciseId%/newSubmissions';\r\n\r\n    private SUBMISSION_PROCESSING_TEMPLATE_TOPIC = '/topic/exercise/%exerciseId%/submissionProcessing';\r\n\r\n    private resultSubscriptions: { [participationId: number]: Subscription } = {};\r\n    // participationId -> topic\r\n    private submissionTopicsSubscribed = new Map<number, string>();\r\n    // participationId -> topic\r\n    private submissionProcessingTopicsSubscribed = new Map<number, string>();\r\n\r\n    // participationId -> exerciseId\r\n    private participationIdToExerciseId = new Map<number, number>();\r\n\r\n    // undefined describes the case when there is not a pending submission, undefined is used for the setup process and will not be emitted to subscribers.\r\n    private submissionSubjects: { [participationId: number]: BehaviorSubject<ProgrammingSubmissionStateObj | undefined> } = {};\r\n    // exerciseId -> ExerciseSubmissionState\r\n    private exerciseBuildStateSubjects = new Map<number, BehaviorSubject<ExerciseSubmissionState | undefined>>();\r\n    // participationId -> Subject\r\n    private resultTimerSubjects = new Map<number, Subject<undefined>>();\r\n    private resultTimerSubscriptions: { [participationId: number]: Subscription } = {};\r\n    private resultEtaSubject = new BehaviorSubject<number>(this.DEFAULT_EXPECTED_RESULT_ETA);\r\n\r\n    private queueEstimateTimerSubscriptions: { [participationId: number]: Subscription } = {};\r\n\r\n    private exerciseBuildStateValue: { [exerciseId: number]: ExerciseSubmissionState } = {};\r\n    private currentExpectedResultETA = this.DEFAULT_EXPECTED_RESULT_ETA;\r\n    private currentExpectedQueueEstimate = this.DEFAULT_EXPECTED_QUEUE_ESTIMATE;\r\n\r\n    private startedProcessingCache: Map<string, BuildTimingInfo> = new Map<string, BuildTimingInfo>();\r\n    private isLocalCIProfile?: boolean = undefined;\r\n    private profileServiceSubscription: Subscription;\r\n\r\n    constructor() {\r\n        this.profileServiceSubscription = this.profileService.getProfileInfo().subscribe((profileInfo) => {\r\n            this.setLocalCIProfile(!!profileInfo?.activeProfiles.includes(PROFILE_LOCALCI));\r\n        });\r\n    }\r\n\r\n    ngOnDestroy(): void {\r\n        Object.values(this.resultSubscriptions).forEach((sub) => sub.unsubscribe());\r\n        Object.values(this.resultTimerSubscriptions).forEach((sub) => sub.unsubscribe());\r\n        Object.values(this.queueEstimateTimerSubscriptions).forEach((sub) => sub.unsubscribe());\r\n        this.submissionTopicsSubscribed.forEach((topic) => this.websocketService.unsubscribe(topic));\r\n        this.submissionProcessingTopicsSubscribed.forEach((topic) => this.websocketService.unsubscribe(topic));\r\n        this.profileServiceSubscription.unsubscribe();\r\n    }\r\n\r\n    get exerciseBuildState() {\r\n        return this.exerciseBuildStateValue;\r\n    }\r\n\r\n    set exerciseBuildState(exerciseBuildState: { [exerciseId: number]: ExerciseSubmissionState }) {\r\n        this.exerciseBuildStateValue = exerciseBuildState;\r\n        this.updateResultEta();\r\n    }\r\n\r\n    /**\r\n     * Based on the number of building submissions, calculate the result eta.\r\n     *\r\n     */\r\n    private updateResultEta() {\r\n        const buildingSubmissionCount = Object.values(this.exerciseBuildStateValue).reduce((acc, exerciseSubmissionState) => {\r\n            const buildingSubmissionsOfExercise = exerciseSubmissionState\r\n                ? Object.values(exerciseSubmissionState).filter(({ submissionState }) => submissionState === ProgrammingSubmissionState.IS_BUILDING_PENDING_SUBMISSION).length\r\n                : 0;\r\n            return acc + buildingSubmissionsOfExercise;\r\n        }, 0);\r\n\r\n        // For every 100 submissions, we increase the expected time by 1 minute.\r\n        this.currentExpectedResultETA = this.DEFAULT_EXPECTED_RESULT_ETA + Math.floor(buildingSubmissionCount / 100) * 1000 * 60;\r\n        this.resultEtaSubject?.next(this.currentExpectedResultETA);\r\n    }\r\n\r\n    /**\r\n     * Fetch the latest pending submission for a participation, which means:\r\n     * - Submission is the newest one (by submissionDate)\r\n     * - Submission does not have a result (yet)\r\n     * - Submission is not older than DEFAULT_EXPECTED_RESULT_ETA (in this case it could be that never a result will come due to an error)\r\n     *\r\n     * This method is private on purpose as subscribers should not try to load initial data!\r\n     * A separate initial fetch is not necessary as this service takes care of it and provides a BehaviorSubject.\r\n     *\r\n     * @param participationId\r\n     */\r\n    private fetchLatestPendingSubmissionByParticipationId(participationId: number): Observable<ProgrammingSubmission | undefined> {\r\n        return this.http\r\n            .get<ProgrammingSubmission>('api/programming/programming-exercise-participations/' + participationId + '/latest-pending-submission')\r\n            .pipe(catchError(() => of(undefined)));\r\n    }\r\n\r\n    /**\r\n     * Fetch the latest pending submission for all participations of a given exercise.\r\n     * Returns an empty array if the api request fails.\r\n     *\r\n     * This method is private on purpose as subscribers should not try to load initial data!\r\n     * A separate initial fetch is not necessary as this service takes care of it and provides a BehaviorSubject.\r\n     *\r\n     * @param exerciseId of programming exercise.\r\n     */\r\n    private fetchLatestPendingSubmissionsByExerciseId(exerciseId: number): Observable<{ [participationId: number]: ProgrammingSubmission }> {\r\n        return this.http\r\n            .get<{ [participationId: number]: ProgrammingSubmission }>(`api/programming/programming-exercises/${exerciseId}/latest-pending-submissions`)\r\n            .pipe(catchError(() => of([])));\r\n    }\r\n\r\n    public fetchQueueReleaseDateEstimationByParticipationId(participationId: number): Observable<dayjs.Dayjs | undefined> {\r\n        return this.http.get<dayjs.Dayjs>('api/programming/queued-jobs/queue-duration-estimation', { params: { participationId } }).pipe(catchError(() => of(undefined)));\r\n    }\r\n\r\n    /**\r\n     * Start a timer after which the timer subject will notify the corresponding subject.\r\n     * Side effect: Timer will also emit an alert when the time runs out as it means here that no result came for a submission.\r\n     *\r\n     * @param participationId\r\n     * @param time\r\n     */\r\n    private startResultWaitingTimer(participationId: number, time = this.currentExpectedResultETA) {\r\n        this.resetResultWaitingTimer(participationId);\r\n        this.resultTimerSubscriptions[participationId] = timer(time)\r\n            .pipe(\r\n                tap(() => {\r\n                    const resultTimerSubject = this.resultTimerSubjects.get(participationId);\r\n                    if (resultTimerSubject) {\r\n                        resultTimerSubject.next(undefined);\r\n                    }\r\n                }),\r\n            )\r\n            .subscribe();\r\n    }\r\n\r\n    private resetResultWaitingTimer(participationId: number) {\r\n        if (this.resultTimerSubscriptions[participationId]) {\r\n            this.resultTimerSubscriptions[participationId].unsubscribe();\r\n        }\r\n    }\r\n\r\n    private startQueueEstimateTimer(participationId: number, exerciseId: number, submission: ProgrammingSubmission, time = this.currentExpectedQueueEstimate) {\r\n        this.resetQueueEstimateTimer(participationId);\r\n        this.queueEstimateTimerSubscriptions[participationId] = timer(time).subscribe(() => {\r\n            const remainingTime = this.getExpectedRemainingTimeForBuild(submission);\r\n            if (remainingTime > 0) {\r\n                this.emitBuildingSubmission(participationId, exerciseId, submission);\r\n                this.startResultWaitingTimer(participationId, remainingTime);\r\n            } else {\r\n                this.emitFailedSubmission(participationId, exerciseId);\r\n            }\r\n            this.resetQueueEstimateTimer(participationId);\r\n        });\r\n    }\r\n\r\n    private resetQueueEstimateTimer(participationId: number) {\r\n        this.queueEstimateTimerSubscriptions[participationId]?.unsubscribe();\r\n    }\r\n\r\n    /**\r\n     * Set up a submission subscription for the latest pending submission if not yet existing.\r\n     *\r\n     * @param participationId that is connected to the submission.\r\n     * @param exerciseId that is connected to the participation.\r\n     * @param personal whether the current user is a participant in the participation.\r\n     */\r\n    private setupWebsocketSubscriptionForLatestPendingSubmission(participationId: number, exerciseId: number, personal: boolean): void {\r\n        if (!this.submissionTopicsSubscribed.get(participationId)) {\r\n            let newSubmissionTopic: string;\r\n            if (personal) {\r\n                newSubmissionTopic = '/user/topic/newSubmissions';\r\n            } else {\r\n                newSubmissionTopic = this.SUBMISSION_TEMPLATE_TOPIC.replace('%exerciseId%', exerciseId.toString());\r\n            }\r\n\r\n            this.resultTimerSubjects.set(participationId, new Subject<undefined>());\r\n            this.participationIdToExerciseId.set(participationId, exerciseId);\r\n\r\n            // Only subscribe if not subscription to same topic exists (e.g. from different participation)\r\n            if (!Array.from(this.submissionTopicsSubscribed.values()).includes(newSubmissionTopic)) {\r\n                this.websocketService.subscribe(newSubmissionTopic);\r\n                this.websocketService\r\n                    .receive(newSubmissionTopic)\r\n                    .pipe(\r\n                        tap((submission: ProgrammingSubmission | ProgrammingSubmissionError) => {\r\n                            if (checkIfSubmissionIsError(submission)) {\r\n                                const programmingSubmissionError = submission as ProgrammingSubmissionError;\r\n                                this.emitFailedSubmission(programmingSubmissionError.participationId, exerciseId);\r\n                                return;\r\n                            }\r\n                            const programmingSubmission = submission as ProgrammingSubmission;\r\n                            const submissionParticipationId = programmingSubmission.participation!.id!;\r\n                            let buildTimingInfo: BuildTimingInfo | undefined = undefined;\r\n\r\n                            if (this.isLocalCIProfile) {\r\n                                const isSubmissionQueued = this.handleQueuedProgrammingSubmissions(programmingSubmission, submissionParticipationId);\r\n                                if (isSubmissionQueued) {\r\n                                    return;\r\n                                }\r\n\r\n                                buildTimingInfo = this.startedProcessingCache.get(programmingSubmission.commitHash!);\r\n                                this.removeSubmissionFromProcessingCache(programmingSubmission.commitHash!);\r\n                            }\r\n\r\n                            this.emitBuildingSubmission(submissionParticipationId, this.participationIdToExerciseId.get(submissionParticipationId)!, submission, buildTimingInfo);\r\n                            this.startResultWaitingTimer(submissionParticipationId);\r\n                        }),\r\n                    )\r\n                    .subscribe();\r\n            }\r\n            this.submissionTopicsSubscribed.set(participationId, newSubmissionTopic);\r\n        }\r\n    }\r\n\r\n    private handleQueuedProgrammingSubmissions(programmingSubmission: ProgrammingSubmission, submissionParticipationId: number) {\r\n        let isSubmissionQueued = false;\r\n        if (!programmingSubmission.isProcessing && !this.didSubmissionStartProcessing(programmingSubmission.commitHash!)) {\r\n            const queueRemainingTime = this.getExpectedRemainingTimeForQueue(programmingSubmission);\r\n            if (queueRemainingTime > 0) {\r\n                this.emitQueuedSubmission(submissionParticipationId, this.participationIdToExerciseId.get(submissionParticipationId)!, programmingSubmission);\r\n                this.startQueueEstimateTimer(\r\n                    submissionParticipationId,\r\n                    this.participationIdToExerciseId.get(submissionParticipationId)!,\r\n                    programmingSubmission,\r\n                    queueRemainingTime,\r\n                );\r\n                isSubmissionQueued = true;\r\n            }\r\n        }\r\n        return isSubmissionQueued;\r\n    }\r\n\r\n    private setupWebsocketSubscriptionForSubmissionProcessing(participationId: number, exerciseId: number, personal: boolean): void {\r\n        if (!this.submissionProcessingTopicsSubscribed.get(participationId)) {\r\n            let newSubmissionTopic: string;\r\n            if (personal) {\r\n                newSubmissionTopic = '/user/topic/submissionProcessing';\r\n            } else {\r\n                newSubmissionTopic = this.SUBMISSION_PROCESSING_TEMPLATE_TOPIC.replace('%exerciseId%', exerciseId.toString());\r\n            }\r\n\r\n            // Only subscribe if not subscription to same topic exists (e.g. from different participation)\r\n            const subscriptionOnSameTopicExists = Array.from(this.submissionProcessingTopicsSubscribed.values()).includes(newSubmissionTopic);\r\n            if (!subscriptionOnSameTopicExists) {\r\n                this.websocketService.subscribe(newSubmissionTopic);\r\n                this.websocketService\r\n                    .receive(newSubmissionTopic)\r\n                    .pipe(\r\n                        tap((submissionProcessing: SubmissionProcessingDTO) => {\r\n                            const submissionParticipationId = submissionProcessing.participationId!;\r\n                            const exerciseId = this.participationIdToExerciseId.get(submissionParticipationId)!;\r\n\r\n                            if (!this.isNewestSubmission(submissionProcessing, exerciseId, submissionParticipationId)) {\r\n                                return;\r\n                            }\r\n\r\n                            const programmingSubmission = this.getSubmissionByCommitHash(submissionProcessing);\r\n                            // It is possible that the submission started processing before it got saved to the database and the message was sent to the client.\r\n                            // In this case, we cache that the submission started processing and do not emit the building state.\r\n                            // When the submission message arrives, we check if the submission is already in the cache.\r\n                            if (!programmingSubmission) {\r\n                                this.startedProcessingCache.set(submissionProcessing.commitHash!, {\r\n                                    estimatedCompletionDate: submissionProcessing.estimatedCompletionDate,\r\n                                    buildStartDate: submissionProcessing.buildStartDate,\r\n                                });\r\n                                return;\r\n                            }\r\n                            programmingSubmission.isProcessing = true;\r\n\r\n                            const buildTimingInfo = {\r\n                                estimatedCompletionDate: submissionProcessing.estimatedCompletionDate,\r\n                                buildStartDate: submissionProcessing.buildStartDate,\r\n                            };\r\n                            this.removeSubmissionFromProcessingCache(programmingSubmission.commitHash!);\r\n                            this.resetQueueEstimateTimer(submissionParticipationId);\r\n                            this.emitBuildingSubmission(submissionParticipationId, exerciseId, programmingSubmission, buildTimingInfo);\r\n\r\n                            this.startResultWaitingTimer(submissionParticipationId);\r\n                        }),\r\n                    )\r\n                    .subscribe();\r\n            }\r\n            this.submissionProcessingTopicsSubscribed.set(participationId, newSubmissionTopic);\r\n        }\r\n    }\r\n\r\n    private isNewestSubmission(newSubmission: SubmissionProcessingDTO, exerciseId: number, participationId: number): boolean {\r\n        const currentSubmission = this.exerciseBuildState[exerciseId]?.[participationId]?.submission;\r\n\r\n        if (!currentSubmission?.submissionDate) return true;\r\n        if (!newSubmission?.submissionDate) return false;\r\n\r\n        return dayjs(newSubmission.submissionDate).isSameOrAfter(dayjs(currentSubmission.submissionDate));\r\n    }\r\n\r\n    private getSubmissionByCommitHash(submissionProcessing: SubmissionProcessingDTO): ProgrammingSubmission | undefined {\r\n        if (submissionProcessing.exerciseId && submissionProcessing.participationId && submissionProcessing.commitHash) {\r\n            const submission = this.exerciseBuildState[submissionProcessing.exerciseId]?.[submissionProcessing.participationId]?.submission;\r\n            if (submission && submission.commitHash === submissionProcessing.commitHash) {\r\n                return submission;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Waits for a new result to come in while a pending submission exists.\r\n     * Will stop waiting after the timer subject has emitted a value.\r\n     *\r\n     * @param participationId that is connected to the result.\r\n     * @param exerciseId that is connected to the participation.\r\n     * @param personal whether the current user is a participant in the participation.\r\n     */\r\n    private subscribeForNewResult(participationId: number, exerciseId: number, personal: boolean) {\r\n        if (this.resultSubscriptions[participationId]) {\r\n            return;\r\n        }\r\n        const resultObservable = this.participationWebsocketService.subscribeForLatestResultOfParticipation(participationId, personal, exerciseId).pipe(\r\n            // Make sure that the incoming result belongs the latest submission!\r\n            filter((result: Result | undefined) => this.isResultOfLatestSubmission(result, exerciseId, participationId)),\r\n            distinctUntilChanged(),\r\n            tap(() => {\r\n                // This is the normal case - the last pending submission received a result, so we emit undefined as the message that there is not a pending submission anymore.\r\n                this.emitNoPendingSubmission(participationId, exerciseId);\r\n            }),\r\n        );\r\n\r\n        // If the timer runs out and the fallback fails we will emit an error as we assume the result is lost\r\n        const timerObservable = this.resultTimerSubjects.get(participationId)!.pipe(\r\n            // Fallback: Try to fetch the latest result from the server as the websocket connection might have failed\r\n            switchMap(() => this.participationService.getLatestResultWithFeedback(participationId, true)),\r\n            tap((result: Result) => {\r\n                if (this.isResultOfLatestSubmission(result, exerciseId, participationId)) {\r\n                    // Notify all result subscribers with the latest result if it belongs to the latest submission\r\n                    // This will also trigger the resultObservable above, which emits that the submission is no longer pending\r\n                    this.participationWebsocketService.notifyAllResultSubscribers({ ...result, participation: { id: participationId } });\r\n                } else {\r\n                    // Otherwise, notify that submission subscribers that the result could not be retrieved\r\n                    this.emitFailedSubmission(participationId, exerciseId);\r\n                }\r\n            }),\r\n            catchError(() => {\r\n                this.emitFailedSubmission(participationId, exerciseId);\r\n                return of(undefined);\r\n            }),\r\n        );\r\n\r\n        this.resultSubscriptions[participationId] = merge(timerObservable, resultObservable)\r\n            .pipe(\r\n                filter(() => !!this.exerciseBuildState[exerciseId][participationId]),\r\n                tap(() => {\r\n                    // We reset the timer when a new result came through OR the timer ran out. The stream will then be inactive until the next submission comes in.\r\n                    this.resetQueueEstimateTimer(participationId);\r\n                    this.resetResultWaitingTimer(participationId);\r\n                }),\r\n            )\r\n            .subscribe();\r\n    }\r\n\r\n    private isResultOfLatestSubmission(result: Result | undefined, exerciseId: number, participationId: number): boolean {\r\n        if (!result || !result.submission) {\r\n            return false;\r\n        }\r\n        const { submission } = this.exerciseBuildState[exerciseId][participationId];\r\n        return !!submission && result.submission.id === submission.id;\r\n    }\r\n\r\n    private emitNoPendingSubmission(participationId: number, exerciseId: number) {\r\n        const newSubmissionState = { participationId, submissionState: ProgrammingSubmissionState.HAS_NO_PENDING_SUBMISSION, submission: undefined };\r\n        this.notifySubscribers(participationId, exerciseId, newSubmissionState);\r\n    }\r\n\r\n    private emitBuildingSubmission(participationId: number, exerciseId: number, submission: ProgrammingSubmission, buildTimingInfo?: BuildTimingInfo) {\r\n        const newSubmissionState = { participationId, submissionState: ProgrammingSubmissionState.IS_BUILDING_PENDING_SUBMISSION, submission, buildTimingInfo };\r\n        this.notifySubscribers(participationId, exerciseId, newSubmissionState);\r\n    }\r\n\r\n    private emitQueuedSubmission(participationId: number, exerciseId: number, submission: ProgrammingSubmission) {\r\n        const newSubmissionState = { participationId, submissionState: ProgrammingSubmissionState.IS_QUEUED, submission };\r\n        this.notifySubscribers(participationId, exerciseId, newSubmissionState);\r\n    }\r\n\r\n    private emitFailedSubmission(participationId: number, exerciseId: number) {\r\n        const submissionStateObj = this.exerciseBuildState[exerciseId] && this.exerciseBuildState[exerciseId][participationId];\r\n        const newSubmissionState = {\r\n            participationId,\r\n            submissionState: ProgrammingSubmissionState.HAS_FAILED_SUBMISSION,\r\n            submission: submissionStateObj ? submissionStateObj.submission : undefined,\r\n        };\r\n        this.notifySubscribers(participationId, exerciseId, newSubmissionState);\r\n    }\r\n\r\n    /**\r\n     * Notifies both the exercise and participation specific subscribers about a new SubmissionState.\r\n     *\r\n     * @param participationId id of ProgrammingExerciseStudentParticipation\r\n     * @param exerciseId id of ProgrammingExercise\r\n     * @param newSubmissionState to inform subscribers about.\r\n     */\r\n    private notifySubscribers(participationId: number, exerciseId: number, newSubmissionState: ProgrammingSubmissionStateObj) {\r\n        // Inform participation subscribers.\r\n        const submissionSubject = this.submissionSubjects[participationId];\r\n        if (submissionSubject) {\r\n            submissionSubject.next(newSubmissionState);\r\n        }\r\n        // Inform exercise subscribers.\r\n        this.exerciseBuildState = { ...this.exerciseBuildState, [exerciseId]: { ...(this.exerciseBuildState[exerciseId] || {}), [participationId]: newSubmissionState } };\r\n        const exerciseBuildStateSubject = this.exerciseBuildStateSubjects.get(exerciseId);\r\n        if (exerciseBuildStateSubject) {\r\n            exerciseBuildStateSubject.next(this.exerciseBuildState[exerciseId]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check how much time is still left for the build.\r\n     *\r\n     * @param submission for which to check the passed build time.\r\n     * @return the expected rest time to wait for the build.\r\n     */\r\n    private getExpectedRemainingTimeForBuild(submission: ProgrammingSubmission): number {\r\n        return this.currentExpectedResultETA - (Date.now() - Date.parse(submission.submissionDate as any));\r\n    }\r\n\r\n    private getExpectedRemainingTimeForQueue(submission: ProgrammingSubmission): number {\r\n        return this.currentExpectedQueueEstimate - (Date.now() - Date.parse(submission.submissionDate as any));\r\n    }\r\n\r\n    /**\r\n     * Initialize the cache from outside the service.\r\n     *\r\n     * The service expects that:\r\n     * - Each exercise does only have one student participation for the given student.\r\n     *\r\n     * If the expectations are violated, the service might not work as intended anymore!\r\n     *\r\n     * @param exercises\r\n     * @param forceCacheOverride if true it will clear the current value in the cache for each participation of the exercises.\r\n     */\r\n    public initializeCacheForStudent(exercises?: Exercise[], forceCacheOverride = false) {\r\n        if (!exercises) {\r\n            return;\r\n        }\r\n        exercises\r\n            .filter((exercise) => {\r\n                // We only process programming exercises in this service.\r\n                if (exercise.type !== ExerciseType.PROGRAMMING) {\r\n                    return false;\r\n                }\r\n                // We can't process exercises without participations.\r\n                if (!exercise.studentParticipations || !exercise.studentParticipations.length) {\r\n                    return false;\r\n                }\r\n                // If we already have a value cached for the participation we don't override it.\r\n                if (!forceCacheOverride && !!this.submissionSubjects[exercise.studentParticipations![0].id!]) {\r\n                    return false;\r\n                }\r\n                // Without submissions, we can't determine if the latest submission is pending.\r\n                return !!exercise.studentParticipations[0].submissions && !!exercise.studentParticipations[0].submissions.length;\r\n            })\r\n            .forEach((exercise) => {\r\n                const participation = exercise.studentParticipations![0] as ProgrammingExerciseStudentParticipation;\r\n                const latestSubmission = participation.submissions!.reduce((current, next) => (current.id! > next.id! ? current : next)) as ProgrammingSubmission;\r\n                const latestResult = findLatestResult(participation.results);\r\n                const isPendingSubmission = !!latestSubmission && (!latestResult || (latestResult.submission && latestResult.submission.id !== latestSubmission.id));\r\n                // This needs to be done to clear the cache if exists and to prepare the subject for the later notification of the subscribers.\r\n                this.submissionSubjects[participation.id!] = new BehaviorSubject<ProgrammingSubmissionStateObj | undefined>(undefined);\r\n                this.processPendingSubmission(isPendingSubmission ? latestSubmission : undefined, participation.id!, exercise.id!, true).subscribe();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Subscribe for the latest pending submission for the given participation.\r\n     * A latest pending submission is characterized by the following properties:\r\n     * - Submission is the newest one (by submissionDate)\r\n     * - Submission does not have a result (yet)\r\n     * - Submission is not older than DEFAULT_EXPECTED_RESULT_ETA (in this case it could be that never a result will come due to an error)\r\n     *\r\n     * Will emit:\r\n     * - A submission if a last pending submission exists.\r\n     * - An undefined value when there is not a pending submission.\r\n     * - An undefined value when no result arrived in time for the submission.\r\n     *\r\n     * This method will execute a REST call to the server so that the subscriber will always receive the latest information from the server.\r\n     *\r\n     * @param participationId id of the ProgrammingExerciseStudentParticipation\r\n     * @param exerciseId id of ProgrammingExercise\r\n     * @param personal whether the current user is a participant in the participation.\r\n     * @param forceCacheOverride whether the cache should definitely be overridden, default is false\r\n     * @param fetchPending whether the latest pending submission should be fetched from the server\r\n     */\r\n    public getLatestPendingSubmissionByParticipationId(participationId: number, exerciseId: number, personal: boolean, forceCacheOverride = false, fetchPending = true) {\r\n        const subject = this.submissionSubjects[participationId];\r\n        if (!forceCacheOverride && subject) {\r\n            return subject.asObservable().pipe(filter((stateObj) => stateObj !== undefined)) as Observable<ProgrammingSubmissionStateObj>;\r\n        }\r\n        // If all submission states for the exercise are currently loaded, don't send a new rest request.\r\n        // Instead, wait for the exercise request to finish and return this result\r\n        const exercisePreloadingSubject = this.exerciseBuildStateSubjects.get(exerciseId);\r\n        if (exercisePreloadingSubject) {\r\n            return exercisePreloadingSubject.asObservable().pipe(\r\n                // remove initial undefined state\r\n                filter((states) => !!states),\r\n                switchMap((exerciseStates) => {\r\n                    const participationState = exerciseStates?.[participationId];\r\n                    if (participationState) {\r\n                        return of(participationState);\r\n                    }\r\n                    // Load the submission manually if it was not part of the exercise state\r\n                    return this.loadLatestPendingSubmissionByParticipationId(participationId, exerciseId, personal, fetchPending);\r\n                }),\r\n            );\r\n        }\r\n        return this.loadLatestPendingSubmissionByParticipationId(participationId, exerciseId, personal, fetchPending);\r\n    }\r\n\r\n    private loadLatestPendingSubmissionByParticipationId(participationId: number, exerciseId: number, personal: boolean, fetchPending: boolean) {\r\n        // The setup process is difficult, because it should not happen that multiple subscribers trigger the setup process at the same time.\r\n        // There the subject is returned before the REST call is made, but will emit its result as soon as it returns.\r\n        this.submissionSubjects[participationId] = new BehaviorSubject<ProgrammingSubmissionStateObj | undefined>(undefined);\r\n        if (fetchPending) {\r\n            this.fetchLatestPendingSubmissionByParticipationId(participationId)\r\n                .pipe(switchMap((submission) => this.processPendingSubmission(submission, participationId, exerciseId, personal)))\r\n                .subscribe();\r\n        } else {\r\n            // only process, but do not try to fetchPending the latest one, e.g. because it was already downloaded shortly before (example: exam start)\r\n            this.processPendingSubmission(undefined, participationId, exerciseId, personal).subscribe();\r\n        }\r\n        // We just remove the initial undefined from the pipe as it is only used to make the setup process easier.\r\n        return this.submissionSubjects[participationId].asObservable().pipe(filter((stateObj) => stateObj !== undefined)) as Observable<ProgrammingSubmissionStateObj>;\r\n    }\r\n\r\n    /**\r\n     * Will retrieve and cache all pending submissions for all student participations of given exercise.\r\n     * After calling this method, subscribers for single pending submissions will be able to use the cached submissions so that we don't execute a GET request to the server\r\n     * for every participation.\r\n     *\r\n     * Will emit once at the end so the subscriber knows that the loading & setup process is done.\r\n     * If the user is not an instructor, this method will not be able to retrieve any pending submission.\r\n     *\r\n     * This method will execute a REST call to the server so that the subscriber will always receive the latest information from the server.\r\n     *\r\n     * @param exerciseId id of programming exercise for which to retrieve all pending submissions.\r\n     */\r\n    public getSubmissionStateOfExercise(exerciseId: number): Observable<ExerciseSubmissionState> {\r\n        // We need to check if the submissions for the given exercise are already being fetched, otherwise the call would be done multiple times.\r\n        const preloadingSubject = this.exerciseBuildStateSubjects.get(exerciseId);\r\n        if (preloadingSubject) {\r\n            return preloadingSubject.asObservable().pipe(filter((val) => val !== undefined)) as Observable<ExerciseSubmissionState>;\r\n        }\r\n        this.exerciseBuildStateSubjects.set(exerciseId, new BehaviorSubject<ExerciseSubmissionState | undefined>(undefined));\r\n        this.fetchLatestPendingSubmissionsByExerciseId(exerciseId)\r\n            .pipe(\r\n                map(Object.entries),\r\n                map(this.mapParticipationIdToNumber),\r\n                switchMap((submissions: Array<[number, ProgrammingSubmission]>) => {\r\n                    if (!submissions.length) {\r\n                        // This needs to be done as from([]) would stop the stream.\r\n                        return of([]);\r\n                    }\r\n                    return from(submissions).pipe(\r\n                        switchMap(([participationId, submission]): Observable<ProgrammingSubmissionStateObj> => {\r\n                            this.submissionSubjects[participationId] = new BehaviorSubject<ProgrammingSubmissionStateObj | undefined>(undefined);\r\n                            return this.processPendingSubmission(submission, participationId, exerciseId, false);\r\n                        }),\r\n                    );\r\n                }),\r\n                reduce(this.mapToExerciseBuildState, {}),\r\n                catchError(() => of({})),\r\n            )\r\n            .subscribe((exerciseBuildState: ExerciseSubmissionState) => {\r\n                this.exerciseBuildState = { ...this.exerciseBuildState, [exerciseId]: exerciseBuildState };\r\n                this.exerciseBuildStateSubjects.get(exerciseId)?.next(exerciseBuildState);\r\n            });\r\n        return this.exerciseBuildStateSubjects\r\n            .get(exerciseId)!\r\n            .asObservable()\r\n            .pipe(filter((val) => val !== undefined)) as Observable<ExerciseSubmissionState>;\r\n    }\r\n\r\n    getResultEtaInMs() {\r\n        return this.resultEtaSubject.asObservable().pipe(distinctUntilChanged());\r\n    }\r\n\r\n    public triggerBuild(participationId: number, submissionType = SubmissionType.MANUAL) {\r\n        return this.http.post(this.SUBMISSION_RESOURCE_URL + participationId + `/trigger-build?submissionType=${submissionType}`, {});\r\n    }\r\n\r\n    public triggerFailedBuild(participationId: number, lastGraded: boolean) {\r\n        const params = new HttpParams().set('lastGraded', lastGraded.toString());\r\n        return this.http.post(this.SUBMISSION_RESOURCE_URL + participationId + '/trigger-failed-build', {}, { params, observe: 'response' });\r\n    }\r\n\r\n    public triggerInstructorBuildForAllParticipationsOfExercise(exerciseId: number) {\r\n        return this.http.post<void>(this.PROGRAMMING_EXERCISE_RESOURCE_URL + exerciseId + '/trigger-instructor-build-all', {});\r\n    }\r\n\r\n    public triggerInstructorBuildForParticipationsOfExercise(exerciseId: number, participationIds: number[]) {\r\n        return this.http.post<void>(this.PROGRAMMING_EXERCISE_RESOURCE_URL + exerciseId + '/trigger-instructor-build', participationIds);\r\n    }\r\n\r\n    /**\r\n     * Get the count of submission state type for exercise.\r\n     *\r\n     * @param exerciseId ProgrammingExercise\r\n     * @param state ProgrammingSubmissionState\r\n     */\r\n    public getSubmissionCountByType(exerciseId: number, state: ProgrammingSubmissionState) {\r\n        const exerciseBuildState = this.exerciseBuildState[exerciseId];\r\n        return Object.entries(exerciseBuildState)\r\n            .filter(([, buildState]) => {\r\n                const { submissionState } = buildState;\r\n                return submissionState === state;\r\n            })\r\n            .map(([participationId]) => parseInt(participationId, 10));\r\n    }\r\n\r\n    /**\r\n     * Cache a retrieved pending submission and set up the websocket connections and timer.\r\n     *\r\n     * @param submissionToBeProcessed to cache and use for the websocket subscriptions\r\n     * @param participationId that serves as an identifier for caching the submission.\r\n     * @param exerciseId of the given participationId.\r\n     * @param personal whether the current user is a participant in the participation.\r\n     */\r\n    private processPendingSubmission(\r\n        submissionToBeProcessed: ProgrammingSubmission | undefined,\r\n        participationId: number,\r\n        exerciseId: number,\r\n        personal: boolean,\r\n    ): Observable<ProgrammingSubmissionStateObj> {\r\n        return of(submissionToBeProcessed).pipe(\r\n            // When a new submission comes in, make sure that a subscription is set up for new incoming submissions.\r\n            // The new submission would then override the current latest pending submission.\r\n            tap(() => {\r\n                this.setupWebsocketSubscriptionForLatestPendingSubmission(participationId, exerciseId, personal);\r\n                if (this.isLocalCIProfile) {\r\n                    this.setupWebsocketSubscriptionForSubmissionProcessing(participationId, exerciseId, personal);\r\n                }\r\n            }),\r\n            // Find out in what state the latest submission is (pending / failed). If the submission is pending, start the result timer.\r\n            map((submission: ProgrammingSubmission | undefined) => {\r\n                if (submission) {\r\n                    if (this.isLocalCIProfile && submission.isProcessing === false && !this.didSubmissionStartProcessing(submission.commitHash!)) {\r\n                        const queueRemainingTime = this.getExpectedRemainingTimeForQueue(submission);\r\n                        if (queueRemainingTime > 0) {\r\n                            this.emitQueuedSubmission(participationId, exerciseId, submission);\r\n                            this.startQueueEstimateTimer(participationId, exerciseId, submission, queueRemainingTime);\r\n                            return {\r\n                                participationId,\r\n                                submission: submissionToBeProcessed,\r\n                                submissionState: ProgrammingSubmissionState.IS_QUEUED,\r\n                            };\r\n                        }\r\n                    } else {\r\n                        let buildTimingInfo: BuildTimingInfo | undefined = {\r\n                            estimatedCompletionDate: submission.estimatedCompletionDate,\r\n                            buildStartDate: submission.buildStartDate,\r\n                        };\r\n                        buildTimingInfo = buildTimingInfo ?? this.startedProcessingCache.get(submission.commitHash!);\r\n                        this.removeSubmissionFromProcessingCache(submission.commitHash!);\r\n                        const remainingTime = this.getExpectedRemainingTimeForBuild(submission);\r\n                        if (remainingTime > 0) {\r\n                            this.emitBuildingSubmission(participationId, exerciseId, submission, buildTimingInfo);\r\n                            this.startResultWaitingTimer(participationId, remainingTime);\r\n                            return { participationId, submission: submissionToBeProcessed, submissionState: ProgrammingSubmissionState.IS_BUILDING_PENDING_SUBMISSION };\r\n                        }\r\n                    }\r\n                    // The server sends the latest submission without a result - so it could be that the result is too old. In this case the error is shown directly.\r\n                    this.emitFailedSubmission(participationId, exerciseId);\r\n                    return { participationId, submission: submissionToBeProcessed, submissionState: ProgrammingSubmissionState.HAS_FAILED_SUBMISSION };\r\n                }\r\n                this.emitNoPendingSubmission(participationId, exerciseId);\r\n                return { participationId, submission: undefined, submissionState: ProgrammingSubmissionState.HAS_NO_PENDING_SUBMISSION };\r\n            }),\r\n            // Now update the exercise build state object and start the build and result subscription regardless of the submission state.\r\n            tap((submissionStateObj: ProgrammingSubmissionStateObj) => {\r\n                const exerciseSubmissionState: ExerciseSubmissionState = { ...(this.exerciseBuildState[exerciseId] || {}), [participationId]: submissionStateObj };\r\n                this.exerciseBuildState = { ...this.exerciseBuildState, [exerciseId]: exerciseSubmissionState };\r\n                this.subscribeForNewResult(participationId, exerciseId, personal);\r\n            }),\r\n        );\r\n    }\r\n\r\n    private mapParticipationIdToNumber(submissions: Array<[string, ProgrammingSubmission | undefined]>) {\r\n        return submissions.map(([participationId, submission]) => [parseInt(participationId, 10), submission]);\r\n    }\r\n\r\n    private mapToExerciseBuildState(acc: ExerciseSubmissionState, val: ProgrammingSubmissionStateObj) {\r\n        if (!Object.keys(val).length) {\r\n            return {};\r\n        }\r\n        const { participationId, submission, submissionState } = val;\r\n        return { ...acc, [participationId]: { participationId, submissionState, submission } };\r\n    }\r\n\r\n    private didSubmissionStartProcessing(commitHash: string): boolean {\r\n        return !!this.startedProcessingCache.get(commitHash);\r\n    }\r\n\r\n    private removeSubmissionFromProcessingCache(commitHash: string): void {\r\n        if (this.startedProcessingCache.has(commitHash)) {\r\n            this.startedProcessingCache.delete(commitHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns programming submissions for exercise from the server\r\n     * @param exerciseId the id of the exercise\r\n     * @param req request parameters\r\n     * @param correctionRound for which to get the Submissions\r\n     */\r\n    getSubmissions(exerciseId: number, req: { submittedOnly?: boolean; assessedByTutor?: boolean }, correctionRound = 0): Observable<HttpResponse<ProgrammingSubmission[]>> {\r\n        const url = `api/programming/exercises/${exerciseId}/programming-submissions`;\r\n        let params = createRequestOption(req);\r\n        if (correctionRound !== 0) {\r\n            params = params.set('correction-round', correctionRound.toString());\r\n        }\r\n\r\n        return this.http\r\n            .get<ProgrammingSubmission[]>(url, {\r\n                params,\r\n                observe: 'response',\r\n            })\r\n            .pipe(map((res: HttpResponse<ProgrammingSubmission[]>) => ProgrammingSubmissionService.convertArrayResponse(res)));\r\n    }\r\n\r\n    /**\r\n     * Returns next programming submission without assessment from the server\r\n     * @param exerciseId the id of the exercise\r\n     * @param lock\r\n     * @param correctionRound for which to get the Submissions\r\n     * @return submission is empty if none are available\r\n     */\r\n    getSubmissionWithoutAssessment(exerciseId: number, lock = false, correctionRound = 0): Observable<ProgrammingSubmission | undefined> {\r\n        const url = `api/programming/exercises/${exerciseId}/programming-submission-without-assessment`;\r\n        let params = new HttpParams();\r\n        if (correctionRound !== 0) {\r\n            params = params.set('correction-round', correctionRound.toString());\r\n        }\r\n        if (lock) {\r\n            params = params.set('lock', 'true');\r\n        }\r\n        return this.http.get<ProgrammingSubmission | undefined>(url, { params });\r\n    }\r\n\r\n    /**\r\n     * Locks the submission of the participation for the user\r\n     * @param submissionId\r\n     * @param correctionRound\r\n     */\r\n    lockAndGetProgrammingSubmissionParticipation(submissionId: number, correctionRound = 0): Observable<ProgrammingSubmission> {\r\n        let params = new HttpParams();\r\n        if (correctionRound > 0) {\r\n            params = params.set('correction-round', correctionRound.toString());\r\n        }\r\n        return this.http.get<ProgrammingSubmission>(`api/programming/programming-submissions/${submissionId}/lock`, { params });\r\n    }\r\n\r\n    private static convertArrayResponse(res: HttpResponse<ProgrammingSubmission[]>): HttpResponse<ProgrammingSubmission[]> {\r\n        const submissions = res.body!;\r\n        const convertedSubmissions: ProgrammingSubmission[] = [];\r\n        for (const submission of submissions) {\r\n            this.convertItemWithLatestSubmissionResultFromServer(submission);\r\n            convertedSubmissions.push({ ...submission });\r\n        }\r\n        return res.clone({ body: convertedSubmissions });\r\n    }\r\n\r\n    private static convertItemWithLatestSubmissionResultFromServer(programmingSubmission: ProgrammingSubmission): ProgrammingSubmission {\r\n        const convertedProgrammingSubmission = Object.assign({}, programmingSubmission);\r\n        setLatestSubmissionResult(convertedProgrammingSubmission, getLatestSubmissionResult(convertedProgrammingSubmission));\r\n        convertedProgrammingSubmission.participation = ParticipationService.convertParticipationDatesFromServer(programmingSubmission.participation);\r\n        return convertedProgrammingSubmission;\r\n    }\r\n\r\n    /**\r\n     * unsubscribe from all websocket topics so that these are not kept after leaving a page who has subscribed before\r\n     * @param exercise\r\n     */\r\n    public unsubscribeAllWebsocketTopics(exercise: Exercise) {\r\n        // TODO: we only should unsubscribe for submissions that belong to the given exerciseId\r\n        Object.values(this.resultSubscriptions).forEach((sub) => sub.unsubscribe());\r\n        this.resultSubscriptions = {};\r\n        Object.values(this.resultTimerSubscriptions).forEach((sub) => sub.unsubscribe());\r\n        this.resultTimerSubscriptions = {};\r\n        Object.values(this.queueEstimateTimerSubscriptions).forEach((sub) => sub.unsubscribe());\r\n        this.queueEstimateTimerSubscriptions = {};\r\n        this.submissionTopicsSubscribed.forEach((topic) => this.websocketService.unsubscribe(topic));\r\n        this.submissionTopicsSubscribed.forEach((_, participationId) => this.participationWebsocketService.unsubscribeForLatestResultOfParticipation(participationId, exercise));\r\n        this.submissionTopicsSubscribed.clear();\r\n        this.submissionProcessingTopicsSubscribed.forEach((topic) => this.websocketService.unsubscribe(topic));\r\n        this.submissionProcessingTopicsSubscribed.clear();\r\n        this.submissionSubjects = {};\r\n        this.exerciseBuildStateSubjects.delete(exercise.id!);\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from the submission\r\n     * @param participationId\r\n     */\r\n    public unsubscribeForLatestSubmissionOfParticipation(participationId: number) {\r\n        const submissionTopic = this.submissionTopicsSubscribed.get(participationId);\r\n        if (submissionTopic) {\r\n            this.submissionTopicsSubscribed.delete(participationId);\r\n            this.resultTimerSubjects.delete(participationId);\r\n            delete this.submissionSubjects[participationId];\r\n\r\n            const openSubscriptionsForTopic = [...this.submissionTopicsSubscribed.values()].filter((topic: string) => topic === submissionTopic).length;\r\n            // Only unsubscribe if no other participations are using this topic\r\n            if (openSubscriptionsForTopic === 0) {\r\n                this.websocketService.unsubscribe(submissionTopic);\r\n            }\r\n        }\r\n        const submissionProcessingTopic = this.submissionProcessingTopicsSubscribed.get(participationId);\r\n        if (submissionProcessingTopic) {\r\n            this.submissionProcessingTopicsSubscribed.delete(participationId);\r\n\r\n            const openSubscriptionsForTopic = [...this.submissionProcessingTopicsSubscribed.values()].filter((topic: string) => topic === submissionProcessingTopic).length;\r\n            // Only unsubscribe if no other participations are using this topic\r\n            const isParcitipationUsingTopic = openSubscriptionsForTopic !== 0;\r\n            if (!isParcitipationUsingTopic) {\r\n                this.websocketService.unsubscribe(submissionProcessingTopic);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the local CI profile to determine which build system is used. Used to set the state in tests.\r\n     * @param isLocalCIProfile\r\n     */\r\n    public setLocalCIProfile(isLocalCIProfile: boolean) {\r\n        this.isLocalCIProfile = isLocalCIProfile;\r\n    }\r\n\r\n    /**\r\n     * Get the local CI profile to determine which build system is used.\r\n     */\r\n    public getIsLocalCIProfile() {\r\n        return this.isLocalCIProfile;\r\n    }\r\n}\r\n"],
  "mappings": "2qBAoBA,IAAYA,EAAZ,SAAYA,EAA0B,CAElCA,OAAAA,EAAA,0BAAA,4BAEAA,EAAA,+BAAA,iCAEAA,EAAA,sBAAA,wBAEAA,EAAA,UAAA,YARQA,CASZ,EATYA,GAA0B,CAAA,CAAA,EA+BhCC,EAA4BC,GACvB,CAAC,CAAEA,EAA8CC,MAe/CC,IAA4B,IAAA,CAAnC,MAAOA,CAA4B,CAC7BC,iBAAmBC,EAAOC,CAAgB,EAC1CC,KAAOF,EAAOG,CAAU,EACxBC,8BAAgCJ,EAAOK,CAA6B,EACpEC,qBAAuBN,EAAOO,CAAuC,EACrEC,eAAiBR,EAAOS,CAAc,EAEvCC,wBAA0B,2CAC1BC,kCAAoC,yCAEnCC,4BAA8B,EAAI,GAAK,IAEvCC,gCAAkC,GAAK,IACvCC,0BAA4B,8CAE5BC,qCAAuC,oDAEvCC,oBAAmE,CAAA,EAEnEC,2BAA6B,IAAIC,IAEjCC,qCAAuC,IAAID,IAG3CE,4BAA8B,IAAIF,IAGlCG,mBAAgH,CAAA,EAEhHC,2BAA6B,IAAIJ,IAEjCK,oBAAsB,IAAIL,IAC1BM,yBAAwE,CAAA,EACxEC,iBAAmB,IAAIC,EAAwB,KAAKd,2BAA2B,EAE/Ee,gCAA+E,CAAA,EAE/EC,wBAA6E,CAAA,EAC7EC,yBAA2B,KAAKjB,4BAChCkB,6BAA+B,KAAKjB,gCAEpCkB,uBAAuD,IAAIb,IAC3Dc,iBAA6BC,OAC7BC,2BAERC,aAAA,CACI,KAAKD,2BAA6B,KAAK1B,eAAe4B,eAAc,EAAGC,UAAWC,GAAe,CAC7F,KAAKC,kBAAkB,CAAC,CAACD,GAAaE,eAAeC,SAASC,CAAe,CAAC,CAClF,CAAC,CACL,CAEAC,aAAW,CACPC,OAAOC,OAAO,KAAK7B,mBAAmB,EAAE8B,QAASC,GAAQA,EAAIC,YAAW,CAAE,EAC1EJ,OAAOC,OAAO,KAAKrB,wBAAwB,EAAEsB,QAASC,GAAQA,EAAIC,YAAW,CAAE,EAC/EJ,OAAOC,OAAO,KAAKlB,+BAA+B,EAAEmB,QAASC,GAAQA,EAAIC,YAAW,CAAE,EACtF,KAAK/B,2BAA2B6B,QAASG,GAAU,KAAKlD,iBAAiBiD,YAAYC,CAAK,CAAC,EAC3F,KAAK9B,qCAAqC2B,QAASG,GAAU,KAAKlD,iBAAiBiD,YAAYC,CAAK,CAAC,EACrG,KAAKf,2BAA2Bc,YAAW,CAC/C,CAEA,IAAIE,oBAAkB,CAClB,OAAO,KAAKtB,uBAChB,CAEA,IAAIsB,mBAAmBA,EAAqE,CACxF,KAAKtB,wBAA0BsB,EAC/B,KAAKC,gBAAe,CACxB,CAMQA,iBAAe,CACnB,IAAMC,EAA0BR,OAAOC,OAAO,KAAKjB,uBAAuB,EAAEyB,OAAO,CAACC,EAAKC,IAA2B,CAChH,IAAMC,EAAgCD,EAChCX,OAAOC,OAAOU,CAAuB,EAAEE,OAAO,CAAC,CAAEC,gBAAAA,CAAe,IAAOA,IAAoBhE,EAA2BiE,8BAA8B,EAAEC,OACtJ,EACN,OAAON,EAAME,CACjB,EAAG,CAAC,EAGJ,KAAK3B,yBAA2B,KAAKjB,4BAA8BiD,KAAKC,MAAMV,EAA0B,GAAG,EAAI,IAAO,GACtH,KAAK3B,kBAAkBsC,KAAK,KAAKlC,wBAAwB,CAC7D,CAaQmC,8CAA8CC,EAAuB,CACzE,OAAO,KAAK/D,KACPgE,IAA2B,uDAAyDD,EAAkB,4BAA4B,EAClIE,KAAKC,EAAW,IAAMC,EAAGpC,MAAS,CAAC,CAAC,CAC7C,CAWQqC,0CAA0CC,EAAkB,CAChE,OAAO,KAAKrE,KACPgE,IAA0D,yCAAyCK,CAAU,6BAA6B,EAC1IJ,KAAKC,EAAW,IAAMC,EAAG,CAAA,CAAE,CAAC,CAAC,CACtC,CAEOG,iDAAiDP,EAAuB,CAC3E,OAAO,KAAK/D,KAAKgE,IAAiB,wDAAyD,CAAEO,OAAQ,CAAER,gBAAAA,CAAe,CAAE,CAAE,EAAEE,KAAKC,EAAW,IAAMC,EAAGpC,MAAS,CAAC,CAAC,CACpK,CASQyC,wBAAwBT,EAAyBU,EAAO,KAAK9C,yBAAwB,CACzF,KAAK+C,wBAAwBX,CAAe,EAC5C,KAAKzC,yBAAyByC,CAAe,EAAIY,EAAMF,CAAI,EACtDR,KACGW,EAAI,IAAK,CACL,IAAMC,EAAqB,KAAKxD,oBAAoB2C,IAAID,CAAe,EACnEc,GACAA,EAAmBhB,KAAK9B,MAAS,CAEzC,CAAC,CAAC,EAELI,UAAS,CAClB,CAEQuC,wBAAwBX,EAAuB,CAC/C,KAAKzC,yBAAyByC,CAAe,GAC7C,KAAKzC,yBAAyByC,CAAe,EAAEjB,YAAW,CAElE,CAEQgC,wBAAwBf,EAAyBM,EAAoBU,EAAmCN,EAAO,KAAK7C,6BAA4B,CACpJ,KAAKoD,wBAAwBjB,CAAe,EAC5C,KAAKtC,gCAAgCsC,CAAe,EAAIY,EAAMF,CAAI,EAAEtC,UAAU,IAAK,CAC/E,IAAM8C,EAAgB,KAAKC,iCAAiCH,CAAU,EAClEE,EAAgB,GAChB,KAAKE,uBAAuBpB,EAAiBM,EAAYU,CAAU,EACnE,KAAKP,wBAAwBT,EAAiBkB,CAAa,GAE3D,KAAKG,qBAAqBrB,EAAiBM,CAAU,EAEzD,KAAKW,wBAAwBjB,CAAe,CAChD,CAAC,CACL,CAEQiB,wBAAwBjB,EAAuB,CACnD,KAAKtC,gCAAgCsC,CAAe,GAAGjB,YAAW,CACtE,CASQuC,qDAAqDtB,EAAyBM,EAAoBiB,EAAiB,CACvH,GAAI,CAAC,KAAKvE,2BAA2BiD,IAAID,CAAe,EAAG,CACvD,IAAIwB,EACAD,EACAC,EAAqB,6BAErBA,EAAqB,KAAK3E,0BAA0B4E,QAAQ,eAAgBnB,EAAWoB,SAAQ,CAAE,EAGrG,KAAKpE,oBAAoBqE,IAAI3B,EAAiB,IAAI4B,CAAoB,EACtE,KAAKzE,4BAA4BwE,IAAI3B,EAAiBM,CAAU,EAG3DuB,MAAMC,KAAK,KAAK9E,2BAA2B4B,OAAM,CAAE,EAAEJ,SAASgD,CAAkB,IACjF,KAAK1F,iBAAiBsC,UAAUoD,CAAkB,EAClD,KAAK1F,iBACAiG,QAAQP,CAAkB,EAC1BtB,KACGW,EAAKG,GAAkE,CACnE,GAAItF,EAAyBsF,CAAU,EAAG,CACtC,IAAMgB,EAA6BhB,EACnC,KAAKK,qBAAqBW,EAA2BhC,gBAAiBM,CAAU,EAChF,MACJ,CACA,IAAM2B,EAAwBjB,EACxBkB,EAA4BD,EAAsBE,cAAeC,GACnEC,EAEJ,GAAI,KAAKtE,iBAAkB,CAEvB,GAD2B,KAAKuE,mCAAmCL,EAAuBC,CAAyB,EAE/G,OAGJG,EAAkB,KAAKvE,uBAAuBmC,IAAIgC,EAAsBM,UAAW,EACnF,KAAKC,oCAAoCP,EAAsBM,UAAW,CAC9E,CAEA,KAAKnB,uBAAuBc,EAA2B,KAAK/E,4BAA4B8C,IAAIiC,CAAyB,EAAIlB,EAAYqB,CAAe,EACpJ,KAAK5B,wBAAwByB,CAAyB,CAC1D,CAAC,CAAC,EAEL9D,UAAS,GAElB,KAAKpB,2BAA2B2E,IAAI3B,EAAiBwB,CAAkB,CAC3E,CACJ,CAEQc,mCAAmCL,EAA8CC,EAAiC,CACtH,IAAIO,EAAqB,GACzB,GAAI,CAACR,EAAsBS,cAAgB,CAAC,KAAKC,6BAA6BV,EAAsBM,UAAW,EAAG,CAC9G,IAAMK,EAAqB,KAAKC,iCAAiCZ,CAAqB,EAClFW,EAAqB,IACrB,KAAKE,qBAAqBZ,EAA2B,KAAK/E,4BAA4B8C,IAAIiC,CAAyB,EAAID,CAAqB,EAC5I,KAAKlB,wBACDmB,EACA,KAAK/E,4BAA4B8C,IAAIiC,CAAyB,EAC9DD,EACAW,CAAkB,EAEtBH,EAAqB,GAE7B,CACA,OAAOA,CACX,CAEQM,kDAAkD/C,EAAyBM,EAAoBiB,EAAiB,CACpH,GAAI,CAAC,KAAKrE,qCAAqC+C,IAAID,CAAe,EAAG,CACjE,IAAIwB,EACAD,EACAC,EAAqB,mCAErBA,EAAqB,KAAK1E,qCAAqC2E,QAAQ,eAAgBnB,EAAWoB,SAAQ,CAAE,EAI1EG,MAAMC,KAAK,KAAK5E,qCAAqC0B,OAAM,CAAE,EAAEJ,SAASgD,CAAkB,IAE5H,KAAK1F,iBAAiBsC,UAAUoD,CAAkB,EAClD,KAAK1F,iBACAiG,QAAQP,CAAkB,EAC1BtB,KACGW,EAAKmC,GAAiD,CAClD,IAAMd,EAA4Bc,EAAqBhD,gBACjDM,EAAa,KAAKnD,4BAA4B8C,IAAIiC,CAAyB,EAEjF,GAAI,CAAC,KAAKe,mBAAmBD,EAAsB1C,EAAY4B,CAAyB,EACpF,OAGJ,IAAMD,EAAwB,KAAKiB,0BAA0BF,CAAoB,EAIjF,GAAI,CAACf,EAAuB,CACxB,KAAKnE,uBAAuB6D,IAAIqB,EAAqBT,WAAa,CAC9DY,wBAAyBH,EAAqBG,wBAC9CC,eAAgBJ,EAAqBI,eACxC,EACD,MACJ,CACAnB,EAAsBS,aAAe,GAErC,IAAML,EAAkB,CACpBc,wBAAyBH,EAAqBG,wBAC9CC,eAAgBJ,EAAqBI,gBAEzC,KAAKZ,oCAAoCP,EAAsBM,UAAW,EAC1E,KAAKtB,wBAAwBiB,CAAyB,EACtD,KAAKd,uBAAuBc,EAA2B5B,EAAY2B,EAAuBI,CAAe,EAEzG,KAAK5B,wBAAwByB,CAAyB,CAC1D,CAAC,CAAC,EAEL9D,UAAS,GAElB,KAAKlB,qCAAqCyE,IAAI3B,EAAiBwB,CAAkB,CACrF,CACJ,CAEQyB,mBAAmBI,EAAwC/C,EAAoBN,EAAuB,CAC1G,IAAMsD,EAAoB,KAAKrE,mBAAmBqB,CAAU,IAAIN,CAAe,GAAGgB,WAElF,OAAKsC,GAAmBC,eACnBF,GAAeE,eAEbC,EAAMH,EAAcE,cAAc,EAAEE,cAAcD,EAAMF,EAAkBC,cAAc,CAAC,EAFrD,GADI,EAInD,CAEQL,0BAA0BF,EAA6C,CAC3E,GAAIA,EAAqB1C,YAAc0C,EAAqBhD,iBAAmBgD,EAAqBT,WAAY,CAC5G,IAAMvB,EAAa,KAAK/B,mBAAmB+D,EAAqB1C,UAAU,IAAI0C,EAAqBhD,eAAe,GAAGgB,WACrH,GAAIA,GAAcA,EAAWuB,aAAeS,EAAqBT,WAC7D,OAAOvB,CAEf,CAEJ,CAUQ0C,sBAAsB1D,EAAyBM,EAAoBiB,EAAiB,CACxF,GAAI,KAAKxE,oBAAoBiD,CAAe,EACxC,OAEJ,IAAM2D,EAAmB,KAAKxH,8BAA8ByH,wCAAwC5D,EAAiBuB,EAAUjB,CAAU,EAAEJ,KAEvIV,EAAQqE,GAA+B,KAAKC,2BAA2BD,EAAQvD,EAAYN,CAAe,CAAC,EAC3G+D,EAAoB,EACpBlD,EAAI,IAAK,CAEL,KAAKmD,wBAAwBhE,EAAiBM,CAAU,CAC5D,CAAC,CAAC,EAIA2D,EAAkB,KAAK3G,oBAAoB2C,IAAID,CAAe,EAAGE,KAEnEgE,EAAU,IAAM,KAAK7H,qBAAqB8H,4BAA4BnE,EAAiB,EAAI,CAAC,EAC5Fa,EAAKgD,GAAkB,CACf,KAAKC,2BAA2BD,EAAQvD,EAAYN,CAAe,EAGnE,KAAK7D,8BAA8BiI,2BAA2BC,EAAAC,EAAA,GAAKT,GAAL,CAAa1B,cAAe,CAAEC,GAAIpC,CAAe,CAAE,EAAE,EAGnH,KAAKqB,qBAAqBrB,EAAiBM,CAAU,CAE7D,CAAC,EACDH,EAAW,KACP,KAAKkB,qBAAqBrB,EAAiBM,CAAU,EAC9CF,EAAGpC,MAAS,EACtB,CAAC,EAGN,KAAKjB,oBAAoBiD,CAAe,EAAIuE,EAAMN,EAAiBN,CAAgB,EAC9EzD,KACGV,EAAO,IAAM,CAAC,CAAC,KAAKP,mBAAmBqB,CAAU,EAAEN,CAAe,CAAC,EACnEa,EAAI,IAAK,CAEL,KAAKI,wBAAwBjB,CAAe,EAC5C,KAAKW,wBAAwBX,CAAe,CAChD,CAAC,CAAC,EAEL5B,UAAS,CAClB,CAEQ0F,2BAA2BD,EAA4BvD,EAAoBN,EAAuB,CACtG,GAAI,CAAC6D,GAAU,CAACA,EAAO7C,WACnB,MAAO,GAEX,GAAM,CAAEA,WAAAA,CAAU,EAAK,KAAK/B,mBAAmBqB,CAAU,EAAEN,CAAe,EAC1E,MAAO,CAAC,CAACgB,GAAc6C,EAAO7C,WAAWoB,KAAOpB,EAAWoB,EAC/D,CAEQ4B,wBAAwBhE,EAAyBM,EAAkB,CACvE,IAAMkE,EAAqB,CAAExE,gBAAAA,EAAiBP,gBAAiBhE,EAA2BgJ,0BAA2BzD,WAAYhD,MAAS,EAC1I,KAAK0G,kBAAkB1E,EAAiBM,EAAYkE,CAAkB,CAC1E,CAEQpD,uBAAuBpB,EAAyBM,EAAoBU,EAAmCqB,EAAiC,CAC5I,IAAMmC,EAAqB,CAAExE,gBAAAA,EAAiBP,gBAAiBhE,EAA2BiE,+BAAgCsB,WAAAA,EAAYqB,gBAAAA,CAAe,EACrJ,KAAKqC,kBAAkB1E,EAAiBM,EAAYkE,CAAkB,CAC1E,CAEQ1B,qBAAqB9C,EAAyBM,EAAoBU,EAAiC,CACvG,IAAMwD,EAAqB,CAAExE,gBAAAA,EAAiBP,gBAAiBhE,EAA2BkJ,UAAW3D,WAAAA,CAAU,EAC/G,KAAK0D,kBAAkB1E,EAAiBM,EAAYkE,CAAkB,CAC1E,CAEQnD,qBAAqBrB,EAAyBM,EAAkB,CACpE,IAAMsE,EAAqB,KAAK3F,mBAAmBqB,CAAU,GAAK,KAAKrB,mBAAmBqB,CAAU,EAAEN,CAAe,EAC/GwE,EAAqB,CACvBxE,gBAAAA,EACAP,gBAAiBhE,EAA2BoJ,sBAC5C7D,WAAY4D,EAAqBA,EAAmB5D,WAAahD,QAErE,KAAK0G,kBAAkB1E,EAAiBM,EAAYkE,CAAkB,CAC1E,CASQE,kBAAkB1E,EAAyBM,EAAoBkE,EAAiD,CAEpH,IAAMM,EAAoB,KAAK1H,mBAAmB4C,CAAe,EAC7D8E,GACAA,EAAkBhF,KAAK0E,CAAkB,EAG7C,KAAKvF,mBAAqBoF,EAAAC,EAAA,GAAK,KAAKrF,oBAAV,CAA8B,CAACqB,CAAU,EAAG+D,EAAAC,EAAA,GAAM,KAAKrF,mBAAmBqB,CAAU,GAAK,CAAA,GAA7C,CAAkD,CAACN,CAAe,EAAGwE,CAAkB,EAAE,GAC/J,IAAMO,EAA4B,KAAK1H,2BAA2B4C,IAAIK,CAAU,EAC5EyE,GACAA,EAA0BjF,KAAK,KAAKb,mBAAmBqB,CAAU,CAAC,CAE1E,CAQQa,iCAAiCH,EAAiC,CACtE,OAAO,KAAKpD,0BAA4BoH,KAAKC,IAAG,EAAKD,KAAKE,MAAMlE,EAAWuC,cAAqB,EACpG,CAEQV,iCAAiC7B,EAAiC,CACtE,OAAO,KAAKnD,8BAAgCmH,KAAKC,IAAG,EAAKD,KAAKE,MAAMlE,EAAWuC,cAAqB,EACxG,CAaO4B,0BAA0BC,EAAwBC,EAAqB,GAAK,CAC1ED,GAGLA,EACK5F,OAAQ8F,GAEDA,EAASC,OAASC,EAAaC,aAI/B,CAACH,EAASI,uBAAyB,CAACJ,EAASI,sBAAsB/F,QAInE,CAAC0F,GAAwB,KAAKjI,mBAAmBkI,EAASI,sBAAuB,CAAC,EAAEtD,EAAG,EAChF,GAGJ,CAAC,CAACkD,EAASI,sBAAsB,CAAC,EAAEC,aAAe,CAAC,CAACL,EAASI,sBAAsB,CAAC,EAAEC,YAAYhG,MAC7G,EACAd,QAASyG,GAAY,CAClB,IAAMnD,EAAgBmD,EAASI,sBAAuB,CAAC,EACjDE,EAAmBzD,EAAcwD,YAAavG,OAAO,CAACyG,EAAS/F,IAAU+F,EAAQzD,GAAMtC,EAAKsC,GAAMyD,EAAU/F,CAAK,EACjHgG,EAAeC,EAAiB5D,EAAc6D,OAAO,EACrDC,EAAsB,CAAC,CAACL,IAAqB,CAACE,GAAiBA,EAAa9E,YAAc8E,EAAa9E,WAAWoB,KAAOwD,EAAiBxD,IAEhJ,KAAKhF,mBAAmB+E,EAAcC,EAAG,EAAI,IAAI3E,EAA2DO,MAAS,EACrH,KAAKkI,yBAAyBD,EAAsBL,EAAmB5H,OAAWmE,EAAcC,GAAKkD,EAASlD,GAAK,EAAI,EAAEhE,UAAS,CACtI,CAAC,CACT,CAsBO+H,4CAA4CnG,EAAyBM,EAAoBiB,EAAmB8D,EAAqB,GAAOe,EAAe,GAAI,CAC9J,IAAMC,EAAU,KAAKjJ,mBAAmB4C,CAAe,EACvD,GAAI,CAACqF,GAAsBgB,EACvB,OAAOA,EAAQC,aAAY,EAAGpG,KAAKV,EAAQ+G,GAAaA,IAAavI,MAAS,CAAC,EAInF,IAAMwI,EAA4B,KAAKnJ,2BAA2B4C,IAAIK,CAAU,EAChF,OAAIkG,EACOA,EAA0BF,aAAY,EAAGpG,KAE5CV,EAAQiH,GAAW,CAAC,CAACA,CAAM,EAC3BvC,EAAWwC,GAAkB,CACzB,IAAMC,EAAqBD,IAAiB1G,CAAe,EAC3D,OAAI2G,EACOvG,EAAGuG,CAAkB,EAGzB,KAAKC,6CAA6C5G,EAAiBM,EAAYiB,EAAU6E,CAAY,CAChH,CAAC,CAAC,EAGH,KAAKQ,6CAA6C5G,EAAiBM,EAAYiB,EAAU6E,CAAY,CAChH,CAEQQ,6CAA6C5G,EAAyBM,EAAoBiB,EAAmB6E,EAAqB,CAGtI,YAAKhJ,mBAAmB4C,CAAe,EAAI,IAAIvC,EAA2DO,MAAS,EAC/GoI,EACA,KAAKrG,8CAA8CC,CAAe,EAC7DE,KAAKgE,EAAWlD,GAAe,KAAKkF,yBAAyBlF,EAAYhB,EAAiBM,EAAYiB,CAAQ,CAAC,CAAC,EAChHnD,UAAS,EAGd,KAAK8H,yBAAyBlI,OAAWgC,EAAiBM,EAAYiB,CAAQ,EAAEnD,UAAS,EAGtF,KAAKhB,mBAAmB4C,CAAe,EAAEsG,aAAY,EAAGpG,KAAKV,EAAQ+G,GAAaA,IAAavI,MAAS,CAAC,CACpH,CAcO6I,6BAA6BvG,EAAkB,CAElD,IAAMwG,EAAoB,KAAKzJ,2BAA2B4C,IAAIK,CAAU,EACxE,OAAIwG,EACOA,EAAkBR,aAAY,EAAGpG,KAAKV,EAAQuH,GAAQA,IAAQ/I,MAAS,CAAC,GAEnF,KAAKX,2BAA2BsE,IAAIrB,EAAY,IAAI7C,EAAqDO,MAAS,CAAC,EACnH,KAAKqC,0CAA0CC,CAAU,EACpDJ,KACG8G,EAAIrI,OAAOsI,OAAO,EAClBD,EAAI,KAAKE,0BAA0B,EACnChD,EAAWyB,GACFA,EAAYhG,OAIVmC,EAAK6D,CAAW,EAAEzF,KACrBgE,EAAU,CAAC,CAAClE,EAAiBgB,CAAU,KACnC,KAAK5D,mBAAmB4C,CAAe,EAAI,IAAIvC,EAA2DO,MAAS,EAC5G,KAAKkI,yBAAyBlF,EAAYhB,EAAiBM,EAAY,EAAK,EACtF,CAAC,EANKF,EAAG,CAAA,CAAE,CAQnB,EACDhB,EAAO,KAAK+H,wBAAyB,CAAA,CAAE,EACvChH,EAAW,IAAMC,EAAG,CAAA,CAAE,CAAC,CAAC,EAE3BhC,UAAWa,GAA+C,CACvD,KAAKA,mBAAqBoF,EAAAC,EAAA,GAAK,KAAKrF,oBAAV,CAA8B,CAACqB,CAAU,EAAGrB,CAAkB,GACxF,KAAK5B,2BAA2B4C,IAAIK,CAAU,GAAGR,KAAKb,CAAkB,CAC5E,CAAC,EACE,KAAK5B,2BACP4C,IAAIK,CAAU,EACdgG,aAAY,EACZpG,KAAKV,EAAQuH,GAAQA,IAAQ/I,MAAS,CAAC,EAChD,CAEAoJ,kBAAgB,CACZ,OAAO,KAAK5J,iBAAiB8I,aAAY,EAAGpG,KAAK6D,EAAoB,CAAE,CAC3E,CAEOsD,aAAarH,EAAyBsH,EAAc,SAAwB,CAC/E,OAAO,KAAKrL,KAAKsL,KAAK,KAAK9K,wBAA0BuD,EAAkB,iCAAiCsH,CAAc,GAAI,CAAA,CAAE,CAChI,CAEOE,mBAAmBxH,EAAyByH,EAAmB,CAClE,IAAMjH,EAAS,IAAIkH,EAAU,EAAG/F,IAAI,aAAc8F,EAAW/F,SAAQ,CAAE,EACvE,OAAO,KAAKzF,KAAKsL,KAAK,KAAK9K,wBAA0BuD,EAAkB,wBAAyB,CAAA,EAAI,CAAEQ,OAAAA,EAAQmH,QAAS,UAAU,CAAE,CACvI,CAEOC,qDAAqDtH,EAAkB,CAC1E,OAAO,KAAKrE,KAAKsL,KAAW,KAAK7K,kCAAoC4D,EAAa,gCAAiC,CAAA,CAAE,CACzH,CAEOuH,kDAAkDvH,EAAoBwH,EAA0B,CACnG,OAAO,KAAK7L,KAAKsL,KAAW,KAAK7K,kCAAoC4D,EAAa,4BAA6BwH,CAAgB,CACnI,CAQOC,yBAAyBzH,EAAoB0H,EAAiC,CACjF,IAAM/I,EAAqB,KAAKA,mBAAmBqB,CAAU,EAC7D,OAAO3B,OAAOsI,QAAQhI,CAAkB,EACnCO,OAAO,CAAC,CAAA,CAAGyI,CAAU,IAAK,CACvB,GAAM,CAAExI,gBAAAA,CAAe,EAAKwI,EAC5B,OAAOxI,IAAoBuI,CAC/B,CAAC,EACAhB,IAAI,CAAC,CAAChH,CAAe,IAAMkI,SAASlI,EAAiB,EAAE,CAAC,CACjE,CAUQkG,yBACJiC,EACAnI,EACAM,EACAiB,EAAiB,CAEjB,OAAOnB,EAAG+H,CAAuB,EAAEjI,KAG/BW,EAAI,IAAK,CACL,KAAKS,qDAAqDtB,EAAiBM,EAAYiB,CAAQ,EAC3F,KAAKxD,kBACL,KAAKgF,kDAAkD/C,EAAiBM,EAAYiB,CAAQ,CAEpG,CAAC,EAEDyF,EAAKhG,GAAiD,CAClD,GAAIA,EAAY,CACZ,GAAI,KAAKjD,kBAAoBiD,EAAW0B,eAAiB,IAAS,CAAC,KAAKC,6BAA6B3B,EAAWuB,UAAW,EAAG,CAC1H,IAAMK,EAAqB,KAAKC,iCAAiC7B,CAAU,EAC3E,GAAI4B,EAAqB,EACrB,YAAKE,qBAAqB9C,EAAiBM,EAAYU,CAAU,EACjE,KAAKD,wBAAwBf,EAAiBM,EAAYU,EAAY4B,CAAkB,EACjF,CACH5C,gBAAAA,EACAgB,WAAYmH,EACZ1I,gBAAiBhE,EAA2BkJ,UAGxD,KAAO,CACH,IAAItC,EAA+C,CAC/Cc,wBAAyBnC,EAAWmC,wBACpCC,eAAgBpC,EAAWoC,gBAE/Bf,EAAkBA,GAAmB,KAAKvE,uBAAuBmC,IAAIe,EAAWuB,UAAW,EAC3F,KAAKC,oCAAoCxB,EAAWuB,UAAW,EAC/D,IAAMrB,EAAgB,KAAKC,iCAAiCH,CAAU,EACtE,GAAIE,EAAgB,EAChB,YAAKE,uBAAuBpB,EAAiBM,EAAYU,EAAYqB,CAAe,EACpF,KAAK5B,wBAAwBT,EAAiBkB,CAAa,EACpD,CAAElB,gBAAAA,EAAiBgB,WAAYmH,EAAyB1I,gBAAiBhE,EAA2BiE,8BAA8B,CAEjJ,CAEA,YAAK2B,qBAAqBrB,EAAiBM,CAAU,EAC9C,CAAEN,gBAAAA,EAAiBgB,WAAYmH,EAAyB1I,gBAAiBhE,EAA2BoJ,qBAAqB,CACpI,CACA,YAAKb,wBAAwBhE,EAAiBM,CAAU,EACjD,CAAEN,gBAAAA,EAAiBgB,WAAYhD,OAAWyB,gBAAiBhE,EAA2BgJ,yBAAyB,CAC1H,CAAC,EAED5D,EAAK+D,GAAqD,CACtD,IAAMtF,EAAmD+E,EAAAC,EAAA,GAAM,KAAKrF,mBAAmBqB,CAAU,GAAK,CAAA,GAA7C,CAAkD,CAACN,CAAe,EAAG4E,CAAkB,GAChJ,KAAK3F,mBAAqBoF,EAAAC,EAAA,GAAK,KAAKrF,oBAAV,CAA8B,CAACqB,CAAU,EAAGhB,CAAuB,GAC7F,KAAKoE,sBAAsB1D,EAAiBM,EAAYiB,CAAQ,CACpE,CAAC,CAAC,CAEV,CAEQ2F,2BAA2BvB,EAA+D,CAC9F,OAAOA,EAAYqB,IAAI,CAAC,CAAChH,EAAiBgB,CAAU,IAAM,CAACkH,SAASlI,EAAiB,EAAE,EAAGgB,CAAU,CAAC,CACzG,CAEQmG,wBAAwB9H,EAA8B0H,EAAkC,CAC5F,GAAI,CAACpI,OAAOyJ,KAAKrB,CAAG,EAAEpH,OAClB,MAAO,CAAA,EAEX,GAAM,CAAEK,gBAAAA,EAAiBgB,WAAAA,EAAYvB,gBAAAA,CAAe,EAAKsH,EACzD,OAAO1C,EAAAC,EAAA,GAAKjF,GAAL,CAAU,CAACW,CAAe,EAAG,CAAEA,gBAAAA,EAAiBP,gBAAAA,EAAiBuB,WAAAA,CAAU,CAAE,EACxF,CAEQ2B,6BAA6BJ,EAAkB,CACnD,MAAO,CAAC,CAAC,KAAKzE,uBAAuBmC,IAAIsC,CAAU,CACvD,CAEQC,oCAAoCD,EAAkB,CACtD,KAAKzE,uBAAuBuK,IAAI9F,CAAU,GAC1C,KAAKzE,uBAAuBwK,OAAO/F,CAAU,CAErD,CAQAgG,eAAejI,EAAoBkI,EAA6DC,EAAkB,EAAC,CAC/G,IAAMC,EAAM,6BAA6BpI,CAAU,2BAC/CE,EAASmI,EAAoBH,CAAG,EACpC,OAAIC,IAAoB,IACpBjI,EAASA,EAAOmB,IAAI,mBAAoB8G,EAAgB/G,SAAQ,CAAE,GAG/D,KAAKzF,KACPgE,IAA6ByI,EAAK,CAC/BlI,OAAAA,EACAmH,QAAS,WACZ,EACAzH,KAAK8G,EAAK4B,GAA+C/M,EAA6BgN,qBAAqBD,CAAG,CAAC,CAAC,CACzH,CASAE,+BAA+BxI,EAAoByI,EAAO,GAAON,EAAkB,EAAC,CAChF,IAAMC,EAAM,6BAA6BpI,CAAU,6CAC/CE,EAAS,IAAIkH,EACjB,OAAIe,IAAoB,IACpBjI,EAASA,EAAOmB,IAAI,mBAAoB8G,EAAgB/G,SAAQ,CAAE,GAElEqH,IACAvI,EAASA,EAAOmB,IAAI,OAAQ,MAAM,GAE/B,KAAK1F,KAAKgE,IAAuCyI,EAAK,CAAElI,OAAAA,CAAM,CAAE,CAC3E,CAOAwI,6CAA6CC,EAAsBR,EAAkB,EAAC,CAClF,IAAIjI,EAAS,IAAIkH,EACjB,OAAIe,EAAkB,IAClBjI,EAASA,EAAOmB,IAAI,mBAAoB8G,EAAgB/G,SAAQ,CAAE,GAE/D,KAAKzF,KAAKgE,IAA2B,2CAA2CgJ,CAAY,QAAS,CAAEzI,OAAAA,CAAM,CAAE,CAC1H,CAEQ,OAAOqI,qBAAqBD,EAA0C,CAC1E,IAAMjD,EAAciD,EAAIM,KAClBC,EAAgD,CAAA,EACtD,QAAWnI,KAAc2E,EACrB,KAAKyD,gDAAgDpI,CAAU,EAC/DmI,EAAqBE,KAAK/E,EAAA,GAAKtD,EAAY,EAE/C,OAAO4H,EAAIU,MAAM,CAAEJ,KAAMC,CAAoB,CAAE,CACnD,CAEQ,OAAOC,gDAAgDnH,EAA4C,CACvG,IAAMsH,EAAiC5K,OAAO6K,OAAO,CAAA,EAAIvH,CAAqB,EAC9EwH,OAAAA,EAA0BF,EAAgCG,EAA0BH,CAA8B,CAAC,EACnHA,EAA+BpH,cAAgBwH,EAAqBC,oCAAoC3H,EAAsBE,aAAa,EACpIoH,CACX,CAMOM,8BAA8BvE,EAAkB,CAEnD3G,OAAOC,OAAO,KAAK7B,mBAAmB,EAAE8B,QAASC,GAAQA,EAAIC,YAAW,CAAE,EAC1E,KAAKhC,oBAAsB,CAAA,EAC3B4B,OAAOC,OAAO,KAAKrB,wBAAwB,EAAEsB,QAASC,GAAQA,EAAIC,YAAW,CAAE,EAC/E,KAAKxB,yBAA2B,CAAA,EAChCoB,OAAOC,OAAO,KAAKlB,+BAA+B,EAAEmB,QAASC,GAAQA,EAAIC,YAAW,CAAE,EACtF,KAAKrB,gCAAkC,CAAA,EACvC,KAAKV,2BAA2B6B,QAASG,GAAU,KAAKlD,iBAAiBiD,YAAYC,CAAK,CAAC,EAC3F,KAAKhC,2BAA2B6B,QAAQ,CAACiL,EAAG9J,IAAoB,KAAK7D,8BAA8B4N,0CAA0C/J,EAAiBsF,CAAQ,CAAC,EACvK,KAAKtI,2BAA2BgN,MAAK,EACrC,KAAK9M,qCAAqC2B,QAASG,GAAU,KAAKlD,iBAAiBiD,YAAYC,CAAK,CAAC,EACrG,KAAK9B,qCAAqC8M,MAAK,EAC/C,KAAK5M,mBAAqB,CAAA,EAC1B,KAAKC,2BAA2BiL,OAAOhD,EAASlD,EAAG,CACvD,CAMO6H,8CAA8CjK,EAAuB,CACxE,IAAMkK,EAAkB,KAAKlN,2BAA2BiD,IAAID,CAAe,EACvEkK,IACA,KAAKlN,2BAA2BsL,OAAOtI,CAAe,EACtD,KAAK1C,oBAAoBgL,OAAOtI,CAAe,EAC/C,OAAO,KAAK5C,mBAAmB4C,CAAe,EAEZ,CAAC,GAAG,KAAKhD,2BAA2B4B,OAAM,CAAE,EAAEY,OAAQR,GAAkBA,IAAUkL,CAAe,EAAEvK,SAEnG,GAC9B,KAAK7D,iBAAiBiD,YAAYmL,CAAe,GAGzD,IAAMC,EAA4B,KAAKjN,qCAAqC+C,IAAID,CAAe,EAC3FmK,IACA,KAAKjN,qCAAqCoL,OAAOtI,CAAe,EAE9B,CAAC,GAAG,KAAK9C,qCAAqC0B,OAAM,CAAE,EAAEY,OAAQR,GAAkBA,IAAUmL,CAAyB,EAAExK,SAEzF,GAE5D,KAAK7D,iBAAiBiD,YAAYoL,CAAyB,EAGvE,CAMO7L,kBAAkBP,EAAyB,CAC9C,KAAKA,iBAAmBA,CAC5B,CAKOqM,qBAAmB,CACtB,OAAO,KAAKrM,gBAChB,4CA/0BSlC,EAA4B,6BAA5BA,EAA4BwO,QAA5BxO,EAA4ByO,UAAAC,WADf,MAAM,CAAA,SACnB1O,CAA4B,GAAA",
  "names": ["ProgrammingSubmissionState", "checkIfSubmissionIsError", "toBeDetermined", "error", "ProgrammingSubmissionService", "websocketService", "inject", "WebsocketService", "http", "HttpClient", "participationWebsocketService", "ParticipationWebsocketService", "participationService", "ProgrammingExerciseParticipationService", "profileService", "ProfileService", "SUBMISSION_RESOURCE_URL", "PROGRAMMING_EXERCISE_RESOURCE_URL", "DEFAULT_EXPECTED_RESULT_ETA", "DEFAULT_EXPECTED_QUEUE_ESTIMATE", "SUBMISSION_TEMPLATE_TOPIC", "SUBMISSION_PROCESSING_TEMPLATE_TOPIC", "resultSubscriptions", "submissionTopicsSubscribed", "Map", "submissionProcessingTopicsSubscribed", "participationIdToExerciseId", "submissionSubjects", "exerciseBuildStateSubjects", "resultTimerSubjects", "resultTimerSubscriptions", "resultEtaSubject", "BehaviorSubject", "queueEstimateTimerSubscriptions", "exerciseBuildStateValue", "currentExpectedResultETA", "currentExpectedQueueEstimate", "startedProcessingCache", "isLocalCIProfile", "undefined", "profileServiceSubscription", "constructor", "getProfileInfo", "subscribe", "profileInfo", "setLocalCIProfile", "activeProfiles", "includes", "PROFILE_LOCALCI", "ngOnDestroy", "Object", "values", "forEach", "sub", "unsubscribe", "topic", "exerciseBuildState", "updateResultEta", "buildingSubmissionCount", "reduce", "acc", "exerciseSubmissionState", "buildingSubmissionsOfExercise", "filter", "submissionState", "IS_BUILDING_PENDING_SUBMISSION", "length", "Math", "floor", "next", "fetchLatestPendingSubmissionByParticipationId", "participationId", "get", "pipe", "catchError", "of", "fetchLatestPendingSubmissionsByExerciseId", "exerciseId", "fetchQueueReleaseDateEstimationByParticipationId", "params", "startResultWaitingTimer", "time", "resetResultWaitingTimer", "timer", "tap", "resultTimerSubject", "startQueueEstimateTimer", "submission", "resetQueueEstimateTimer", "remainingTime", "getExpectedRemainingTimeForBuild", "emitBuildingSubmission", "emitFailedSubmission", "setupWebsocketSubscriptionForLatestPendingSubmission", "personal", "newSubmissionTopic", "replace", "toString", "set", "Subject", "Array", "from", "receive", "programmingSubmissionError", "programmingSubmission", "submissionParticipationId", "participation", "id", "buildTimingInfo", "handleQueuedProgrammingSubmissions", "commitHash", "removeSubmissionFromProcessingCache", "isSubmissionQueued", "isProcessing", "didSubmissionStartProcessing", "queueRemainingTime", "getExpectedRemainingTimeForQueue", "emitQueuedSubmission", "setupWebsocketSubscriptionForSubmissionProcessing", "submissionProcessing", "isNewestSubmission", "getSubmissionByCommitHash", "estimatedCompletionDate", "buildStartDate", "newSubmission", "currentSubmission", "submissionDate", "dayjs", "isSameOrAfter", "subscribeForNewResult", "resultObservable", "subscribeForLatestResultOfParticipation", "result", "isResultOfLatestSubmission", "distinctUntilChanged", "emitNoPendingSubmission", "timerObservable", "switchMap", "getLatestResultWithFeedback", "notifyAllResultSubscribers", "__spreadProps", "__spreadValues", "merge", "newSubmissionState", "HAS_NO_PENDING_SUBMISSION", "notifySubscribers", "IS_QUEUED", "submissionStateObj", "HAS_FAILED_SUBMISSION", "submissionSubject", "exerciseBuildStateSubject", "Date", "now", "parse", "initializeCacheForStudent", "exercises", "forceCacheOverride", "exercise", "type", "ExerciseType", "PROGRAMMING", "studentParticipations", "submissions", "latestSubmission", "current", "latestResult", "findLatestResult", "results", "isPendingSubmission", "processPendingSubmission", "getLatestPendingSubmissionByParticipationId", "fetchPending", "subject", "asObservable", "stateObj", "exercisePreloadingSubject", "states", "exerciseStates", "participationState", "loadLatestPendingSubmissionByParticipationId", "getSubmissionStateOfExercise", "preloadingSubject", "val", "map", "entries", "mapParticipationIdToNumber", "mapToExerciseBuildState", "getResultEtaInMs", "triggerBuild", "submissionType", "post", "triggerFailedBuild", "lastGraded", "HttpParams", "observe", "triggerInstructorBuildForAllParticipationsOfExercise", "triggerInstructorBuildForParticipationsOfExercise", "participationIds", "getSubmissionCountByType", "state", "buildState", "parseInt", "submissionToBeProcessed", "keys", "has", "delete", "getSubmissions", "req", "correctionRound", "url", "createRequestOption", "res", "convertArrayResponse", "getSubmissionWithoutAssessment", "lock", "lockAndGetProgrammingSubmissionParticipation", "submissionId", "body", "convertedSubmissions", "convertItemWithLatestSubmissionResultFromServer", "push", "clone", "convertedProgrammingSubmission", "assign", "setLatestSubmissionResult", "getLatestSubmissionResult", "ParticipationService", "convertParticipationDatesFromServer", "unsubscribeAllWebsocketTopics", "_", "unsubscribeForLatestResultOfParticipation", "clear", "unsubscribeForLatestSubmissionOfParticipation", "submissionTopic", "submissionProcessingTopic", "getIsLocalCIProfile", "factory", "\u0275fac", "providedIn"]
}
